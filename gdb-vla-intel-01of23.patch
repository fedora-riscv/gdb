Subject: [PATCH 01/23] dwarf: add dwarf3 DW_OP_push_object_address opcode
Message-Id: <1401861266-6240-2-git-send-email-keven.boell@intel.com>

The opcode pushes the address of the object being evaluated. The semantic is
equivalent to the implicit push of the base address of a data member location.

2014-05-28  Sanimir Agovic  <sanimir.agovic@intel.com>
            Keven Boell  <keven.boell@intel.com>

	* dwarf2expr.c (execute_stack_op) <DW_OP_push_object_address>: New case.
	* dwarf2expr.h (struct dwarf_expr_context_funcs)
	<DW_OP_push_object_address>: New function pointer get_object_addr.
	* dwarf2loc.c (struct dwarf_expr_baton): Add obj_address.
	(dwarf_expr_get_obj_addr): New function.
	(struct dwarf_expr_context_funcs): Add
	dwarf_expr_get_obj_addr to dwarf_expr_ctx_funcs.
	(dwarf2_evaluate_loc_desc_full): Initialize baton.obj_address.
	(dwarf2_locexpr_baton_eval): Set baton.obj_address to addr.
	(needs_get_obj_addr): New function.
	(struct dwarf_expr_context_funcs): Add needs_get_obj_addr to
	needs_frame_ctx_funcs.

Change-Id: Ied9e1ba632e8d35d0ec00cc832b96d432449fd82

Signed-off-by: Keven Boell <keven.boell@intel.com>
---
 gdb/dwarf2expr.c |    6 ++++++
 gdb/dwarf2expr.h |    4 ----
 gdb/dwarf2loc.c  |   41 +++++++++++++++++++++++++++++++++++++----
 gdb/dwarf2loc.h  |    1 +
 gdb/gdbtypes.c   |   16 ++++++++--------
 5 files changed, 52 insertions(+), 16 deletions(-)

Index: gdb-7.7.90.20140613/gdb/dwarf2expr.c
===================================================================
--- gdb-7.7.90.20140613.orig/gdb/dwarf2expr.c	2014-06-14 15:02:21.484551132 +0200
+++ gdb-7.7.90.20140613/gdb/dwarf2expr.c	2014-06-14 15:02:52.299575369 +0200
@@ -1478,6 +1478,12 @@ execute_stack_op (struct dwarf_expr_cont
 	  }
 	  break;
 
+        case DW_OP_push_object_address:
+	  /* Return the address of the object we are currently observing.  */
+	  result = (ctx->funcs->get_object_address) (ctx->baton);
+	  result_val = value_from_ulongest (address_type, result);
+	  break;
+
 	default:
 	  error (_("Unhandled dwarf expression opcode 0x%x"), op);
 	}
Index: gdb-7.7.90.20140613/gdb/dwarf2expr.h
===================================================================
--- gdb-7.7.90.20140613.orig/gdb/dwarf2expr.h	2014-06-14 15:02:21.485551133 +0200
+++ gdb-7.7.90.20140613/gdb/dwarf2expr.h	2014-06-14 15:02:52.299575369 +0200
@@ -84,12 +84,8 @@ struct dwarf_expr_context_funcs
      This can throw an exception if the index is out of range.  */
   CORE_ADDR (*get_addr_index) (void *baton, unsigned int index);
 
-#if 0
-  /* Not yet implemented.  */
-
   /* Return the `object address' for DW_OP_push_object_address.  */
   CORE_ADDR (*get_object_address) (void *baton);
-#endif
 };
 
 /* The location of a value.  */
Index: gdb-7.7.90.20140613/gdb/dwarf2loc.c
===================================================================
--- gdb-7.7.90.20140613.orig/gdb/dwarf2loc.c	2014-06-14 15:02:21.487551135 +0200
+++ gdb-7.7.90.20140613/gdb/dwarf2loc.c	2014-06-14 15:02:52.301575370 +0200
@@ -306,6 +306,7 @@ struct dwarf_expr_baton
 {
   struct frame_info *frame;
   struct dwarf2_per_cu_data *per_cu;
+  CORE_ADDR obj_address;
 };
 
 /* Helper functions for dwarf2_evaluate_loc_desc.  */
@@ -1209,6 +1210,7 @@ dwarf_expr_push_dwarf_reg_entry_value (s
 
   baton_local.frame = caller_frame;
   baton_local.per_cu = caller_per_cu;
+  baton_local.obj_address = 0;
 
   saved_ctx.gdbarch = ctx->gdbarch;
   saved_ctx.addr_size = ctx->addr_size;
@@ -1238,6 +1240,22 @@ dwarf_expr_get_addr_index (void *baton,
   return dwarf2_read_addr_index (debaton->per_cu, index);
 }
 
+/* Callback function for get_object_address. Return the address of the VLA
+   object.  */
+
+static CORE_ADDR
+dwarf_expr_get_obj_addr (void *baton)
+{
+  struct dwarf_expr_baton *debaton = baton;
+
+  gdb_assert (debaton != NULL);
+
+  if (debaton->obj_address == 0)
+    error (_("Location address is not set."));
+
+  return debaton->obj_address;
+}
+
 /* VALUE must be of type lval_computed with entry_data_value_funcs.  Perform
    the indirect method on it, that is use its stored target value, the sole
    purpose of entry_data_value_funcs..  */
@@ -2206,7 +2224,8 @@ static const struct dwarf_expr_context_f
   dwarf_expr_dwarf_call,
   dwarf_expr_get_base_type,
   dwarf_expr_push_dwarf_reg_entry_value,
-  dwarf_expr_get_addr_index
+  dwarf_expr_get_addr_index,
+  dwarf_expr_get_obj_addr
 };
 
 /* Evaluate a location description, starting at DATA and with length
@@ -2235,6 +2254,7 @@ dwarf2_evaluate_loc_desc_full (struct ty
 
   baton.frame = frame;
   baton.per_cu = per_cu;
+  baton.obj_address = 0;
 
   ctx = new_dwarf_expr_context ();
   old_chain = make_cleanup_free_dwarf_expr_context (ctx);
@@ -2440,6 +2460,7 @@ dwarf2_evaluate_loc_desc (struct type *t
 
 static int
 dwarf2_locexpr_baton_eval (const struct dwarf2_locexpr_baton *dlbaton,
+         CORE_ADDR addr,
 			   CORE_ADDR *valp)
 {
   struct dwarf_expr_context *ctx;
@@ -2455,6 +2476,7 @@ dwarf2_locexpr_baton_eval (const struct
 
   baton.frame = get_selected_frame (NULL);
   baton.per_cu = dlbaton->per_cu;
+  baton.obj_address = addr;
 
   objfile = dwarf2_per_cu_objfile (dlbaton->per_cu);
 
@@ -2495,7 +2517,8 @@ dwarf2_locexpr_baton_eval (const struct
 /* See dwarf2loc.h.  */
 
 int
-dwarf2_evaluate_property (const struct dynamic_prop *prop, CORE_ADDR *value)
+dwarf2_evaluate_property (const struct dynamic_prop *prop, CORE_ADDR address,
+        CORE_ADDR *value)
 {
   if (prop == NULL)
     return 0;
@@ -2506,7 +2529,7 @@ dwarf2_evaluate_property (const struct d
       {
 	const struct dwarf2_property_baton *baton = prop->data.baton;
 
-	if (dwarf2_locexpr_baton_eval (&baton->locexpr, value))
+	if (dwarf2_locexpr_baton_eval (&baton->locexpr, address, value))
 	  {
 	    if (baton->referenced_type)
 	      {
@@ -2657,6 +2680,15 @@ needs_get_addr_index (void *baton, unsig
   return 1;
 }
 
+/* DW_OP_push_object_address has a frame already passed thru.  */
+
+static CORE_ADDR
+needs_get_obj_addr (void *baton)
+{
+  /* Nothing to do.  */
+  return 1;
+}
+
 /* Virtual method table for dwarf2_loc_desc_needs_frame below.  */
 
 static const struct dwarf_expr_context_funcs needs_frame_ctx_funcs =
@@ -2671,7 +2703,8 @@ static const struct dwarf_expr_context_f
   needs_frame_dwarf_call,
   NULL,				/* get_base_type */
   needs_dwarf_reg_entry_value,
-  needs_get_addr_index
+  needs_get_addr_index,
+  needs_get_obj_addr
 };
 
 /* Return non-zero iff the location expression at DATA (length SIZE)
Index: gdb-7.7.90.20140613/gdb/dwarf2loc.h
===================================================================
--- gdb-7.7.90.20140613.orig/gdb/dwarf2loc.h	2014-06-14 15:02:21.488551135 +0200
+++ gdb-7.7.90.20140613/gdb/dwarf2loc.h	2014-06-14 15:02:52.301575370 +0200
@@ -96,6 +96,7 @@ struct value *dwarf2_evaluate_loc_desc (
    into VALUE, otherwise returns 0.  */
 
 int dwarf2_evaluate_property (const struct dynamic_prop *prop,
+			      CORE_ADDR address,
 			      CORE_ADDR *value);
 
 CORE_ADDR dwarf2_read_addr_index (struct dwarf2_per_cu_data *per_cu,
Index: gdb-7.7.90.20140613/gdb/gdbtypes.c
===================================================================
--- gdb-7.7.90.20140613.orig/gdb/gdbtypes.c	2014-06-14 15:02:21.490551137 +0200
+++ gdb-7.7.90.20140613/gdb/gdbtypes.c	2014-06-14 15:03:37.919609955 +0200
@@ -1657,7 +1657,7 @@ is_dynamic_type (struct type *type)
    of that type.  */
 
 static struct type *
-resolve_dynamic_range (struct type *dyn_range_type)
+resolve_dynamic_range (struct type *dyn_range_type, CORE_ADDR addr)
 {
   CORE_ADDR value;
   struct type *static_range_type;
@@ -1668,7 +1668,7 @@ resolve_dynamic_range (struct type *dyn_
   gdb_assert (TYPE_CODE (dyn_range_type) == TYPE_CODE_RANGE);
 
   prop = &TYPE_RANGE_DATA (dyn_range_type)->low;
-  if (dwarf2_evaluate_property (prop, &value))
+  if (dwarf2_evaluate_property (prop, addr, &value))
     {
       low_bound.kind = PROP_CONST;
       low_bound.data.const_val = value;
@@ -1680,7 +1680,7 @@ resolve_dynamic_range (struct type *dyn_
     }
 
   prop = &TYPE_RANGE_DATA (dyn_range_type)->high;
-  if (dwarf2_evaluate_property (prop, &value))
+  if (dwarf2_evaluate_property (prop, addr, &value))
     {
       high_bound.kind = PROP_CONST;
       high_bound.data.const_val = value;
@@ -1707,7 +1707,7 @@ resolve_dynamic_range (struct type *dyn_
    of the associated array.  */
 
 static struct type *
-resolve_dynamic_array (struct type *type)
+resolve_dynamic_array (struct type *type, CORE_ADDR addr)
 {
   CORE_ADDR value;
   struct type *elt_type;
@@ -1718,12 +1718,12 @@ resolve_dynamic_array (struct type *type
 
   elt_type = type;
   range_type = check_typedef (TYPE_INDEX_TYPE (elt_type));
-  range_type = resolve_dynamic_range (range_type);
+  range_type = resolve_dynamic_range (range_type, addr);
 
   ary_dim = check_typedef (TYPE_TARGET_TYPE (elt_type));
 
   if (ary_dim != NULL && TYPE_CODE (ary_dim) == TYPE_CODE_ARRAY)
-    elt_type = resolve_dynamic_array (TYPE_TARGET_TYPE (type));
+    elt_type = resolve_dynamic_array (TYPE_TARGET_TYPE (type), addr);
   else
     elt_type = TYPE_TARGET_TYPE (type);
 
@@ -1853,11 +1853,11 @@ resolve_dynamic_type (struct type *type,
 	}
 
       case TYPE_CODE_ARRAY:
-	resolved_type = resolve_dynamic_array (type);
+	resolved_type = resolve_dynamic_array (type, addr);
 	break;
 
       case TYPE_CODE_RANGE:
-	resolved_type = resolve_dynamic_range (type);
+	resolved_type = resolve_dynamic_range (type, addr);
 	break;
 
     case TYPE_CODE_UNION:
