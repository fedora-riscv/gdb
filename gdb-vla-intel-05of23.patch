Subject: [PATCH 05/23] vla: make field selection work with vla
Message-Id: <1401861266-6240-6-git-send-email-keven.boell@intel.com>

In Fortran vla are pointers to arrays. Thus a
type only contains a pointer to such array and
we need to re-read the field to retrieve the
correct vla.

old (wrong value):
(gdb) p type_var%vla(14)
$1 = 1

new (correct value):
(gdb) p type_var%vla(14)
$1 = 42

2014-05-28  Sanimir Agovic  <sanimir.agovic@intel.com>
            Keven Boell  <keven.boell@intel.com>

	* value.c (value_primitive_field): Re-evaluate
	field value to get the actual value.

Change-Id: Ic22c37324963aca520c52a80fbbd0042d1fddc05

Signed-off-by: Keven Boell <keven.boell@intel.com>
---
 gdb/value.c |   21 +++++++++++++++------
 1 file changed, 15 insertions(+), 6 deletions(-)

diff --git a/gdb/value.c b/gdb/value.c
index 08593b6..1f0d9a4 100644
--- a/gdb/value.c
+++ b/gdb/value.c
@@ -2929,13 +2929,22 @@ value_primitive_field (struct value *arg1, int offset,
 	v = allocate_value_lazy (type);
       else
 	{
-	  v = allocate_value (type);
-	  value_contents_copy_raw (v, value_embedded_offset (v),
-				   arg1, value_embedded_offset (arg1) + offset,
-				   TYPE_LENGTH (type));
+	  if (TYPE_DATA_LOCATION (type)
+	      && TYPE_DATA_LOCATION_KIND (type) == PROP_CONST)
+	    v = value_at_lazy (type, value_address (arg1) + offset);
+	  else
+	    {
+	      v = allocate_value (type);
+	      value_contents_copy_raw (v, value_embedded_offset (v),
+				       arg1, value_embedded_offset (arg1) + offset,
+				       TYPE_LENGTH (type));
+	    }
 	}
-      v->offset = (value_offset (arg1) + offset
-		   + value_embedded_offset (arg1));
+
+      if (!TYPE_DATA_LOCATION (type)
+          || !TYPE_DATA_LOCATION_KIND (type) == PROP_CONST)
+	v->offset = (value_offset (arg1) + offset
+		     + value_embedded_offset (arg1));
     }
   set_value_component_location (v, arg1);
   VALUE_REGNUM (v) = VALUE_REGNUM (arg1);
-- 
1.7.9.5

