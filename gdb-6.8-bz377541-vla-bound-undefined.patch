http://sourceware.org/ml/gdb-cvs/2008-10/msg00019.html

gdb/
2008-10-02  Jan Kratochvil  <jan.kratochvil@redhat.com>

	Replace TYPE_ARRAY_{UPPER,LOWER}_BOUND_TYPE by a bit if {un,}defined.
	* c-typeprint.c (c_type_print_varspec_suffix), m2-typeprint.c
	(m2_array), p-typeprint.c (pascal_type_print_varspec_prefix),
	valops.c (value_cast), varobj.c (c_number_of_children): Replace
	TYPE_ARRAY_UPPER_BOUND_TYPE compared to BOUND_CANNOT_BE_DETERMINED by
	TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED.
	* parse.c (follow_types): Use TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED.
	* f-valprint.c (f77_get_dynamic_upperbound): Replace with ...
	(f77_get_upperbound): ... this function handling now only
	TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED.
	(f77_get_dynamic_lowerbound): Replace with ...
	(f77_get_lowerbound): ... this function handling now only
	TYPE_ARRAY_LOWER_BOUND_IS_UNDEFINED.
	(f77_get_dynamic_length_of_aggregate, f77_create_arrayprint_offset_tbl):
	Update their callers.
	* eval.c (evaluate_subexp_standard): Update their callers.
	* f-lang.h (f77_get_dynamic_upperbound, f77_get_upperbound)
	(f77_get_dynamic_lowerbound, f77_get_lowerbound): Update their
	prototypes.
	(BOUND_FETCH_OK, BOUND_FETCH_ERROR): Remove.
	* f-typeprint.c (f_type_print_varspec_suffix, f_type_print_base): Remove
	the lower_bound_was_default variable.  Update the
	f77_get_dynamic_upperbound, f77_get_upperbound and
	TYPE_ARRAY_UPPER_BOUND_TYPE calls.
	* gdbtypes.c (print_bound_type): Remove the function.
	(recursive_dump_type): Remove its calls printing UPPER_BOUND_TYPE and
	LOWER_BOUND_TYPE.
	* gdbtypes.h (enum array_bound_type): Remove.
	(struct main_type): Remove the fields upper_bound_type and
	lower_bound_type.  Comment the new overload of the field artificial.
	(TYPE_ARRAY_UPPER_BOUND_TYPE): Replace by ...
	(TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED): ... this macro.
	(TYPE_ARRAY_LOWER_BOUND_TYPE): Replace by ...
	(TYPE_ARRAY_LOWER_BOUND_IS_UNDEFINED): ... this macro.

gdb/testsuite/
2008-10-02  Jan Kratochvil  <jan.kratochvil@redhat.com>

	* gdb.base/maint.exp (maint print type): Remove printing
	UPPER_BOUND_TYPE and LOWER_BOUND_TYPE.

[ Ported to gdb-6.8fedora.  ]

--- ./gdb/c-typeprint.c	2008-01-01 23:53:09.000000000 +0100
+++ ./gdb/c-typeprint.c	2008-10-29 10:55:07.000000000 +0100
@@ -542,7 +542,7 @@ c_type_print_varspec_suffix (struct type
 
       fprintf_filtered (stream, "[");
       if (TYPE_LENGTH (TYPE_TARGET_TYPE (type)) > 0
-	&& TYPE_ARRAY_UPPER_BOUND_TYPE (type) != BOUND_CANNOT_BE_DETERMINED)
+	&& !TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED (type))
 	fprintf_filtered (stream, "%d",
 			  (TYPE_LENGTH (type)
 			   / TYPE_LENGTH (TYPE_TARGET_TYPE (type))));
--- ./gdb/eval.c	2008-10-29 10:50:23.000000000 +0100
+++ ./gdb/eval.c	2008-10-29 10:55:07.000000000 +0100
@@ -1674,13 +1674,8 @@ evaluate_subexp_standard (struct type *e
 	/* Internal type of array is arranged right to left */
 	for (i = 0; i < nargs; i++)
 	  {
-	    retcode = f77_get_dynamic_upperbound (tmp_type, &upper);
-	    if (retcode == BOUND_FETCH_ERROR)
-	      error (_("Cannot obtain dynamic upper bound"));
-
-	    retcode = f77_get_dynamic_lowerbound (tmp_type, &lower);
-	    if (retcode == BOUND_FETCH_ERROR)
-	      error (_("Cannot obtain dynamic lower bound"));
+	    upper = f77_get_upperbound (tmp_type);
+	    lower = f77_get_lowerbound (tmp_type);
 
 	    array_size_array[nargs - i - 1] = upper - lower + 1;
 
--- ./gdb/f-lang.h	2008-10-29 10:50:23.000000000 +0100
+++ ./gdb/f-lang.h	2008-10-29 10:55:07.000000000 +0100
@@ -83,9 +83,6 @@ extern SAVED_F77_COMMON_PTR find_common_
 #define BLANK_COMMON_NAME_MF77     "__BLNK__"	/* MF77 assigned  */
 #define BLANK_COMMON_NAME_LOCAL    "__BLANK"	/* Local GDB */
 
-#define BOUND_FETCH_OK 1
-#define BOUND_FETCH_ERROR -999
-
 /* When reasonable array bounds cannot be fetched, such as when 
    you ask to 'mt print symbols' and there is no stack frame and 
    therefore no way of knowing the bounds of stack-based arrays, 
@@ -97,9 +94,9 @@ extern SAVED_F77_COMMON_PTR find_common_
 extern char *real_main_name;	/* Name of main function */
 extern int real_main_c_value;	/* C_value field of main function */
 
-extern int f77_get_dynamic_upperbound (struct type *, int *);
+extern int f77_get_upperbound (struct type *);
 
-extern int f77_get_dynamic_lowerbound (struct type *, int *);
+extern int f77_get_lowerbound (struct type *);
 
 extern void f77_get_dynamic_array_length (struct type *);
 
--- ./gdb/f-typeprint.c	2008-10-29 10:50:23.000000000 +0100
+++ ./gdb/f-typeprint.c	2008-10-29 10:55:07.000000000 +0100
@@ -150,7 +150,6 @@ f_type_print_varspec_suffix (struct type
 			     int show, int passed_a_ptr, int demangled_args)
 {
   int upper_bound, lower_bound;
-  int lower_bound_was_default = 0;
   static int arrayprint_recurse_level = 0;
   int retcode;
 
@@ -173,35 +172,19 @@ f_type_print_varspec_suffix (struct type
       if (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_ARRAY)
 	f_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, 0, 0, 0);
 
-      retcode = f77_get_dynamic_lowerbound (type, &lower_bound);
-
-      lower_bound_was_default = 0;
-
-      if (retcode == BOUND_FETCH_ERROR)
-	fprintf_filtered (stream, "???");
-      else if (lower_bound == 1)	/* The default */
-	lower_bound_was_default = 1;
-      else
-	fprintf_filtered (stream, "%d", lower_bound);
-
-      if (lower_bound_was_default)
-	lower_bound_was_default = 0;
-      else
-	fprintf_filtered (stream, ":");
+      lower_bound = f77_get_lowerbound (type);
+      if (lower_bound != 1)	/* Not the default.  */
+	fprintf_filtered (stream, "%d:", lower_bound);
 
       /* Make sure that, if we have an assumed size array, we
          print out a warning and print the upperbound as '*' */
 
-      if (TYPE_ARRAY_UPPER_BOUND_TYPE (type) == BOUND_CANNOT_BE_DETERMINED)
+      if (TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED (type))
 	fprintf_filtered (stream, "*");
       else
 	{
-	  retcode = f77_get_dynamic_upperbound (type, &upper_bound);
-
-	  if (retcode == BOUND_FETCH_ERROR)
-	    fprintf_filtered (stream, "???");
-	  else
-	    fprintf_filtered (stream, "%d", upper_bound);
+	  upper_bound = f77_get_upperbound (type);
+	  fprintf_filtered (stream, "%d", upper_bound);
 	}
 
       if (TYPE_CODE (TYPE_TARGET_TYPE (type)) != TYPE_CODE_ARRAY)
@@ -351,16 +334,12 @@ f_type_print_base (struct type *type, st
     case TYPE_CODE_STRING:
       /* Strings may have dynamic upperbounds (lengths) like arrays. */
 
-      if (TYPE_ARRAY_UPPER_BOUND_TYPE (type) == BOUND_CANNOT_BE_DETERMINED)
+      if (TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED (type))
 	fprintfi_filtered (level, stream, "character*(*)");
       else
 	{
-	  retcode = f77_get_dynamic_upperbound (type, &upper_bound);
-
-	  if (retcode == BOUND_FETCH_ERROR)
-	    fprintf_filtered (stream, "character*???");
-	  else
-	    fprintf_filtered (stream, "character*%d", upper_bound);
+	  upper_bound = f77_get_upperbound (type);
+	  fprintf_filtered (stream, "character*%d", upper_bound);
 	}
       break;
 
--- ./gdb/f-valprint.c	2008-10-29 10:50:23.000000000 +0100
+++ ./gdb/f-valprint.c	2008-10-29 20:48:30.000000000 +0100
@@ -61,130 +61,28 @@ int f77_array_offset_tbl[MAX_FORTRAN_DIM
 #define F77_DIM_OFFSET(n) (f77_array_offset_tbl[n][0])
 
 int
-f77_get_dynamic_lowerbound (struct type *type, int *lower_bound)
+f77_get_lowerbound (struct type *type)
 {
-  struct frame_info *frame;
-  CORE_ADDR current_frame_addr;
-  CORE_ADDR ptr_to_lower_bound;
-
-  switch (TYPE_ARRAY_LOWER_BOUND_TYPE (type))
-    {
-    case BOUND_BY_VALUE_ON_STACK:
-      frame = deprecated_safe_get_selected_frame ();
-      current_frame_addr = get_frame_base (frame);
-      if (current_frame_addr > 0)
-	{
-	  *lower_bound =
-	    read_memory_integer (current_frame_addr +
-				 TYPE_ARRAY_LOWER_BOUND_VALUE (type),
-				 4);
-	}
-      else
-	{
-	  *lower_bound = DEFAULT_LOWER_BOUND;
-	  return BOUND_FETCH_ERROR;
-	}
-      break;
-
-    case BOUND_SIMPLE:
-      *lower_bound = TYPE_ARRAY_LOWER_BOUND_VALUE (type);
-      break;
-
-    case BOUND_CANNOT_BE_DETERMINED:
-      error (_("Lower bound may not be '*' in F77"));
-      break;
-
-    case BOUND_BY_REF_ON_STACK:
-      frame = deprecated_safe_get_selected_frame ();
-      current_frame_addr = get_frame_base (frame);
-      if (current_frame_addr > 0)
-	{
-	  ptr_to_lower_bound =
-	    read_memory_typed_address (current_frame_addr +
-				       TYPE_ARRAY_LOWER_BOUND_VALUE (type),
-				       builtin_type_void_data_ptr);
-	  *lower_bound = read_memory_integer (ptr_to_lower_bound, 4);
-	}
-      else
-	{
-	  *lower_bound = DEFAULT_LOWER_BOUND;
-	  return BOUND_FETCH_ERROR;
-	}
-      break;
+  if (TYPE_ARRAY_LOWER_BOUND_IS_UNDEFINED (type))
+    error (_("Lower bound may not be '*' in F77"));
 
-    case BOUND_BY_REF_IN_REG:
-    case BOUND_BY_VALUE_IN_REG:
-    default:
-      error (_("??? unhandled dynamic array bound type ???"));
-      break;
-    }
-  return BOUND_FETCH_OK;
+  return TYPE_ARRAY_LOWER_BOUND_VALUE (type);
 }
 
 int
-f77_get_dynamic_upperbound (struct type *type, int *upper_bound)
+f77_get_upperbound (struct type *type)
 {
-  struct frame_info *frame;
-  CORE_ADDR current_frame_addr = 0;
-  CORE_ADDR ptr_to_upper_bound;
-
-  switch (TYPE_ARRAY_UPPER_BOUND_TYPE (type))
-    {
-    case BOUND_BY_VALUE_ON_STACK:
-      frame = deprecated_safe_get_selected_frame ();
-      current_frame_addr = get_frame_base (frame);
-      if (current_frame_addr > 0)
-	{
-	  *upper_bound =
-	    read_memory_integer (current_frame_addr +
-				 TYPE_ARRAY_UPPER_BOUND_VALUE (type),
-				 4);
-	}
-      else
-	{
-	  *upper_bound = DEFAULT_UPPER_BOUND;
-	  return BOUND_FETCH_ERROR;
-	}
-      break;
-
-    case BOUND_SIMPLE:
-      *upper_bound = TYPE_ARRAY_UPPER_BOUND_VALUE (type);
-      break;
-
-    case BOUND_CANNOT_BE_DETERMINED:
-      /* we have an assumed size array on our hands. Assume that 
-         upper_bound == lower_bound so that we show at least 
-         1 element.If the user wants to see more elements, let 
-         him manually ask for 'em and we'll subscript the 
-         array and show him */
-      f77_get_dynamic_lowerbound (type, upper_bound);
-      break;
-
-    case BOUND_BY_REF_ON_STACK:
-      frame = deprecated_safe_get_selected_frame ();
-      current_frame_addr = get_frame_base (frame);
-      if (current_frame_addr > 0)
-	{
-	  ptr_to_upper_bound =
-	    read_memory_typed_address (current_frame_addr +
-				       TYPE_ARRAY_UPPER_BOUND_VALUE (type),
-				       builtin_type_void_data_ptr);
-	  *upper_bound = read_memory_integer (ptr_to_upper_bound, 4);
-	}
-      else
-	{
-	  *upper_bound = DEFAULT_UPPER_BOUND;
-	  return BOUND_FETCH_ERROR;
-	}
-      break;
+  if (TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED (type))
+    {
+      /* We have an assumed size array on our hands.  Assume that
+	 upper_bound == lower_bound so that we show at least 1 element.
+	 If the user wants to see more elements, let him manually ask for 'em
+	 and we'll subscript the array and show him.  */
 
-    case BOUND_BY_REF_IN_REG:
-    case BOUND_BY_VALUE_IN_REG:
-    default:
-      error (_("??? unhandled dynamic array bound type ???"));
-      break;
+      return f77_get_lowerbound (type);
     }
-  return BOUND_FETCH_OK;
+
+  return TYPE_ARRAY_UPPER_BOUND_VALUE (type);
 }
 
 /* Obtain F77 adjustable array dimensions */
@@ -210,13 +108,8 @@ f77_get_dynamic_length_of_aggregate (str
     f77_get_dynamic_length_of_aggregate (TYPE_TARGET_TYPE (type));
 
   /* Recursion ends here, start setting up lengths.  */
-  retcode = f77_get_dynamic_lowerbound (type, &lower_bound);
-  if (retcode == BOUND_FETCH_ERROR)
-    error (_("Cannot obtain valid array lower bound"));
-
-  retcode = f77_get_dynamic_upperbound (type, &upper_bound);
-  if (retcode == BOUND_FETCH_ERROR)
-    error (_("Cannot obtain valid array upper bound"));
+  lower_bound = f77_get_lowerbound (type);
+  upper_bound = f77_get_upperbound (type);
 
   /* Patch in a valid length value. */
 
@@ -239,16 +132,8 @@ f77_create_arrayprint_offset_tbl (struct
 
   while ((TYPE_CODE (tmp_type) == TYPE_CODE_ARRAY))
     {
-      if (TYPE_ARRAY_UPPER_BOUND_TYPE (tmp_type) == BOUND_CANNOT_BE_DETERMINED)
-	fprintf_filtered (stream, "<assumed size array> ");
-
-      retcode = f77_get_dynamic_upperbound (tmp_type, &upper);
-      if (retcode == BOUND_FETCH_ERROR)
-	error (_("Cannot obtain dynamic upper bound"));
-
-      retcode = f77_get_dynamic_lowerbound (tmp_type, &lower);
-      if (retcode == BOUND_FETCH_ERROR)
-	error (_("Cannot obtain dynamic lower bound"));
+      upper = f77_get_upperbound (tmp_type);
+      lower = f77_get_lowerbound (tmp_type);
 
       F77_DIM_SIZE (ndimen) = upper - lower + 1;
 
--- ./gdb/gdbtypes.c	2008-10-29 10:50:23.000000000 +0100
+++ ./gdb/gdbtypes.c	2008-10-29 10:55:07.000000000 +0100
@@ -2529,35 +2529,6 @@ print_cplus_stuff (struct type *type, in
     }
 }
 
-static void
-print_bound_type (int bt)
-{
-  switch (bt)
-    {
-    case BOUND_CANNOT_BE_DETERMINED:
-      printf_filtered ("(BOUND_CANNOT_BE_DETERMINED)");
-      break;
-    case BOUND_BY_REF_ON_STACK:
-      printf_filtered ("(BOUND_BY_REF_ON_STACK)");
-      break;
-    case BOUND_BY_VALUE_ON_STACK:
-      printf_filtered ("(BOUND_BY_VALUE_ON_STACK)");
-      break;
-    case BOUND_BY_REF_IN_REG:
-      printf_filtered ("(BOUND_BY_REF_IN_REG)");
-      break;
-    case BOUND_BY_VALUE_IN_REG:
-      printf_filtered ("(BOUND_BY_VALUE_IN_REG)");
-      break;
-    case BOUND_SIMPLE:
-      printf_filtered ("(BOUND_SIMPLE)");
-      break;
-    default:
-      printf_filtered (_("(unknown bound type)"));
-      break;
-    }
-}
-
 static struct obstack dont_print_type_obstack;
 
 void
@@ -2692,14 +2663,6 @@ recursive_dump_type (struct type *type, 
     }
   puts_filtered ("\n");
   printfi_filtered (spaces, "length %d\n", TYPE_LENGTH (type));
-  printfi_filtered (spaces, "upper_bound_type 0x%x ",
-		    TYPE_ARRAY_UPPER_BOUND_TYPE (type));
-  print_bound_type (TYPE_ARRAY_UPPER_BOUND_TYPE (type));
-  puts_filtered ("\n");
-  printfi_filtered (spaces, "lower_bound_type 0x%x ",
-		    TYPE_ARRAY_LOWER_BOUND_TYPE (type));
-  print_bound_type (TYPE_ARRAY_LOWER_BOUND_TYPE (type));
-  puts_filtered ("\n");
   printfi_filtered (spaces, "objfile ");
   gdb_print_host_address (TYPE_OBJFILE (type), gdb_stdout);
   printf_filtered ("\n");
@@ -2942,10 +2942,6 @@ copy_type_recursive (struct objfile *obj
 
   /* Copy the common fields of types.  */
   TYPE_CODE (new_type) = TYPE_CODE (type);
-  TYPE_ARRAY_UPPER_BOUND_TYPE (new_type) = 
-    TYPE_ARRAY_UPPER_BOUND_TYPE (type);
-  TYPE_ARRAY_LOWER_BOUND_TYPE (new_type) = 
-    TYPE_ARRAY_LOWER_BOUND_TYPE (type);
   if (TYPE_NAME (type))
     TYPE_NAME (new_type) = xstrdup (TYPE_NAME (type));
   if (TYPE_TAG_NAME (type))
--- ./gdb/gdbtypes.h	2008-10-29 10:50:23.000000000 +0100
+++ ./gdb/gdbtypes.h	2008-10-29 10:56:05.000000000 +0100
@@ -310,17 +310,6 @@ enum type_code
 #define TYPE_FLAG_NOTTEXT	(1 << 17)
 #define TYPE_NOTTEXT(t)		(TYPE_FLAGS (t) & TYPE_FLAG_NOTTEXT)
 
-/*  Array bound type.  */
-enum array_bound_type
-{
-  BOUND_SIMPLE = 0,
-  BOUND_BY_VALUE_IN_REG,
-  BOUND_BY_REF_IN_REG,
-  BOUND_BY_VALUE_ON_STACK,
-  BOUND_BY_REF_ON_STACK,
-  BOUND_CANNOT_BE_DETERMINED
-};
-
 /* This structure is space-critical.
    Its layout has been tweaked to reduce the space used.  */
 
@@ -330,12 +319,6 @@ struct main_type
 
   ENUM_BITFIELD(type_code) code : 8;
 
-  /* Array bounds.  These fields appear at this location because
-     they pack nicely here.  */
-
-  ENUM_BITFIELD(array_bound_type) upper_bound_type : 4;
-  ENUM_BITFIELD(array_bound_type) lower_bound_type : 4;
-
   /* Name of this type, or NULL if none.
 
      This is used for printing only, except by poorly designed C++ code.
@@ -437,7 +420,8 @@ struct main_type
 
     /* For a function or member type, this is 1 if the argument is marked
        artificial.  Artificial arguments should not be shown to the
-       user.  */
+       user.  For TYPE_CODE_RANGE it is set if the specific bound is not
+       defined.  */
     unsigned int artificial : 1;
 
     /* This flag is zero for non-static fields, 1 for fields whose location
@@ -802,10 +786,10 @@ extern void allocate_cplus_struct_type (
 
 /* Moto-specific stuff for FORTRAN arrays */
 
-#define TYPE_ARRAY_UPPER_BOUND_TYPE(thistype) \
-	TYPE_MAIN_TYPE(thistype)->upper_bound_type
-#define TYPE_ARRAY_LOWER_BOUND_TYPE(thistype) \
-	TYPE_MAIN_TYPE(thistype)->lower_bound_type
+#define TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED(arraytype) \
+   (TYPE_FIELD_ARTIFICIAL((TYPE_FIELD_TYPE((arraytype),0)),1))
+#define TYPE_ARRAY_LOWER_BOUND_IS_UNDEFINED(arraytype) \
+   (TYPE_FIELD_ARTIFICIAL((TYPE_FIELD_TYPE((arraytype),0)),0))
 
 #define TYPE_ARRAY_UPPER_BOUND_VALUE(arraytype) \
    (TYPE_FIELD_BITPOS((TYPE_FIELD_TYPE((arraytype),0)),1))
--- ./gdb/m2-typeprint.c	2008-01-01 23:53:11.000000000 +0100
+++ ./gdb/m2-typeprint.c	2008-10-29 10:55:12.000000000 +0100
@@ -202,7 +202,7 @@ static void m2_array (struct type *type,
 {
   fprintf_filtered (stream, "ARRAY [");
   if (TYPE_LENGTH (TYPE_TARGET_TYPE (type)) > 0
-      && TYPE_ARRAY_UPPER_BOUND_TYPE (type) != BOUND_CANNOT_BE_DETERMINED)
+      && !TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED (type))
     {
       if (TYPE_INDEX_TYPE (type) != 0)
 	{
--- ./gdb/p-typeprint.c	2008-01-01 23:53:12.000000000 +0100
+++ ./gdb/p-typeprint.c	2008-10-29 10:55:12.000000000 +0100
@@ -251,7 +251,7 @@ pascal_type_print_varspec_prefix (struct
 	fprintf_filtered (stream, "(");
       fprintf_filtered (stream, "array ");
       if (TYPE_LENGTH (TYPE_TARGET_TYPE (type)) > 0
-	&& TYPE_ARRAY_UPPER_BOUND_TYPE (type) != BOUND_CANNOT_BE_DETERMINED)
+	&& !TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED (type))
 	fprintf_filtered (stream, "[%d..%d] ",
 			  TYPE_ARRAY_LOWER_BOUND_VALUE (type),
 			  TYPE_ARRAY_UPPER_BOUND_VALUE (type)
--- ./gdb/parse.c	2008-10-29 10:47:18.000000000 +0100
+++ ./gdb/parse.c	2008-10-29 10:55:12.000000000 +0100
@@ -1175,8 +1175,7 @@ follow_types (struct type *follow_type)
 	  create_array_type ((struct type *) NULL,
 			     follow_type, range_type);
 	if (array_size < 0)
-	  TYPE_ARRAY_UPPER_BOUND_TYPE (follow_type)
-	    = BOUND_CANNOT_BE_DETERMINED;
+	  TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED (follow_type) = 1;
 	break;
       case tp_function:
 	/* FIXME-type-allocation: need a way to free this type when we are
--- ./gdb/testsuite/gdb.base/maint.exp	2008-01-28 19:06:59.000000000 +0100
+++ ./gdb/testsuite/gdb.base/maint.exp	2008-10-29 20:50:33.000000000 +0100
@@ -404,7 +404,7 @@ gdb_expect  {
 
 send_gdb "maint print type argc\n"
 gdb_expect  {
-        -re "type node $hex\r\nname .int. \\($hex\\)\r\ntagname .<NULL>. \\($hex\\)\r\ncode $hex \\(TYPE_CODE_INT\\)\r\nlength \[24\]\r\nupper_bound_type $hex \\(BOUND_SIMPLE\\)\r\nlower_bound_type $hex \\(BOUND_SIMPLE\\)\r\nobjfile $hex\r\ntarget_type $hex\r\npointer_type $hex\r\nreference_type $hex\r\ntype_chain $hex\r\ninstance_flags $hex\r\nflags $hex\r\nnfields 0 $hex\r\nvptr_basetype $hex\r\nvptr_fieldno -1\r\ntype_specific $hex\r\n$gdb_prompt $"\
+        -re "type node $hex\r\nname .int. \\($hex\\)\r\ntagname .<NULL>. \\($hex\\)\r\ncode $hex \\(TYPE_CODE_INT\\)\r\nlength \[24\]\r\nobjfile $hex\r\ntarget_type $hex\r\npointer_type $hex\r\nreference_type $hex\r\ntype_chain $hex\r\ninstance_flags $hex\r\nflags $hex\r\nnfields 0 $hex\r\nvptr_basetype $hex\r\nvptr_fieldno -1\r\ntype_specific $hex\r\n$gdb_prompt $"\
                         { pass "maint print type" }
         -re ".*$gdb_prompt $"       { fail "maint print type" }
         timeout         { fail "(timeout) maint print type" }
--- ./gdb/valops.c	2008-10-29 10:50:23.000000000 +0100
+++ ./gdb/valops.c	2008-10-29 10:55:12.000000000 +0100
@@ -291,8 +291,7 @@ value_cast (struct type *type, struct va
     {
       struct type *element_type = TYPE_TARGET_TYPE (type);
       unsigned element_length = TYPE_LENGTH (check_typedef (element_type));
-      if (element_length > 0
-	&& TYPE_ARRAY_UPPER_BOUND_TYPE (type) == BOUND_CANNOT_BE_DETERMINED)
+      if (element_length > 0 && TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED (type))
 	{
 	  struct type *range_type = TYPE_INDEX_TYPE (type);
 	  int val_length = TYPE_LENGTH (type2);
--- ./gdb/varobj.c	2008-10-29 10:47:21.000000000 +0100
+++ ./gdb/varobj.c	2008-10-29 10:55:12.000000000 +0100
@@ -1988,7 +1988,7 @@ c_number_of_children (struct varobj *var
     {
     case TYPE_CODE_ARRAY:
       if (TYPE_LENGTH (type) > 0 && TYPE_LENGTH (target) > 0
-	  && TYPE_ARRAY_UPPER_BOUND_TYPE (type) != BOUND_CANNOT_BE_DETERMINED)
+	  && !TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED (type))
 	children = TYPE_LENGTH (type) / TYPE_LENGTH (target);
       else
 	/* If we don't know how many elements there are, don't display
