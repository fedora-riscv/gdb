https://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=109921


2007-01-09  Jan Kratochvil  <jan.kratochvil@redhat.com>

	* buildsym.c (start_subfile_index): Renamed `start_subfile' now
	supporting the FILE_INDEX parameter.
	(start_subfile): Backward compatible stub for `start_subfile_index'.
	(end_symtab): Resolve new SYMBOL.FILE.SYMTAB from SYMBOL.FILE.INDEX.
	Substitute possibly missing DIRNAME from the CU's main file DIRNAME.
	Clear `subfiles' variable as its data have been deallocated.
	* buildsym.h (struct subfile): New field `file_index'.
	(start_subfile_index): New prototype.
	* dwarf2read.c (add_file_name): Ensure subfile has been founded.
	(dwarf_decode_lines): Specify the new FILE_INDEX parameter.
	(dwarf2_start_subfile): New FILE_INDEX parameter.
	(new_symbol): Extract `DW_AT_decl_file' DWARF 2 information entry.
	* symtab.c (lookup_symbol): Override by the new SYMBOL.FILE.SYMTAB.
	(search_symbols): Likewise.
	* symtab.h (struct symbol): New fields FILE.INDEX and FILE.SYMTAB.
	(SYMBOL_FILE_INDEX, SYMBOL_FILE_SYMTAB): New macros.


--- ./gdb/buildsym.c	2005-12-17 22:33:59.000000000 +0000
+++ ./gdb/buildsym.c	2007-01-09 08:30:38.000000000 +0000
@@ -535,7 +535,7 @@ make_blockvector (struct objfile *objfil
    the directory in which it resides (or NULL if not known).  */
 
 void
-start_subfile (char *name, char *dirname)
+start_subfile_index (char *name, char *dirname, unsigned file_index)
 {
   struct subfile *subfile;
 
@@ -547,6 +547,17 @@ start_subfile (char *name, char *dirname
       if (FILENAME_CMP (subfile->name, name) == 0)
 	{
 	  current_subfile = subfile;
+
+	  if (subfile->file_index != 0 && file_index != 0
+	      && subfile->file_index != file_index)
+	    complaint (&symfile_complaints, _("Filenames indexing conflict: "
+	               "name \"%s\" dir \"%s\" index %u vs. "
+		       "name \"%s\" dir \"%s\" index %u"),
+		       subfile->name, subfile->dirname, subfile->file_index,
+		       name, dirname, file_index);
+	  if (subfile->file_index == 0)
+	    subfile->file_index = file_index;
+
 	  return;
 	}
     }
@@ -562,6 +573,7 @@ start_subfile (char *name, char *dirname
   current_subfile = subfile;
 
   /* Save its name and compilation directory name */
+  subfile->file_index = file_index;
   subfile->name = (name == NULL) ? NULL : savestring (name, strlen (name));
   subfile->dirname =
     (dirname == NULL) ? NULL : savestring (dirname, strlen (dirname));
@@ -617,6 +629,13 @@ start_subfile (char *name, char *dirname
     }
 }
 
+/* Backward compatibility.  */
+void
+start_subfile (char *name, char *dirname)
+{
+  start_subfile_index (name, dirname, 0);
+}
+
 /* For stabs readers, the first N_SO symbol is assumed to be the
    source file name, and the subfile struct is initialized using that
    assumption.  If another N_SO symbol is later seen, immediately
@@ -816,9 +835,12 @@ end_symtab (CORE_ADDR end_addr, struct o
 {
   struct symtab *symtab = NULL;
   struct blockvector *blockvector;
-  struct subfile *subfile;
+  struct subfile *subfile, *subfile_main;
   struct context_stack *cstk;
   struct subfile *nextsub;
+  int subfiles_count;
+  struct symtab **file_index_to_symtab;
+  size_t file_index_to_symtab_size;
 
   /* Finish the lexical context of the last function in the file; pop
      the context stack.  */
@@ -916,6 +938,18 @@ end_symtab (CORE_ADDR end_addr, struct o
 #endif
   PROCESS_LINENUMBER_HOOK ();	/* Needed for xcoff. */
 
+  /* Get the last subfile s SUBFILE_MAIN which is the main file of CU.
+     Count SUBFILES_COUNT.
+     Start with 1 as we do not iterate past the last item.  */
+  subfiles_count = 1;
+  for (subfile_main = subfiles; subfile_main && subfile_main->next;
+       subfile_main = subfile_main->next)
+    subfiles_count++;
+
+  file_index_to_symtab_size = sizeof (*file_index_to_symtab) * subfiles_count;
+  file_index_to_symtab = xmalloc (file_index_to_symtab_size);
+  memset ((char *) file_index_to_symtab, 0, file_index_to_symtab_size);
+
   /* Now create the symtab objects proper, one for each subfile.  */
   /* (The main file is the last one on the chain.)  */
 
@@ -976,6 +1010,16 @@ end_symtab (CORE_ADDR end_addr, struct o
 			       strlen (subfile->dirname) + 1);
 	      strcpy (symtab->dirname, subfile->dirname);
 	    }
+	  /* Non-primary subfiles may miss COMP_DIR resulting in NULL
+	     DIRNAME and so default it from the CU file - SUBFILE_MAIN.  */
+	  else if (subfile_main->dirname)
+	    {
+	      /* Reallocate the dirname on the symbol obstack */
+	      symtab->dirname = (char *)
+		obstack_alloc (&objfile->objfile_obstack,
+			       strlen (subfile_main->dirname) + 1);
+	      strcpy (symtab->dirname, subfile_main->dirname);
+	    }
 	  else
 	    {
 	      symtab->dirname = NULL;
@@ -1004,6 +1048,13 @@ end_symtab (CORE_ADDR end_addr, struct o
 	     but the main file.  */
 
 	  symtab->primary = 0;
+
+	  /* It may be zero for files unlisted in File Table.  */
+	  if (subfile->file_index)
+	    {
+	      gdb_assert (subfile->file_index <= subfiles_count);
+	      file_index_to_symtab[subfile->file_index - 1] = symtab;
+	    }
 	}
       if (subfile->name != NULL)
 	{
@@ -1032,9 +1083,40 @@ end_symtab (CORE_ADDR end_addr, struct o
       symtab->primary = 1;
     }
 
+  /* Resolve `struct symbol.file.index' into `struct symbol.file.symtab'.  */
+  if (blockvector)
+    {
+      int block_i;
+
+      for (block_i = 0; block_i < BLOCKVECTOR_NBLOCKS (blockvector); block_i++)
+	{
+	  struct symbol *sym;
+	  struct dict_iterator iter;
+
+	  for (sym = dict_iterator_first (BLOCK_DICT
+		       (BLOCKVECTOR_BLOCK (blockvector, block_i)), &iter);
+	       sym != NULL;
+	       sym = dict_iterator_next (&iter))
+	    {
+	      /* Beware the ordering as `sym->file' is a union.  */
+	      if (SYMBOL_FILE_INDEX (sym)
+		  && file_index_to_symtab[SYMBOL_FILE_INDEX (sym) - 1])
+	        SYMBOL_FILE_SYMTAB (sym) = file_index_to_symtab
+					     [SYMBOL_FILE_INDEX (sym) - 1];
+	      else
+	        {
+		  /* Default to the primary symbol table, never use NULL.  */
+		  SYMBOL_FILE_SYMTAB (sym) = symtab;
+		}
+	    }
+	}
+    }
+
+  xfree (file_index_to_symtab);
   last_source_file = NULL;
   current_subfile = NULL;
   pending_macros = NULL;
+  subfiles = NULL;
 
   return symtab;
 }
--- ./gdb/buildsym.h	2005-12-17 22:33:59.000000000 +0000
+++ ./gdb/buildsym.h	2007-01-09 08:17:17.000000000 +0000
@@ -63,6 +63,7 @@ EXTERN CORE_ADDR last_source_start_addr;
 struct subfile
   {
     struct subfile *next;
+    unsigned file_index;
     char *name;
     char *dirname;
     struct linetable *line_vector;
@@ -240,6 +241,9 @@ extern void finish_block (struct symbol 
 
 extern void really_free_pendings (void *dummy);
 
+extern void start_subfile_index (char *name, char *dirname,
+				 unsigned file_index);
+
 extern void start_subfile (char *name, char *dirname);
 
 extern void patch_subfile_names (struct subfile *subfile, char *name);
--- ./gdb/dwarf2read.c	2007-01-08 22:28:24.000000000 +0000
+++ ./gdb/dwarf2read.c	2007-01-09 08:58:41.000000000 +0000
@@ -847,7 +847,7 @@ static struct line_header *(dwarf_decode
 static void dwarf_decode_lines (struct line_header *, char *, bfd *,
 				struct dwarf2_cu *, struct partial_symtab *);
 
-static void dwarf2_start_subfile (char *, char *, char *);
+static void dwarf2_start_subfile (char *, char *, char *, unsigned);
 
 static struct symbol *new_symbol (struct die_info *, struct type *,
 				  struct dwarf2_cu *);
@@ -6321,6 +6321,7 @@ add_file_name (struct line_header *lh,
                unsigned int length)
 {
   struct file_entry *fe;
+  char *dir = NULL;
 
   /* Grow the array if necessary.  */
   if (lh->file_names_size == 0)
@@ -6343,6 +6344,10 @@ add_file_name (struct line_header *lh,
   fe->mod_time = mod_time;
   fe->length = length;
   fe->included_p = 0;
+
+  if (dir_index)
+    dir = lh->include_dirs[dir_index - 1];
+  dwarf2_start_subfile (name, dir, NULL, lh->num_file_names);
 }
  
 
@@ -6560,7 +6565,7 @@ dwarf_decode_lines (struct line_header *
           if (fe->dir_index)
             dir = lh->include_dirs[fe->dir_index - 1];
 
-	  dwarf2_start_subfile (fe->name, dir, comp_dir);
+	  dwarf2_start_subfile (fe->name, dir, comp_dir, file);
 	}
 
       /* Decode the table.  */
@@ -6661,7 +6666,7 @@ dwarf_decode_lines (struct line_header *
                   dir = lh->include_dirs[fe->dir_index - 1];
 
                 if (!decode_for_pst_p)
-                  dwarf2_start_subfile (fe->name, dir, comp_dir);
+                  dwarf2_start_subfile (fe->name, dir, comp_dir, file);
               }
 	      break;
 	    case DW_LNS_set_column:
@@ -6764,7 +6769,8 @@ dwarf_decode_lines (struct line_header *
    subfile's name.  */
 
 static void
-dwarf2_start_subfile (char *filename, char *dirname, char *comp_dir)
+dwarf2_start_subfile (char *filename, char *dirname, char *comp_dir,
+		      unsigned file_index)
 {
   char *fullname;
 
@@ -6783,7 +6789,7 @@ dwarf2_start_subfile (char *filename, ch
   else
     fullname = filename;
 
-  start_subfile (fullname, comp_dir);
+  start_subfile_index (fullname, comp_dir, file_index);
 
   if (fullname != filename)
     xfree (fullname);
@@ -6892,6 +6898,13 @@ new_symbol (struct die_info *die, struct
 	{
 	  SYMBOL_LINE (sym) = DW_UNSND (attr);
 	}
+      attr = dwarf2_attr (die, DW_AT_decl_file, cu);
+      if (attr)
+	{
+	  /* Do not yet search `objfile->symtabs' here as they still do not
+	     have filled in their FILE.INDEX fields.  */
+	  SYMBOL_FILE_INDEX (sym) = DW_UNSND (attr);
+	}
       switch (die->tag)
 	{
 	case DW_TAG_label:
--- ./gdb/symtab.c	2007-01-08 22:28:25.000000000 +0000
+++ ./gdb/symtab.c	2007-01-09 08:19:05.000000000 +0000
@@ -1129,6 +1129,10 @@ lookup_symbol (const char *name, const s
   if (needtofreename)
     xfree (demangled_name);
 
+  /* Override the returned symtab with optional symbol's specific one.  */
+  if (returnval != NULL && symtab != NULL)
+    *symtab = SYMBOL_FILE_SYMTAB (returnval);
+
   return returnval;	 
 }
 
@@ -3235,7 +3239,7 @@ search_symbols (char *regexp, domain_enu
 	  ALL_BLOCK_SYMBOLS (b, iter, sym)
 	    {
 	      QUIT;
-	      if (file_matches (s->filename, files, nfiles)
+	      if (file_matches (SYMBOL_FILE_SYMTAB (sym)->filename, files, nfiles)
 		  && ((regexp == NULL
 		       || re_exec (SYMBOL_NATURAL_NAME (sym)) != 0)
 		      && ((kind == VARIABLES_DOMAIN && SYMBOL_CLASS (sym) != LOC_TYPEDEF
@@ -3248,7 +3252,7 @@ search_symbols (char *regexp, domain_enu
 		  /* match */
 		  psr = (struct symbol_search *) xmalloc (sizeof (struct symbol_search));
 		  psr->block = i;
-		  psr->symtab = s;
+		  psr->symtab = SYMBOL_FILE_SYMTAB (sym);
 		  psr->symbol = sym;
 		  psr->msymbol = NULL;
 		  psr->next = NULL;
--- ./gdb/symtab.h	2007-01-08 22:28:25.000000000 +0000
+++ ./gdb/symtab.h	2007-01-09 08:44:02.000000000 +0000
@@ -623,6 +623,18 @@ struct symbol
 
   ENUM_BITFIELD(address_class) aclass : 6;
 
+  /* File name it comes from.  Use with `line' below.
+     FILE.INDEX is zero if the symbol's specific file is not known and in such
+     case we later default to the main file of the compilation unit.
+     FILE.SYMTAB gets resolved during end_symtab() and it is never NULL.  */
+
+  union
+  {
+    unsigned index;
+    struct symtab *symtab;
+  }
+  file;
+
   /* Line number of definition.  FIXME:  Should we really make the assumption
      that nobody will try to debug files longer than 64K lines?  What about
      machine generated programs? */
@@ -663,6 +675,8 @@ struct symbol
 #define SYMBOL_DOMAIN(symbol)	(symbol)->domain
 #define SYMBOL_CLASS(symbol)		(symbol)->aclass
 #define SYMBOL_TYPE(symbol)		(symbol)->type
+#define SYMBOL_FILE_INDEX(symbol)	(symbol)->file.index
+#define SYMBOL_FILE_SYMTAB(symbol)	(symbol)->file.symtab
 #define SYMBOL_LINE(symbol)		(symbol)->line
 #define SYMBOL_BASEREG(symbol)		(symbol)->aux_value.basereg
 #define SYMBOL_OBJFILE(symbol)          (symbol)->aux_value.objfile
