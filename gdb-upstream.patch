[COMMIT PATCH] Avoid invalid pointer to pointer conversions.
http://sourceware.org/ml/gdb-patches/2013-03/msg00449.html
http://sourceware.org/ml/gdb-cvs/2013-03/msg00093.html

### src/gdb/ChangeLog	2013/03/11 12:20:45	1.15252
### src/gdb/ChangeLog	2013/03/11 12:22:16	1.15253
## -1,3 +1,15 @@
+2013-03-11  Pedro Alves  <palves@redhat.com>
+
+	* charset.c (convert_between_encodings): Don't cast between
+	different pointer to pointer types.  Instead, make the 'inp' local
+	be of the type iconv expects.
+	(wchar_iterate): Don't cast between different pointer to pointer
+	types.  Instead, use new pointer local of the type iconv expects.
+	* target.c (target_read_stralloc, target_fileio_read_stralloc):
+	Add new local of type char pointer, and use it to get a
+	char/string view of the byte buffer, instead of casting between
+	pointer to pointer types.
+
 2013-03-11  Hafiz Abid Qadeer  <abidh@codesourcery.com>
 
 	* remote.c (remote_set_trace_buffer_size): Move != operator
--- src/gdb/charset.c	2013/03/07 19:10:46	1.54
+++ src/gdb/charset.c	2013/03/11 12:22:20	1.55
@@ -474,7 +474,7 @@
   iconv_t desc;
   struct cleanup *cleanups;
   size_t inleft;
-  char *inp;
+  ICONV_CONST char *inp;
   unsigned int space_request;
 
   /* Often, the host and target charsets will be the same.  */
@@ -490,7 +490,7 @@
   cleanups = make_cleanup (cleanup_iconv, &desc);
 
   inleft = num_bytes;
-  inp = (char *) bytes;
+  inp = (ICONV_CONST char *) bytes;
 
   space_request = num_bytes;
 
@@ -506,7 +506,7 @@
       outp = obstack_base (output) + old_size;
       outleft = space_request;
 
-      r = iconv (desc, (ICONV_CONST char **) &inp, &inleft, &outp, &outleft);
+      r = iconv (desc, &inp, &inleft, &outp, &outleft);
 
       /* Now make sure that the object on the obstack only includes
 	 bytes we have converted.  */
@@ -640,14 +640,15 @@
   out_request = 1;
   while (iter->bytes > 0)
     {
+      ICONV_CONST char *inptr = (ICONV_CONST char *) iter->input;
       char *outptr = (char *) &iter->out[0];
       const gdb_byte *orig_inptr = iter->input;
       size_t orig_in = iter->bytes;
       size_t out_avail = out_request * sizeof (gdb_wchar_t);
       size_t num;
-      size_t r = iconv (iter->desc,
-			(ICONV_CONST char **) &iter->input, 
-			&iter->bytes, &outptr, &out_avail);
+      size_t r = iconv (iter->desc, &inptr, &iter->bytes, &outptr, &out_avail);
+
+      iter->input = (gdb_byte *) inptr;
 
       if (r == (size_t) -1)
 	{
--- src/gdb/target.c	2013/03/11 08:50:05	1.328
+++ src/gdb/target.c	2013/03/11 12:22:20	1.329
@@ -2378,11 +2378,12 @@
 target_read_stralloc (struct target_ops *ops, enum target_object object,
 		      const char *annex)
 {
-  char *buffer;
+  gdb_byte *buffer;
+  char *bufstr;
   LONGEST i, transferred;
 
-  transferred = target_read_alloc_1 (ops, object, annex,
-				     (gdb_byte **) &buffer, 1);
+  transferred = target_read_alloc_1 (ops, object, annex, &buffer, 1);
+  bufstr = (char *) buffer;
 
   if (transferred < 0)
     return NULL;
@@ -2390,11 +2391,11 @@
   if (transferred == 0)
     return xstrdup ("");
 
-  buffer[transferred] = 0;
+  bufstr[transferred] = 0;
 
   /* Check for embedded NUL bytes; but allow trailing NULs.  */
-  for (i = strlen (buffer); i < transferred; i++)
-    if (buffer[i] != 0)
+  for (i = strlen (bufstr); i < transferred; i++)
+    if (bufstr[i] != 0)
       {
 	warning (_("target object %d, annex %s, "
 		   "contained unexpected null characters"),
@@ -2402,7 +2403,7 @@
 	break;
       }
 
-  return buffer;
+  return bufstr;
 }
 
 /* Memory transfer methods.  */
@@ -3542,11 +3543,12 @@
 char *
 target_fileio_read_stralloc (const char *filename)
 {
-  char *buffer;
+  gdb_byte *buffer;
+  char *bufstr;
   LONGEST i, transferred;
 
-  transferred = target_fileio_read_alloc_1 (filename,
-					    (gdb_byte **) &buffer, 1);
+  transferred = target_fileio_read_alloc_1 (filename, &buffer, 1);
+  bufstr = (char *) buffer;
 
   if (transferred < 0)
     return NULL;
@@ -3554,11 +3556,11 @@
   if (transferred == 0)
     return xstrdup ("");
 
-  buffer[transferred] = 0;
+  bufstr[transferred] = 0;
 
   /* Check for embedded NUL bytes; but allow trailing NULs.  */
-  for (i = strlen (buffer); i < transferred; i++)
-    if (buffer[i] != 0)
+  for (i = strlen (bufstr); i < transferred; i++)
+    if (bufstr[i] != 0)
       {
 	warning (_("target file %s "
 		   "contained unexpected null characters"),
@@ -3566,7 +3568,7 @@
 	break;
       }
 
-  return buffer;
+  return bufstr;
 }
 
 
