FYI: fix possible crash in find_charset_names
http://sourceware.org/ml/gdb-patches/2012-02/msg00073.html
http://sourceware.org/ml/gdb-cvs/2012-02/msg00037.html
https://bugzilla.redhat.com/show_bug.cgi?id=786091

### src/gdb/ChangeLog	2012/02/07 04:48:14	1.13810
### src/gdb/ChangeLog	2012/02/07 15:42:33	1.13811
## -1,3 +1,7 @@
+2012-02-07  Tom Tromey  <tromey@redhat.com>
+
+	* charset.c (find_charset_names): Check 'in' against NULL.
+
 2012-02-06  Doug Evans  <dje@google.com>
 
 	* gdbtypes.h (struct main_type): Change type of name,tag_name,
--- src/gdb/charset.c	2012/01/24 21:36:37	1.47
+++ src/gdb/charset.c	2012/02/07 15:42:39	1.48
@@ -839,7 +839,7 @@
 	 parse the glibc and libiconv formats; feel free to add others
 	 as needed.  */
 
-      while (!feof (in))
+      while (in != NULL && !feof (in))
 	{
 	  /* The size of buf is chosen arbitrarily.  */
 	  char buf[1024];



http://sourceware.org/ml/gdb-patches/2012-02/msg00151.html
Subject: [patch] ppc-linux-nat.c: Fix gcc-4.7 aliasing warnings

Hi,

ppc-linux-nat.c: In function 'fetch_register':
ppc-linux-nat.c:598:9: error: dereferencing type-punned pointer will break strict-aliasing rules [-Werror=strict-aliasing]
ppc-linux-nat.c: In function 'store_register':
ppc-linux-nat.c:1078:8: error: dereferencing type-punned pointer will break strict-aliasing rules [-Werror=strict-aliasing]

gcc-4.7.0-0.10.fc17.ppc64

Probably clear, I looked at making it using union instead of memcpy but that
would be too ugly.

No regressions on ppc64-fedorarawhide-linux-gnu only for gdb.base/*.exp.

I will check it in.


Thanks,
Jan


gdb/
2012-02-09  Jan Kratochvil  <jan.kratochvil@redhat.com>

	* ppc-linux-nat.c (fetch_register, store_register): Fix GCC aliasing
	compilation warning.

--- a/gdb/ppc-linux-nat.c
+++ b/gdb/ppc-linux-nat.c
@@ -593,9 +593,10 @@ fetch_register (struct regcache *regcache, int tid, int regno)
        bytes_transferred < register_size (gdbarch, regno);
        bytes_transferred += sizeof (long))
     {
+      long l;
+
       errno = 0;
-      *(long *) &buf[bytes_transferred]
-        = ptrace (PTRACE_PEEKUSER, tid, (PTRACE_TYPE_ARG3) regaddr, 0);
+      l = ptrace (PTRACE_PEEKUSER, tid, (PTRACE_TYPE_ARG3) regaddr, 0);
       regaddr += sizeof (long);
       if (errno != 0)
 	{
@@ -604,6 +605,7 @@ fetch_register (struct regcache *regcache, int tid, int regno)
 		   gdbarch_register_name (gdbarch, regno), regno);
 	  perror_with_name (message);
 	}
+      memcpy (&buf[bytes_transferred], &l, sizeof (l));
     }
 
   /* Now supply the register.  Keep in mind that the regcache's idea
@@ -1073,9 +1075,11 @@ store_register (const struct regcache *regcache, int tid, int regno)
 
   for (i = 0; i < bytes_to_transfer; i += sizeof (long))
     {
+      long l;
+
+      memcpy (&l, &buf[i], sizeof (l));
       errno = 0;
-      ptrace (PTRACE_POKEUSER, tid, (PTRACE_TYPE_ARG3) regaddr,
-	      *(long *) &buf[i]);
+      ptrace (PTRACE_POKEUSER, tid, (PTRACE_TYPE_ARG3) regaddr, l);
       regaddr += sizeof (long);
 
       if (errno == EIO 



http://sourceware.org/ml/gdb-patches/2012-02/msg00409.html
Subject: FYI: remove extraneous block from dw2_map_symtabs_matching_filename
http://sourceware.org/ml/gdb-cvs/2012-02/msg00117.html
commit 61d8161b33b1e7dbc80ba6f7a92500a1594da55c

### src/gdb/ChangeLog	2012/02/20 09:42:34	1.13845
### src/gdb/ChangeLog	2012/02/20 19:24:34	1.13846
## -1,3 +1,8 @@
+2012-02-20  Tom Tromey  <tromey@redhat.com>
+
+	* dwarf2read.c (dw2_map_symtabs_matching_filename): Remove
+	extraneous block.
+
 2012-02-20  Tristan Gingold  <gingold@adacore.com>
 
 	* darwin-nat.h (enum darwin_msg_state): Add comments.
--- src/gdb/dwarf2read.c	2012/02/07 04:48:19	1.612
+++ src/gdb/dwarf2read.c	2012/02/20 19:24:39	1.613
@@ -2437,13 +2437,6 @@
 		return 1;
 	    }
 
-	    {
-	      if (dw2_map_expand_apply (objfile, per_cu,
-					name, full_path, real_path,
-					callback, data))
-		return 1;
-	    }
-
 	  /* Before we invoke realpath, which can get expensive when many
 	     files are involved, do a quick comparison of the basenames.  */
 	  if (! basenames_may_differ



FYI: fix some performance bugs with .gdb_index
http://sourceware.org/ml/gdb-patches/2012-02/msg00413.html
http://sourceware.org/ml/gdb-cvs/2012-02/msg00119.html

### src/gdb/ChangeLog	2012/02/20 19:44:00	1.13847
### src/gdb/ChangeLog	2012/02/20 20:56:12	1.13848
## -1,3 +1,10 @@
+2012-02-20  Tom Tromey  <tromey@redhat.com>
+
+	PR gdb/13498:
+	* dwarf2read.c (dw2_expand_symtabs_matching): Only visit a
+	particular set of file names once.
+	(dw2_map_symbol_filenames): Likewise.
+
 2012-02-20  Jan Kratochvil  <jan.kratochvil@redhat.com>
 
 	Code cleanup.
--- src/gdb/dwarf2read.c	2012/02/20 19:24:39	1.613
+++ src/gdb/dwarf2read.c	2012/02/20 20:56:12	1.614
@@ -2700,32 +2700,63 @@
   index = dwarf2_per_objfile->index_table;
 
   if (file_matcher != NULL)
-    for (i = 0; i < (dwarf2_per_objfile->n_comp_units
-		     + dwarf2_per_objfile->n_type_units); ++i)
-      {
-	int j;
-	struct dwarf2_per_cu_data *per_cu = dw2_get_cu (i);
-	struct quick_file_names *file_data;
+    {
+      struct cleanup *cleanup;
+      htab_t visited_found, visited_not_found;
 
-	per_cu->v.quick->mark = 0;
+      visited_found = htab_create_alloc (10,
+					 htab_hash_pointer, htab_eq_pointer,
+					 NULL, xcalloc, xfree);
+      cleanup = make_cleanup_htab_delete (visited_found);
+      visited_not_found = htab_create_alloc (10,
+					     htab_hash_pointer, htab_eq_pointer,
+					     NULL, xcalloc, xfree);
+      make_cleanup_htab_delete (visited_not_found);
 
-	/* We only need to look at symtabs not already expanded.  */
-	if (per_cu->v.quick->symtab)
-	  continue;
+      for (i = 0; i < (dwarf2_per_objfile->n_comp_units
+		       + dwarf2_per_objfile->n_type_units); ++i)
+	{
+	  int j;
+	  struct dwarf2_per_cu_data *per_cu = dw2_get_cu (i);
+	  struct quick_file_names *file_data;
+	  void **slot;
 
-	file_data = dw2_get_file_names (objfile, per_cu);
-	if (file_data == NULL)
-	  continue;
+	  per_cu->v.quick->mark = 0;
 
-	for (j = 0; j < file_data->num_file_names; ++j)
-	  {
-	    if (file_matcher (file_data->file_names[j], data))
-	      {
-		per_cu->v.quick->mark = 1;
-		break;
-	      }
-	  }
-      }
+	  /* We only need to look at symtabs not already expanded.  */
+	  if (per_cu->v.quick->symtab)
+	    continue;
+
+	  file_data = dw2_get_file_names (objfile, per_cu);
+	  if (file_data == NULL)
+	    continue;
+
+	  if (htab_find (visited_not_found, file_data) != NULL)
+	    continue;
+	  else if (htab_find (visited_found, file_data) != NULL)
+	    {
+	      per_cu->v.quick->mark = 1;
+	      continue;
+	    }
+
+	  for (j = 0; j < file_data->num_file_names; ++j)
+	    {
+	      if (file_matcher (file_data->file_names[j], data))
+		{
+		  per_cu->v.quick->mark = 1;
+		  break;
+		}
+	    }
+
+	  slot = htab_find_slot (per_cu->v.quick->mark
+				 ? visited_found
+				 : visited_not_found,
+				 file_data, INSERT);
+	  *slot = file_data;
+	}
+
+      do_cleanups (cleanup);
+    }
 
   for (iter = 0; iter < index->symbol_table_slots; ++iter)
     {
@@ -2787,15 +2818,35 @@
 			  void *data, int need_fullname)
 {
   int i;
+  struct cleanup *cleanup;
+  htab_t visited = htab_create_alloc (10, htab_hash_pointer, htab_eq_pointer,
+				      NULL, xcalloc, xfree);
 
+  cleanup = make_cleanup_htab_delete (visited);
   dw2_setup (objfile);
 
+  /* We can ignore file names coming from already-expanded CUs.  */
+  for (i = 0; i < (dwarf2_per_objfile->n_comp_units
+		   + dwarf2_per_objfile->n_type_units); ++i)
+    {
+      struct dwarf2_per_cu_data *per_cu = dw2_get_cu (i);
+
+      if (per_cu->v.quick->symtab)
+	{
+	  void **slot = htab_find_slot (visited, per_cu->v.quick->file_names,
+					INSERT);
+
+	  *slot = per_cu->v.quick->file_names;
+	}
+    }
+
   for (i = 0; i < (dwarf2_per_objfile->n_comp_units
 		   + dwarf2_per_objfile->n_type_units); ++i)
     {
       int j;
       struct dwarf2_per_cu_data *per_cu = dw2_get_cu (i);
       struct quick_file_names *file_data;
+      void **slot;
 
       /* We only need to look at symtabs not already expanded.  */
       if (per_cu->v.quick->symtab)
@@ -2805,6 +2856,14 @@
       if (file_data == NULL)
 	continue;
 
+      slot = htab_find_slot (visited, file_data, INSERT);
+      if (*slot)
+	{
+	  /* Already visited.  */
+	  continue;
+	}
+      *slot = file_data;
+
       for (j = 0; j < file_data->num_file_names; ++j)
 	{
 	  const char *this_real_name;
@@ -2816,6 +2875,8 @@
 	  (*fun) (file_data->file_names[j], this_real_name, data);
 	}
     }
+
+  do_cleanups (cleanup);
 }
 
 static int



http://sourceware.org/ml/gdb-cvs/2012-09/msg00081.html

### src/gdb/ChangeLog	2012/09/17 07:14:54	1.14469.2.32
### src/gdb/ChangeLog	2012/09/17 07:17:25	1.14469.2.33
## -1,4 +1,11 @@
 2012-09-17  Jan Kratochvil  <jan.kratochvil@redhat.com>
+
+	PR 14119
+	* frame.c (skip_inlined_frames): Skip also TAILCALL_FRAME frames.
+	(frame_pop): Drop also TAILCALL_FRAME frames.
+	* infcmd.c (finish_command): Ignore also TAILCALL_FRAME frames.
+
+2012-09-17  Jan Kratochvil  <jan.kratochvil@redhat.com>
 	    Pedro Alves  <palves@redhat.com>
 
 	PR 14548
--- src/gdb/frame.c	2012/03/01 20:48:56	1.306
+++ src/gdb/frame.c	2012/09/17 07:17:27	1.306.2.1
@@ -309,7 +309,8 @@
 static struct frame_info *
 skip_inlined_frames (struct frame_info *frame)
 {
-  while (get_frame_type (frame) == INLINE_FRAME)
+  while (get_frame_type (frame) == INLINE_FRAME
+	 || get_frame_type (frame) == TAILCALL_FRAME)
     frame = get_prev_frame (frame);
 
   return frame;
@@ -814,6 +815,11 @@
   if (!prev_frame)
     error (_("Cannot pop the initial frame."));
 
+  /* Ignore TAILCALL_FRAME type frames, they were executed already before
+     entering THISFRAME.  */
+  while (get_frame_type (prev_frame) == TAILCALL_FRAME)
+    prev_frame = get_prev_frame (prev_frame);
+
   /* Make a copy of all the register values unwound from this frame.
      Save them in a scratch buffer so that there isn't a race between
      trying to extract the old values from the current regcache while
--- src/gdb/infcmd.c	2012/06/29 22:46:44	1.306
+++ src/gdb/infcmd.c	2012/09/17 07:17:27	1.306.2.1
@@ -1777,6 +1777,11 @@
       return;
     }
 
+  /* Ignore TAILCALL_FRAME type frames, they were executed already before
+     entering THISFRAME.  */
+  while (get_frame_type (frame) == TAILCALL_FRAME)
+    frame = get_prev_frame (frame);
+
   /* Find the function we will return from.  */
 
   function = find_pc_function (get_frame_pc (get_selected_frame (NULL)));
### src/gdb/testsuite/ChangeLog	2012/09/17 07:14:55	1.3295.2.22
### src/gdb/testsuite/ChangeLog	2012/09/17 07:17:27	1.3295.2.23
## -1,5 +1,15 @@
 2012-09-17  Jan Kratochvil  <jan.kratochvil@redhat.com>
 
+	PR 14119
+	* gdb.arch/amd64-tailcall-ret.S: New file.
+	* gdb.arch/amd64-tailcall-ret.c: New file.
+	* gdb.arch/amd64-tailcall-ret.exp: New file.
+	* gdb.reverse/amd64-tailcall-reverse.S: New file.
+	* gdb.reverse/amd64-tailcall-reverse.c: New file.
+	* gdb.reverse/amd64-tailcall-reverse.exp: New file.
+
+2012-09-17  Jan Kratochvil  <jan.kratochvil@redhat.com>
+
 	PR 14548
 	* gdb.reverse/singlejmp-reverse-nodebug.S: New file.
 	* gdb.reverse/singlejmp-reverse-nodebug.c: New file.
--- src/gdb/testsuite/gdb.arch/amd64-tailcall-ret.S
+++ src/gdb/testsuite/gdb.arch/amd64-tailcall-ret.S	2013-01-13 07:24:23.894972000 +0000
@@ -0,0 +1,357 @@
+/* This testcase is part of GDB, the GNU debugger.
+
+   Copyright 2012 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* This source file was generated by:
+   gcc -o gdb.arch/amd64-tailcall-ret.S gdb.arch/amd64-tailcall-ret.c -Wall -S -dA -O2 -g
+   */
+
+	.file	"amd64-tailcall-ret.c"
+	.text
+.Ltext0:
+	.p2align 4,,15
+	.type	g, @function
+g:
+.LFB0:
+	.file 1 "gdb.arch/amd64-tailcall-ret.c"
+	# gdb.arch/amd64-tailcall-ret.c:22
+	.loc 1 22 0
+	.cfi_startproc
+# BLOCK 2 freq:10000 seq:0
+# PRED: ENTRY [100.0%]  (fallthru)
+	# gdb.arch/amd64-tailcall-ret.c:23
+	.loc 1 23 0
+	movl	$2, v(%rip)
+# SUCC: EXIT [100.0%] 
+	ret
+	.cfi_endproc
+.LFE0:
+	.size	g, .-g
+	.p2align 4,,15
+	.type	f, @function
+f:
+.LFB1:
+	# gdb.arch/amd64-tailcall-ret.c:28
+	.loc 1 28 0
+	.cfi_startproc
+# BLOCK 2 freq:10000 seq:0
+# PRED: ENTRY [100.0%]  (fallthru)
+	# gdb.arch/amd64-tailcall-ret.c:29
+	.loc 1 29 0
+	jmp	g
+# SUCC: EXIT [100.0%]  (ab,sibcall)
+.LVL0:
+	.cfi_endproc
+.LFE1:
+	.size	f, .-f
+	.section	.text.startup,"ax",@progbits
+	.p2align 4,,15
+	.globl	main
+	.type	main, @function
+main:
+.LFB2:
+	# gdb.arch/amd64-tailcall-ret.c:34
+	.loc 1 34 0
+	.cfi_startproc
+# BLOCK 2 freq:10000 seq:0
+# PRED: ENTRY [100.0%]  (fallthru)
+	# gdb.arch/amd64-tailcall-ret.c:35
+	.loc 1 35 0
+	call	f
+.LVL1:
+	# gdb.arch/amd64-tailcall-ret.c:36
+	.loc 1 36 0
+	call	f
+.LVL2:
+	# gdb.arch/amd64-tailcall-ret.c:37
+	.loc 1 37 0
+	movl	$3, v(%rip)
+	# gdb.arch/amd64-tailcall-ret.c:39
+	.loc 1 39 0
+	xorl	%eax, %eax
+# SUCC: EXIT [100.0%] 
+	ret
+	.cfi_endproc
+.LFE2:
+	.size	main, .-main
+	.comm	v,4,4
+	.text
+.Letext0:
+	.section	.debug_info,"",@progbits
+.Ldebug_info0:
+	.long	0xd5	# Length of Compilation Unit Info
+	.value	0x2	# DWARF version number
+	.long	.Ldebug_abbrev0	# Offset Into Abbrev. Section
+	.byte	0x8	# Pointer Size (in bytes)
+	.uleb128 0x1	# (DIE (0xb) DW_TAG_compile_unit)
+	.long	.LASF0	# DW_AT_producer: "GNU C 4.7.2 20120911 (prerelease)"
+	.byte	0x1	# DW_AT_language
+	.long	.LASF1	# DW_AT_name: "gdb.arch/amd64-tailcall-ret.c"
+	.long	.LASF2	# DW_AT_comp_dir: ""
+	.long	.Ldebug_ranges0+0	# DW_AT_ranges
+	.quad	0	# DW_AT_low_pc
+	.quad	0	# DW_AT_entry_pc
+	.long	.Ldebug_line0	# DW_AT_stmt_list
+	.uleb128 0x2	# (DIE (0x31) DW_TAG_subprogram)
+	.ascii "g\0"	# DW_AT_name
+	.byte	0x1	# DW_AT_decl_file (gdb.arch/amd64-tailcall-ret.c)
+	.byte	0x15	# DW_AT_decl_line
+	.byte	0x1	# DW_AT_prototyped
+	.quad	.LFB0	# DW_AT_low_pc
+	.quad	.LFE0	# DW_AT_high_pc
+	.byte	0x2	# DW_AT_frame_base
+	.byte	0x77	# DW_OP_breg7
+	.sleb128 8
+	.byte	0x1	# DW_AT_GNU_all_call_sites
+	.uleb128 0x3	# (DIE (0x4b) DW_TAG_subprogram)
+	.ascii "f\0"	# DW_AT_name
+	.byte	0x1	# DW_AT_decl_file (gdb.arch/amd64-tailcall-ret.c)
+	.byte	0x1b	# DW_AT_decl_line
+	.byte	0x1	# DW_AT_prototyped
+	.quad	.LFB1	# DW_AT_low_pc
+	.quad	.LFE1	# DW_AT_high_pc
+	.byte	0x2	# DW_AT_frame_base
+	.byte	0x77	# DW_OP_breg7
+	.sleb128 8
+	.byte	0x1	# DW_AT_GNU_all_call_sites
+	.long	0x78	# DW_AT_sibling
+	.uleb128 0x4	# (DIE (0x69) DW_TAG_GNU_call_site)
+	.quad	.LVL0	# DW_AT_low_pc
+	.byte	0x1	# DW_AT_GNU_tail_call
+	.long	0x31	# DW_AT_abstract_origin
+	.byte	0	# end of children of DIE 0x4b
+	.uleb128 0x5	# (DIE (0x78) DW_TAG_subprogram)
+	.byte	0x1	# DW_AT_external
+	.long	.LASF3	# DW_AT_name: "main"
+	.byte	0x1	# DW_AT_decl_file (gdb.arch/amd64-tailcall-ret.c)
+	.byte	0x21	# DW_AT_decl_line
+	.byte	0x1	# DW_AT_prototyped
+	.long	0xb8	# DW_AT_type
+	.quad	.LFB2	# DW_AT_low_pc
+	.quad	.LFE2	# DW_AT_high_pc
+	.byte	0x2	# DW_AT_frame_base
+	.byte	0x77	# DW_OP_breg7
+	.sleb128 8
+	.byte	0x1	# DW_AT_GNU_all_call_sites
+	.long	0xb8	# DW_AT_sibling
+	.uleb128 0x6	# (DIE (0x9d) DW_TAG_GNU_call_site)
+	.quad	.LVL1	# DW_AT_low_pc
+	.long	0x4b	# DW_AT_abstract_origin
+	.uleb128 0x6	# (DIE (0xaa) DW_TAG_GNU_call_site)
+	.quad	.LVL2	# DW_AT_low_pc
+	.long	0x4b	# DW_AT_abstract_origin
+	.byte	0	# end of children of DIE 0x78
+	.uleb128 0x7	# (DIE (0xb8) DW_TAG_base_type)
+	.byte	0x4	# DW_AT_byte_size
+	.byte	0x5	# DW_AT_encoding
+	.ascii "int\0"	# DW_AT_name
+	.uleb128 0x8	# (DIE (0xbf) DW_TAG_variable)
+	.ascii "v\0"	# DW_AT_name
+	.byte	0x1	# DW_AT_decl_file (gdb.arch/amd64-tailcall-ret.c)
+	.byte	0x12	# DW_AT_decl_line
+	.long	0xd3	# DW_AT_type
+	.byte	0x1	# DW_AT_external
+	.byte	0x9	# DW_AT_location
+	.byte	0x3	# DW_OP_addr
+	.quad	v
+	.uleb128 0x9	# (DIE (0xd3) DW_TAG_volatile_type)
+	.long	0xb8	# DW_AT_type
+	.byte	0	# end of children of DIE 0xb
+	.section	.debug_abbrev,"",@progbits
+.Ldebug_abbrev0:
+	.uleb128 0x1	# (abbrev code)
+	.uleb128 0x11	# (TAG: DW_TAG_compile_unit)
+	.byte	0x1	# DW_children_yes
+	.uleb128 0x25	# (DW_AT_producer)
+	.uleb128 0xe	# (DW_FORM_strp)
+	.uleb128 0x13	# (DW_AT_language)
+	.uleb128 0xb	# (DW_FORM_data1)
+	.uleb128 0x3	# (DW_AT_name)
+	.uleb128 0xe	# (DW_FORM_strp)
+	.uleb128 0x1b	# (DW_AT_comp_dir)
+	.uleb128 0xe	# (DW_FORM_strp)
+	.uleb128 0x55	# (DW_AT_ranges)
+	.uleb128 0x6	# (DW_FORM_data4)
+	.uleb128 0x11	# (DW_AT_low_pc)
+	.uleb128 0x1	# (DW_FORM_addr)
+	.uleb128 0x52	# (DW_AT_entry_pc)
+	.uleb128 0x1	# (DW_FORM_addr)
+	.uleb128 0x10	# (DW_AT_stmt_list)
+	.uleb128 0x6	# (DW_FORM_data4)
+	.byte	0
+	.byte	0
+	.uleb128 0x2	# (abbrev code)
+	.uleb128 0x2e	# (TAG: DW_TAG_subprogram)
+	.byte	0	# DW_children_no
+	.uleb128 0x3	# (DW_AT_name)
+	.uleb128 0x8	# (DW_FORM_string)
+	.uleb128 0x3a	# (DW_AT_decl_file)
+	.uleb128 0xb	# (DW_FORM_data1)
+	.uleb128 0x3b	# (DW_AT_decl_line)
+	.uleb128 0xb	# (DW_FORM_data1)
+	.uleb128 0x27	# (DW_AT_prototyped)
+	.uleb128 0xc	# (DW_FORM_flag)
+	.uleb128 0x11	# (DW_AT_low_pc)
+	.uleb128 0x1	# (DW_FORM_addr)
+	.uleb128 0x12	# (DW_AT_high_pc)
+	.uleb128 0x1	# (DW_FORM_addr)
+	.uleb128 0x40	# (DW_AT_frame_base)
+	.uleb128 0xa	# (DW_FORM_block1)
+	.uleb128 0x2117	# (DW_AT_GNU_all_call_sites)
+	.uleb128 0xc	# (DW_FORM_flag)
+	.byte	0
+	.byte	0
+	.uleb128 0x3	# (abbrev code)
+	.uleb128 0x2e	# (TAG: DW_TAG_subprogram)
+	.byte	0x1	# DW_children_yes
+	.uleb128 0x3	# (DW_AT_name)
+	.uleb128 0x8	# (DW_FORM_string)
+	.uleb128 0x3a	# (DW_AT_decl_file)
+	.uleb128 0xb	# (DW_FORM_data1)
+	.uleb128 0x3b	# (DW_AT_decl_line)
+	.uleb128 0xb	# (DW_FORM_data1)
+	.uleb128 0x27	# (DW_AT_prototyped)
+	.uleb128 0xc	# (DW_FORM_flag)
+	.uleb128 0x11	# (DW_AT_low_pc)
+	.uleb128 0x1	# (DW_FORM_addr)
+	.uleb128 0x12	# (DW_AT_high_pc)
+	.uleb128 0x1	# (DW_FORM_addr)
+	.uleb128 0x40	# (DW_AT_frame_base)
+	.uleb128 0xa	# (DW_FORM_block1)
+	.uleb128 0x2117	# (DW_AT_GNU_all_call_sites)
+	.uleb128 0xc	# (DW_FORM_flag)
+	.uleb128 0x1	# (DW_AT_sibling)
+	.uleb128 0x13	# (DW_FORM_ref4)
+	.byte	0
+	.byte	0
+	.uleb128 0x4	# (abbrev code)
+	.uleb128 0x4109	# (TAG: DW_TAG_GNU_call_site)
+	.byte	0	# DW_children_no
+	.uleb128 0x11	# (DW_AT_low_pc)
+	.uleb128 0x1	# (DW_FORM_addr)
+	.uleb128 0x2115	# (DW_AT_GNU_tail_call)
+	.uleb128 0xc	# (DW_FORM_flag)
+	.uleb128 0x31	# (DW_AT_abstract_origin)
+	.uleb128 0x13	# (DW_FORM_ref4)
+	.byte	0
+	.byte	0
+	.uleb128 0x5	# (abbrev code)
+	.uleb128 0x2e	# (TAG: DW_TAG_subprogram)
+	.byte	0x1	# DW_children_yes
+	.uleb128 0x3f	# (DW_AT_external)
+	.uleb128 0xc	# (DW_FORM_flag)
+	.uleb128 0x3	# (DW_AT_name)
+	.uleb128 0xe	# (DW_FORM_strp)
+	.uleb128 0x3a	# (DW_AT_decl_file)
+	.uleb128 0xb	# (DW_FORM_data1)
+	.uleb128 0x3b	# (DW_AT_decl_line)
+	.uleb128 0xb	# (DW_FORM_data1)
+	.uleb128 0x27	# (DW_AT_prototyped)
+	.uleb128 0xc	# (DW_FORM_flag)
+	.uleb128 0x49	# (DW_AT_type)
+	.uleb128 0x13	# (DW_FORM_ref4)
+	.uleb128 0x11	# (DW_AT_low_pc)
+	.uleb128 0x1	# (DW_FORM_addr)
+	.uleb128 0x12	# (DW_AT_high_pc)
+	.uleb128 0x1	# (DW_FORM_addr)
+	.uleb128 0x40	# (DW_AT_frame_base)
+	.uleb128 0xa	# (DW_FORM_block1)
+	.uleb128 0x2117	# (DW_AT_GNU_all_call_sites)
+	.uleb128 0xc	# (DW_FORM_flag)
+	.uleb128 0x1	# (DW_AT_sibling)
+	.uleb128 0x13	# (DW_FORM_ref4)
+	.byte	0
+	.byte	0
+	.uleb128 0x6	# (abbrev code)
+	.uleb128 0x4109	# (TAG: DW_TAG_GNU_call_site)
+	.byte	0	# DW_children_no
+	.uleb128 0x11	# (DW_AT_low_pc)
+	.uleb128 0x1	# (DW_FORM_addr)
+	.uleb128 0x31	# (DW_AT_abstract_origin)
+	.uleb128 0x13	# (DW_FORM_ref4)
+	.byte	0
+	.byte	0
+	.uleb128 0x7	# (abbrev code)
+	.uleb128 0x24	# (TAG: DW_TAG_base_type)
+	.byte	0	# DW_children_no
+	.uleb128 0xb	# (DW_AT_byte_size)
+	.uleb128 0xb	# (DW_FORM_data1)
+	.uleb128 0x3e	# (DW_AT_encoding)
+	.uleb128 0xb	# (DW_FORM_data1)
+	.uleb128 0x3	# (DW_AT_name)
+	.uleb128 0x8	# (DW_FORM_string)
+	.byte	0
+	.byte	0
+	.uleb128 0x8	# (abbrev code)
+	.uleb128 0x34	# (TAG: DW_TAG_variable)
+	.byte	0	# DW_children_no
+	.uleb128 0x3	# (DW_AT_name)
+	.uleb128 0x8	# (DW_FORM_string)
+	.uleb128 0x3a	# (DW_AT_decl_file)
+	.uleb128 0xb	# (DW_FORM_data1)
+	.uleb128 0x3b	# (DW_AT_decl_line)
+	.uleb128 0xb	# (DW_FORM_data1)
+	.uleb128 0x49	# (DW_AT_type)
+	.uleb128 0x13	# (DW_FORM_ref4)
+	.uleb128 0x3f	# (DW_AT_external)
+	.uleb128 0xc	# (DW_FORM_flag)
+	.uleb128 0x2	# (DW_AT_location)
+	.uleb128 0xa	# (DW_FORM_block1)
+	.byte	0
+	.byte	0
+	.uleb128 0x9	# (abbrev code)
+	.uleb128 0x35	# (TAG: DW_TAG_volatile_type)
+	.byte	0	# DW_children_no
+	.uleb128 0x49	# (DW_AT_type)
+	.uleb128 0x13	# (DW_FORM_ref4)
+	.byte	0
+	.byte	0
+	.byte	0
+	.section	.debug_aranges,"",@progbits
+	.long	0x3c	# Length of Address Ranges Info
+	.value	0x2	# DWARF Version
+	.long	.Ldebug_info0	# Offset of Compilation Unit Info
+	.byte	0x8	# Size of Address
+	.byte	0	# Size of Segment Descriptor
+	.value	0	# Pad to 16 byte boundary
+	.value	0
+	.quad	.Ltext0	# Address
+	.quad	.Letext0-.Ltext0	# Length
+	.quad	.LFB2	# Address
+	.quad	.LFE2-.LFB2	# Length
+	.quad	0
+	.quad	0
+	.section	.debug_ranges,"",@progbits
+.Ldebug_ranges0:
+	.quad	.Ltext0	# Offset 0
+	.quad	.Letext0
+	.quad	.LFB2	# Offset 0x10
+	.quad	.LFE2
+	.quad	0
+	.quad	0
+	.section	.debug_line,"",@progbits
+.Ldebug_line0:
+	.section	.debug_str,"MS",@progbits,1
+.LASF0:
+	.string	"GNU C 4.7.2 20120911 (prerelease)"
+.LASF1:
+	.string	"gdb.arch/amd64-tailcall-ret.c"
+.LASF2:
+	.string	""
+.LASF3:
+	.string	"main"
+	.ident	"GCC: (GNU) 4.7.2 20120911 (prerelease)"
+	.section	.note.GNU-stack,"",@progbits
--- src/gdb/testsuite/gdb.arch/amd64-tailcall-ret.c
+++ src/gdb/testsuite/gdb.arch/amd64-tailcall-ret.c	2013-01-13 07:24:24.648595000 +0000
@@ -0,0 +1,39 @@
+/* This testcase is part of GDB, the GNU debugger.
+
+   Copyright 2012 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+volatile int v;
+
+static __attribute__ ((noinline, noclone)) void
+g (void)
+{
+  v = 2;
+}
+
+static __attribute__ ((noinline, noclone)) void
+f (void)
+{
+  g ();
+}
+
+int
+main (void)
+{
+  f (); /* first */
+  f (); /* second */
+  v = 3;
+  return 0;
+}
--- src/gdb/testsuite/gdb.arch/amd64-tailcall-ret.exp
+++ src/gdb/testsuite/gdb.arch/amd64-tailcall-ret.exp	2013-01-13 07:24:25.267748000 +0000
@@ -0,0 +1,44 @@
+# Copyright (C) 2012 Free Software Foundation, Inc.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+set testfile "amd64-tailcall-ret"
+set opts {}
+set srcfile "amd64-tailcall-ret.S"
+
+if [info exists COMPILE] {
+    # make check RUNTESTFLAGS="gdb.arch/amd64-tailcall-ret.exp COMPILE=1"
+    #standard_testfile
+    lappend opts debug optimize=-O2
+} elseif { ![istarget x86_64-*-* ] || ![is_lp64_target] } {
+    verbose "Skipping ${testfile}."
+    return
+}
+
+if { [prepare_for_testing ${testfile}.exp ${testfile} ${srcfile} $opts] } {
+    return -1
+}
+
+if ![runto_main] {
+    return -1
+}
+
+gdb_breakpoint "g"
+gdb_continue_to_breakpoint "g" ".* v = 2;"
+
+gdb_test "return" { f \(\); /\* second \*/} "return" \
+         {Make g return now\? \(y or n\) } "y"
+
+gdb_continue_to_breakpoint "g" ".* v = 2;"
+
+gdb_test "finish" " v = 3;"
