commit 2c29df25b7c2ff006b45afd80ee6dd734ebbd47c
Author: Sergio Durigan Junior <sergiodj@redhat.com>
Date:   Sun Sep 11 16:53:09 2016 -0400

    Fix false FAIL on gdb.base/stap-probe.exp, due to ICF optimization
    
    GCC 6's ICF optimization pass is making the declaration of 'm1' and
    'm2', on gdb.base/stap-probe.c, to be unified.  However, this leads to
    only one instance of the probe 'two' being created, which causes a
    failure on the testsuite (which expects a multi-location breakpoint to
    be inserted on the probe).
    
    This patch fixes this failure by declaring a dummy variable on 'm1',
    and using it as an argument to m1's version of probe 'two'.  Since we
    do not care about the contents of the functions nor about the
    arguments of each probe 'two', this is OK.
    
    gdb/testsuite/ChangeLog:
    2016-09-11  Sergio Durigan Junior  <sergiodj@redhat.com>
    	    Jan Kratochvil  <jan.kratochvil@redhat.com>
    
    	* gdb.base/stap-probe.c (m1): New variable 'dummy', necessary to
    	make m1's definition to be different from m2's.  Use 'dummy' as an
    	argument for probe 'two'.

### a/gdb/testsuite/ChangeLog
### b/gdb/testsuite/ChangeLog
## -1,3 +1,10 @@
+2016-09-11  Sergio Durigan Junior  <sergiodj@redhat.com>
+	    Jan Kratochvil  <jan.kratochvil@redhat.com>
+
+	* gdb.base/stap-probe.c (m1): New variable 'dummy', necessary to
+	make m1's definition to be different from m2's.  Use 'dummy' as an
+	argument for probe 'two'.
+
 2016-09-10  Jon Beniston  <jon@beniston.com>
 
 	* lib/mi-support.exp (mi_gdb_target_load): Use target_sim_options
--- a/gdb/testsuite/gdb.base/stap-probe.c
+++ b/gdb/testsuite/gdb.base/stap-probe.c
@@ -53,8 +53,13 @@ struct funcs
 static void
 m1 (void)
 {
+  /* m1 and m2 are equivalent, but because of some compiler
+     optimizations we have to make each of them unique.  This is why
+     we have this dummy variable here.  */
+  volatile int dummy = 0;
+
   if (TEST2)
-    STAP_PROBE (test, two);
+    STAP_PROBE1 (test, two, dummy);
 }
 
 static void


commit f389f6fef76d7cf8e8beb7061edff2155c284898
Author: Jan Kratochvil <jan.kratochvil@redhat.com>
Date:   Wed Oct 5 21:56:46 2016 +0200

    testsuite: Fix recent GCC FAIL: gdb.arch/i386-signal.exp
    
    gcc-6.2.1-2.fc24.x86_64
    
    (gdb) backtrace 10^M
    (gdb) FAIL: gdb.arch/i386-signal.exp: backtrace 10
    
    (gdb) disas/s
    Dump of assembler code for function main:
    .../gdb/testsuite/gdb.arch/i386-signal.c:
    30      {
       0x000000000040057f <+0>:     push   %rbp
       0x0000000000400580 <+1>:     mov    %rsp,%rbp
    31        setup ();
       0x0000000000400583 <+4>:     callq  0x400590 <setup>
    => 0x0000000000400588 <+9>:     mov    $0x0,%eax
    32      }
       0x000000000040058d <+14>:    pop    %rbp
       0x000000000040058e <+15>:    retq
    End of assembler dump.
    
    The .exp patch is an obvious typo fix I think.  The regex was written to
    accept "ADDR in main" and I find it OK as checking .debug_line validity is not
    the purpose of this testfile.
    
    gcc-4.8.5-11.el7.x86_64 did not put the 'mov $0x0,%eax' instruction there at
    all so there was no problem with .debug_line.
    
    gdb/testsuite/ChangeLog
    2016-10-05  Jan Kratochvil  <jan.kratochvil@redhat.com>
    
    	* gdb.arch/i386-signal.exp (backtrace 10): Fix #2 typo.

### a/gdb/testsuite/ChangeLog
### b/gdb/testsuite/ChangeLog
## -1,3 +1,7 @@
+2016-10-05  Jan Kratochvil  <jan.kratochvil@redhat.com>
+
+	* gdb.arch/i386-signal.exp (backtrace 10): Fix #2 typo.
+
 2016-10-05  Yao Qi  <yao.qi@linaro.org>
 
 	* lib/gdb.exp (support_complex_tests): Return zero if
--- a/gdb/testsuite/gdb.arch/i386-signal.exp
+++ b/gdb/testsuite/gdb.arch/i386-signal.exp
@@ -35,6 +35,6 @@ gdb_load ${binfile}
 
 runto func
 gdb_test "backtrace 10" \
-    "#0  ($hex in )?func.*\r\n#1  <signal handler called>\r\n#2  ($hex in)?main.*"
+    "#0  ($hex in )?func.*\r\n#1  <signal handler called>\r\n#2  ($hex in )?main.*"
 
 gdb_test "finish" "Run till exit from \#0  func.*<signal handler called>"


commit e027976f02ce8ed4cf0da79238226c03a640f2b3
Author: Pedro Alves <palves@redhat.com>
Date:   Thu Oct 6 12:57:39 2016 +0100

    Fix a few gdb.base/jit-simple.exp problems
    
    I noticed that we sometimes get this:
    
      (gdb) print &__jit_debug_descriptor
      $1 = (struct jit_descriptor *) 0x601040 <__jit_debug_descriptor>
      (gdb) PASS: gdb.base/jit-simple.exp: blah 1
      [...]
      (gdb) run
      [...]
      Starting program: build/gdb/testsuite/outputs/gdb.base/jit-simple/jit-simple
      Unsupported JIT protocol version 4 in descriptor (expected 1)
    
      Breakpoint 2, main () at src/gdb/testsuite/gdb.base/jit-simple.c:36
      36        return 0;
      (gdb) print &__jit_debug_descriptor
      $2 = (struct jit_descriptor *) 0x601040 <__jit_debug_descriptor>
      (gdb) PASS: gdb.base/jit-simple.exp: blah 1
    
    All tests PASSed, but note the "Unsupported JIT protocol version 4"
    message.
    
    Also notice that "__jit_debug_descriptor" has the same address before
    and after the rerun, while the test is built in a way that should make
    that address change between runs.
    
    The test doesn't catch any of this because it doesn't compare
    before/after addresses.
    
    And then notice the "blah 1" test messages.  "blah" is clearly a WIP
    message, but it should be at least "blah 2" the second time.  :-)
    
    The reason this sometimes happens is that the test recompiles the
    program and expects gdb to reload it automaticallyt on "run".  However,
    if the original program and the new recompilation happen to be in the
    same second, then gdb does not realize that the binary needs to be
    reloaded.  (This is an old problem out of scope of this series.)  If
    that happens, then GDB ends up using the wrong symbols for the program
    that it spawns, reads the JIT descriptor out of the wrong address,
    finds garbage, and prints that "unsupported version" notice.
    
    Fix that in the same way gdb.base/reread.exp handles it -- by sleeping
    one second before recompiling.
    
    gdb/testsuite/ChangeLog:
    2016-10-06  Pedro Alves  <palves@redhat.com>
    
    	* gdb.base/jit-simple.exp (top level) Delete get_compiler_info
    	call.
    	(jit_run): Delete.
    	(jit_test_reread): Use with_test_prefix.  Reload the main binary
    	explicitly.  Compare the before/after addresses of the JIT
    	descriptor.

### a/gdb/testsuite/ChangeLog
### b/gdb/testsuite/ChangeLog
## -1,3 +1,12 @@
+2016-10-06  Pedro Alves  <palves@redhat.com>
+
+	* gdb.base/jit-simple.exp (top level) Delete get_compiler_info
+	call.
+	(jit_run): Delete.
+	(jit_test_reread): Use with_test_prefix.  Reload the main binary
+	explicitly.  Compare the before/after addresses of the JIT
+	descriptor.
+
 2016-10-03  Antoine Tremblay  <antoine.tremblay@ericsson.com>
 2016-10-03  Simon Marchi  <simon.marchi@ericsson.com>
 
--- a/gdb/testsuite/gdb.base/jit-simple.exp
+++ b/gdb/testsuite/gdb.base/jit-simple.exp
@@ -18,16 +18,6 @@ if {[skip_shlib_tests]} {
     return -1
 }
 
-if {[get_compiler_info]} {
-    warning "Could not get compiler info"
-    untested jit-simple.exp
-    return 1
-}
-
-#
-# test running programs
-#
-
 standard_testfile
 
 if {[build_executable $testfile.exp $testfile $srcfile debug] == -1} {
@@ -35,39 +25,43 @@ if {[build_executable $testfile.exp $testfile $srcfile debug] == -1} {
     return -1
 }
 
-# A helper for jit_test_reread that invokes gdb_run_cmd.
-proc jit_run {msg} {
-    global decimal gdb_prompt
-
-    gdb_run_cmd
-    gdb_test "" "Inferior .* exited.*" $msg
-}
-
 # Test re-running an inferior with a JIT descriptor, where the JIT
 # descriptor changes address between runs.
 # http://sourceware.org/bugzilla/show_bug.cgi?id=13431
 proc jit_test_reread {} {
     global testfile binfile subdir srcfile srcdir
+    global hex
 
-    clean_restart $testfile
+    with_test_prefix "initial run" {
+	clean_restart $testfile
 
-    # jit_run "initial run"
-    runto_main
-
-    gdb_test "print &__jit_debug_descriptor" "= .*" "blah 1"
+	runto_main
 
-    gdb_rename_execfile $binfile ${binfile}x
+	set addr_before [get_hexadecimal_valueof "&__jit_debug_descriptor" 0 \
+			     "get address of __jit_debug_descriptor"]
+    }
 
-    if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug additional_flags=-DSPACER}] != "" } {
-	fail "recompile $srcfile"
-    } else {
-	pass "recompile $srcfile"
+    with_test_prefix "second run" {
+	# Ensure that the new executable is at least one second newer
+	# than the old.  If the recompilation happens in the same
+	# second, gdb might not reload the executable automatically.
+	sleep 1
 
-	# jit_run "second run"
+	gdb_rename_execfile $binfile ${binfile}x
+	if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug additional_flags=-DSPACER}] != "" } {
+	    fail "recompile"
+	    return
+	} else {
+	    pass "recompile"
+	}
 
 	runto_main
-	gdb_test "print &__jit_debug_descriptor" "= .*" "blah 1"
+
+	set addr_after [get_hexadecimal_valueof "&__jit_debug_descriptor" 0 \
+			    "get address of __jit_debug_descriptor"]
     }
+
+    gdb_assert {$addr_before != $addr_after} "address changed"
 }
 
 jit_test_reread


commit f8da6fe399c8dafa98e7dbed36d3562a919768f5
Author: Pedro Alves <palves@redhat.com>
Date:   Thu Oct 6 12:57:40 2016 +0100

    Fix PR11094: JIT breakpoint is not properly recreated on reruns
    
    Even though this was supposedly in the gdb 7.2 timeframe, the testcase
    in PR11094 crashes current GDB with a segfault:
    
      Program received signal SIGSEGV, Segmentation fault.
      0x00000000005ee894 in event_location_to_string (location=0x0) at
      src/gdb/location.c:412
      412       if (EL_STRING (location) == NULL)
      (top-gdb) bt
      #0  0x00000000005ee894 in event_location_to_string (location=0x0) at
      src/gdb/location.c:412
      #1  0x000000000057411a in print_breakpoint_location (b=0x18288e0, loc=0x0) at
      src/gdb/breakpoint.c:6201
      #2  0x000000000057483f in print_one_breakpoint_location (b=0x18288e0,
      loc=0x182cf10, loc_number=0, last_loc=0x7fffffffd258, allflag=1)
          at src/gdb/breakpoint.c:6473
      #3  0x00000000005751e1 in print_one_breakpoint (b=0x18288e0,
      last_loc=0x7fffffffd258, allflag=1) at
      src/gdb/breakpoint.c:6707
      #4  0x000000000057589c in breakpoint_1 (args=0x0, allflag=1, filter=0x0) at
      src/gdb/breakpoint.c:6947
      #5  0x0000000000575aa8 in maintenance_info_breakpoints (args=0x0, from_tty=0)
      at src/gdb/breakpoint.c:7026
      [...]
    
    This is GDB trying to print the location spec of the JIT event
    breakpoint, but that's an internal breakpoint without one.
    
    If I add a NULL check, then we see that the JIT breakpoint is now
    pending (because its location has shlib_disabled set):
    
      (gdb) maint info breakpoints
      Num     Type           Disp Enb Address            What
      [...]
      -8      jit events     keep y   <PENDING>           inf 1
      [...]
    
    But that's incorrect.  GDB should have managed to recreate the JIT
    breakpoint's location for the second run.  So the problem is
    elsewhere.
    
    The problem is that if the JIT loads at the same address on the second
    run, we never recreate the JIT breakpoint, because we hit this early
    return:
    
      static int
      jit_breakpoint_re_set_internal (struct gdbarch *gdbarch,
    				  struct jit_program_space_data *ps_data)
      {
        [...]
        if (ps_data->cached_code_address == addr)
          return 0;
    
        [...]
          delete_breakpoint (ps_data->jit_breakpoint);
        [...]
        ps_data->jit_breakpoint = create_jit_event_breakpoint (gdbarch, addr);
    
    Fix this by deleting the breakpoint and discarding the cached code
    address when the objfile where the previous JIT breakpoint was found
    is deleted/unloaded in the first place.
    
    The test that was originally added for PR11094 doesn't trip on this
    because:
    
      #1 - It doesn't test the case of the JIT descriptor's address _not_
           changing between reruns.
    
      #2 - And then it doesn't do "maint info breakpoints", or really
           anything with the JIT at all.
    
      #3 - and even then, to trigger the problem the JIT descriptor needs
           to be in a separate library, while the current test puts it in
           the main program.
    
    The patch extends the test to cover all combinations of these
    scenarios.
    
    gdb/ChangeLog:
    2016-10-06  Pedro Alves  <palves@redhat.com>
    
    	* jit.c (free_objfile_data): Delete the JIT breakpoint and clear
    	the cached code address.
    
    gdb/testsuite/ChangeLog:
    2016-10-06  Pedro Alves  <palves@redhat.com>
    
    	* gdb.base/jit-simple-dl.c: New file.
    	* gdb.base/jit-simple-jit.c: New file, factored out from ...
    	* gdb.base/jit-simple.c: ... this.
    	* gdb.base/jit-simple.exp (jit_run): Delete.
    	(build_jit): New proc.
    	(jit_test_reread): Recompile either the main program or the shared
    	library, depending on what is being tested.  Skip changing address
    	if caller wants to.  Compare before/after addresses.  If testing
    	standalone, explicitly load the binary.  Test "maint info
    	breakpoints".
    	(top level): Add "standalone vs shared lib" and "change address"
    	vs "same address" axes.

### a/gdb/ChangeLog
### b/gdb/ChangeLog
## -1,3 +1,8 @@
+2016-10-06  Pedro Alves  <palves@redhat.com>
+
+	* jit.c (free_objfile_data): Delete the JIT breakpoint and clear
+	the cached code address.
+
 2016-10-03  Simon Marchi  <simark@simark.ca>
 
 	* infrun.c (restore_current_uiout_cleanup): Move to ui-out.c.
--- a/gdb/jit.c
+++ b/gdb/jit.c
@@ -1482,7 +1482,11 @@ free_objfile_data (struct objfile *objfile, void *data)
 	= ((struct jit_program_space_data *)
 	   program_space_data (objfile->pspace, jit_program_space_data));
       if (ps_data != NULL && ps_data->objfile == objfile)
-	ps_data->objfile = NULL;
+	{
+	  ps_data->objfile = NULL;
+	  delete_breakpoint (ps_data->jit_breakpoint);
+	  ps_data->cached_code_address = 0;
+	}
     }
 
   xfree (data);
### a/gdb/testsuite/ChangeLog
### b/gdb/testsuite/ChangeLog
## -1,5 +1,20 @@
 2016-10-06  Pedro Alves  <palves@redhat.com>
 
+	* gdb.base/jit-simple-dl.c: New file.
+	* gdb.base/jit-simple-jit.c: New file, factored out from ...
+	* gdb.base/jit-simple.c: ... this.
+	* gdb.base/jit-simple.exp (jit_run): Delete.
+	(build_jit): New proc.
+	(jit_test_reread): Recompile either the main program or the shared
+	library, depending on what is being tested.  Skip changing address
+	if caller wants to.  Compare before/after addresses.  If testing
+	standalone, explicitly load the binary.  Test "maint info
+	breakpoints".
+	(top level): Add "standalone vs shared lib" and "change address"
+	vs "same address" axes.
+
+2016-10-06  Pedro Alves  <palves@redhat.com>
+
 	* gdb.base/jit-simple.exp (top level) Delete get_compiler_info
 	call.
 	(jit_run): Delete.
--- /dev/null
+++ b/gdb/testsuite/gdb.base/jit-simple-dl.c
@@ -0,0 +1,25 @@
+/* This testcase is part of GDB, the GNU debugger.
+
+   Copyright 2016 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* A stub program that links with a simple library that uses the JIT
+   API.  */
+
+int
+main (void)
+{
+  return 0;
+}
--- /dev/null
+++ b/gdb/testsuite/gdb.base/jit-simple-jit.c
@@ -0,0 +1,50 @@
+/* This testcase is part of GDB, the GNU debugger.
+
+   Copyright 2012-2016 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Simple library using the JIT API.  */
+
+#include <stdint.h>
+
+struct jit_code_entry
+{
+  struct jit_code_entry *next_entry;
+  struct jit_code_entry *prev_entry;
+  const char *symfile_addr;
+  uint64_t symfile_size;
+};
+
+struct jit_descriptor
+{
+  uint32_t version;
+  /* This type should be jit_actions_t, but we use uint32_t
+     to be explicit about the bitwidth.  */
+  uint32_t action_flag;
+  struct jit_code_entry *relevant_entry;
+  struct jit_code_entry *first_entry;
+};
+
+#ifdef SPACER
+/* This exists to change the address of __jit_debug_descriptor.  */
+int spacer = 4;
+#endif
+
+struct jit_descriptor __jit_debug_descriptor = { 1, 0, 0, 0 };
+
+void
+__jit_debug_register_code (void)
+{
+}
--- a/gdb/testsuite/gdb.base/jit-simple.c
+++ b/gdb/testsuite/gdb.base/jit-simple.c
@@ -1,37 +1,26 @@
-/* Simple program using the JIT API.  */
+/* This testcase is part of GDB, the GNU debugger.
 
-#include <stdint.h>
+   Copyright 2016 Free Software Foundation, Inc.
 
-struct jit_code_entry
-{
-  struct jit_code_entry *next_entry;
-  struct jit_code_entry *prev_entry;
-  const char *symfile_addr;
-  uint64_t symfile_size;
-};
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
 
-struct jit_descriptor
-{
-  uint32_t version;
-  /* This type should be jit_actions_t, but we use uint32_t
-     to be explicit about the bitwidth.  */
-  uint32_t action_flag;
-  struct jit_code_entry *relevant_entry;
-  struct jit_code_entry *first_entry;
-};
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
 
-#ifdef SPACER
-/* This exists to change the address of __jit_debug_descriptor.  */
-int spacer = 4;
-#endif
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
-struct jit_descriptor __jit_debug_descriptor = { 1, 0, 0, 0 };
+/* Simple standalone program using the JIT API.  */
 
-void __jit_debug_register_code()
-{
-}
+#include "jit-simple-jit.c"
 
-int main()
+int
+main (void)
 {
   return 0;
 }
--- a/gdb/testsuite/gdb.base/jit-simple.exp
+++ b/gdb/testsuite/gdb.base/jit-simple.exp
@@ -13,6 +13,17 @@
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
+# Test re-running an inferior with a JIT descriptor, where the JIT
+# descriptor changes address between runs.
+# http://sourceware.org/bugzilla/show_bug.cgi?id=13431
+
+# Test both the case of the JIT reader being included in the main
+# program directly, and the case of the JIT reader being split out to
+# a shared library.
+
+# For completeness, also test when the JIT descriptor does not change
+# address between runs.
+
 if {[skip_shlib_tests]} {
     untested jit-simple.exp
     return -1
@@ -20,25 +31,81 @@ if {[skip_shlib_tests]} {
 
 standard_testfile
 
-if {[build_executable $testfile.exp $testfile $srcfile debug] == -1} {
+set libname $testfile-jit
+set srcfile_lib $srcdir/$subdir/$libname.c
+set binfile_lib [standard_output_file $libname.so]
+
+# Build a standalone JIT binary.
+
+proc build_standalone_jit {{options ""}} {
+    global testfile srcfile binfile
+
+    lappend options "debug"
+
+    if {[build_executable $testfile.exp $testfile $srcfile $options] == -1} {
+	return -1
+    }
+
+    return 0
+}
+
+# Build the shared library JIT.
+
+proc build_shared_jit {{options ""}} {
+    global testfile
+    global srcfile_lib binfile_lib
+
+    lappend options "debug additional_flags=-fPIC"
+    if { [gdb_compile_shlib $srcfile_lib $binfile_lib $options] != "" } {
+	return -1
+    }
+
+    return 0
+}
+
+if {[build_standalone_jit] == -1} {
+    untested "could not compile $binfile"
+    return
+}
+
+if {[build_shared_jit] == -1} {
+    untested "could not compile $binfile_lib"
+    return
+}
+
+# Built the program that loads the JIT library.
+set srcfile_dl $testfile-dl.c
+set binfile_dl $binfile-dl
+set options [list debug shlib=${binfile_lib}]
+if {[gdb_compile ${srcdir}/${subdir}/${srcfile_dl} $binfile_dl executable \
+	 [list debug shlib=$binfile_lib]] == -1 } {
     untested jit-simple.exp
     return -1
 }
 
-# Test re-running an inferior with a JIT descriptor, where the JIT
-# descriptor changes address between runs.
-# http://sourceware.org/bugzilla/show_bug.cgi?id=13431
-proc jit_test_reread {} {
-    global testfile binfile subdir srcfile srcdir
+# STANDALONE is true when the JIT reader is included directly in the
+# main program.  False when the JIT reader is in a separate shared
+# library.  If CHANGE_ADDR is true, force changing the JIT descriptor
+# changes address between runs.
+proc jit_test_reread {standalone change_addr} {
+    global testfile binfile subdir srcfile srcdir binfile_lib binfile_dl
     global hex
 
     with_test_prefix "initial run" {
-	clean_restart $testfile
+	if {$standalone} {
+	    clean_restart $binfile
+	} else {
+	    clean_restart $binfile_dl
+	}
 
 	runto_main
 
 	set addr_before [get_hexadecimal_valueof "&__jit_debug_descriptor" 0 \
 			     "get address of __jit_debug_descriptor"]
+
+	gdb_test "maint info breakpoints" \
+	    "jit events     keep y   $hex <__jit_debug_register_code>.*" \
+	    "maint info breakpoints shows jit breakpoint"
     }
 
     with_test_prefix "second run" {
@@ -47,21 +114,49 @@ proc jit_test_reread {} {
 	# second, gdb might not reload the executable automatically.
 	sleep 1
 
-	gdb_rename_execfile $binfile ${binfile}x
-	if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug additional_flags=-DSPACER}] != "" } {
-	    fail "recompile"
-	    return
-	} else {
-	    pass "recompile"
+	if ${change_addr} {
+	    set options "additional_flags=-DSPACER"
+	    if {$standalone} {
+		gdb_rename_execfile $binfile ${binfile}x
+		set res [build_standalone_jit $options]
+	    } else {
+		gdb_rename_execfile $binfile_lib ${binfile_lib}x
+		set res [build_shared_jit $options]
+	    }
+	    if  { $res == -1 } {
+		fail "recompile"
+		return
+	    } else {
+		pass "recompile"
+	    }
 	}
 
 	runto_main
 
 	set addr_after [get_hexadecimal_valueof "&__jit_debug_descriptor" 0 \
 			    "get address of __jit_debug_descriptor"]
+
+	# This used to crash in the JIT-in-shared-library case:
+	# https://sourceware.org/bugzilla/show_bug.cgi?id=11094
+	gdb_test "maint info breakpoints" \
+	    "jit events     keep y   $hex <__jit_debug_register_code>.*" \
+	    "maint info breakpoints shows jit breakpoint"
     }
 
-    gdb_assert {$addr_before != $addr_after} "address changed"
+    if ${change_addr} {
+	gdb_assert {$addr_before != $addr_after} "address changed"
+    } else {
+	gdb_assert {$addr_before == $addr_after} "address didn't change"
+    }
 }
 
-jit_test_reread
+foreach standalone {1 0} {
+    with_test_prefix [expr ($standalone)?"standalone":"shared"] {
+	with_test_prefix "change addr" {
+	    jit_test_reread $standalone 1
+	}
+	with_test_prefix "same addr" {
+	    jit_test_reread $standalone 0
+	}
+    }
+}
