commit 50e64da58e648ff8708935add5b2a87b4e590edf
Author: Yao Qi <yao.qi@linaro.org>
Date:   Tue Jul 25 10:15:25 2017 +0100

    [ARM] Access FPSCR on vfpv2
    
    GDB can fetch or store FPSCR on vfpv3, which has 32 VFP registers, but
    fail to do so on vfpv2, which has 16 VFP registers.  GDB code is incorrect
    for vfpv2,
    
           else if (tdep->vfp_register_count > 0
                   && regno >= ARM_D0_REGNUM
                   && regno <= ARM_D0_REGNUM + tdep->vfp_register_count)
    
    while FPSCR register number is defined as ARM_D0_REGNUM + 32.
    
      ARM_D0_REGNUM,                /* VFP double-precision registers.  */
      ARM_D31_REGNUM = ARM_D0_REGNUM + 31,
      ARM_FPSCR_REGNUM,
    
    The code above uses "<=" rather than "<", in order to put FPSCR in the
    range, but it is only correct when tdep->vfp_register_count is 32.  On
    vpfv2, it is 16, and FPSCR is out of the range, so fetch_vfp_regs or
    store_vfp_regs are not called.
    
    gdb:
    
    2017-07-25  Yao Qi  <yao.qi@linaro.org>
    
            PR tdep/21717
            * arm-linux-nat.c (arm_linux_fetch_inferior_registers): Update
            condition for FPSCR.
            (arm_linux_store_inferior_registers): Likewise.

### a/gdb/ChangeLog
### b/gdb/ChangeLog
## -1,3 +1,10 @@
+2017-07-25  Yao Qi  <yao.qi@linaro.org>
+
+	PR tdep/21717
+	* arm-linux-nat.c (arm_linux_fetch_inferior_registers): Update
+	condition for FPSCR.
+	(arm_linux_store_inferior_registers): Likewise.
+
 2017-06-04  Joel Brobecker  <brobecker@adacore.com>
 
 	* version.in: Set GDB version number to 8.0.0.DATE-git.
--- a/gdb/arm-linux-nat.c
+++ b/gdb/arm-linux-nat.c
@@ -402,7 +402,8 @@ arm_linux_fetch_inferior_registers (struct target_ops *ops,
 	fetch_wmmx_regs (regcache);
       else if (tdep->vfp_register_count > 0
 	       && regno >= ARM_D0_REGNUM
-	       && regno <= ARM_D0_REGNUM + tdep->vfp_register_count)
+	       && (regno < ARM_D0_REGNUM + tdep->vfp_register_count
+		   || regno == ARM_FPSCR_REGNUM))
 	fetch_vfp_regs (regcache);
     }
 }
@@ -439,7 +440,8 @@ arm_linux_store_inferior_registers (struct target_ops *ops,
 	store_wmmx_regs (regcache);
       else if (tdep->vfp_register_count > 0
 	       && regno >= ARM_D0_REGNUM
-	       && regno <= ARM_D0_REGNUM + tdep->vfp_register_count)
+	       && (regno < ARM_D0_REGNUM + tdep->vfp_register_count
+		   || regno == ARM_FPSCR_REGNUM))
 	store_vfp_regs (regcache);
     }
 }



commit cd33a03d183a268b83ccbcae07f3788308e8d9f4
Author: Yao Qi <yao.qi@linaro.org>
Date:   Tue Jul 25 11:38:50 2017 +0100

    Catch exceptions thrown from gdbarch_skip_prologue
    
    PR 21555 is caused by the exception during the prologue analysis when re-set
    a breakpoint.
    
    (gdb) bt
     #0  memory_error_message (err=TARGET_XFER_E_IO, gdbarch=0x153db50, memaddr=93824992233232) at ../../binutils-gdb/gdb/corefile.c:192
     #1  0x00000000005718ed in memory_error (err=TARGET_XFER_E_IO, memaddr=memaddr@entry=93824992233232) at ../../binutils-gdb/gdb/corefile.c:220
     #2  0x00000000005719d6 in read_memory_object (object=object@entry=TARGET_OBJECT_CODE_MEMORY, memaddr=93824992233232, memaddr@entry=1, myaddr=myaddr@entry=0x7fffffffd0a0 "P\333S\001", len=len@entry=1) at ../../binutils-gdb/gdb/corefile.c:259
     #3  0x0000000000571c6e in read_code (len=1, myaddr=0x7fffffffd0a0 "P\333S\001", memaddr=<optimized out>) at ../../binutils-gdb/gdb/corefile.c:287
     #4  read_code_unsigned_integer (memaddr=memaddr@entry=93824992233232, len=len@entry=1, byte_order=byte_order@entry=BFD_ENDIAN_LITTLE)                          at ../../binutils-gdb/gdb/corefile.c:362
     #5  0x000000000041d4a0 in amd64_analyze_prologue (gdbarch=gdbarch@entry=0x153db50, pc=pc@entry=93824992233232, current_pc=current_pc@entry=18446744073709551615, cache=cache@entry=0x7fffffffd1e0) at ../../binutils-gdb/gdb/amd64-tdep.c:2310
     #6  0x000000000041e404 in amd64_skip_prologue (gdbarch=0x153db50, start_pc=93824992233232) at ../../binutils-gdb/gdb/amd64-tdep.c:2459
     #7  0x000000000067bfb0 in skip_prologue_sal (sal=sal@entry=0x7fffffffd4e0) at ../../binutils-gdb/gdb/symtab.c:3628
     #8  0x000000000067c4d8 in find_function_start_sal (sym=sym@entry=0x1549960, funfirstline=1) at ../../binutils-gdb/gdb/symtab.c:3501
     #9  0x000000000060999d in symbol_to_sal (result=result@entry=0x7fffffffd5f0, funfirstline=<optimized out>, sym=sym@entry=0x1549960) at ../../binutils-gdb/gdb/linespec.c:3860
    ....
     #16 0x000000000054b733 in location_to_sals (b=b@entry=0x15792d0, location=0x157c230, search_pspace=search_pspace@entry=0x1148120, found=found@entry=0x7fffffffdc64) at ../../binutils-gdb/gdb/breakpoint.c:14211
     #17 0x000000000054c1f5 in breakpoint_re_set_default (b=0x15792d0) at ../../binutils-gdb/gdb/breakpoint.c:14301
     #18 0x00000000005412a9 in breakpoint_re_set_one (bint=bint@entry=0x15792d0) at ../../binutils-gdb/gdb/breakpoint.c:14412
    
    This problem can be fixed by
    
     - either each prologue analyzer doesn't throw exception,
     - or catch the exception thrown from gdbarch_skip_prologue,
    
    I choose the latter because the former needs to fix *every* prologue
    analyzer to not throw exception.
    
    This error can be reproduced by changing reread.exp.  The test reread.exp
    has already test that breakpoint can be reset correctly after the
    executable is re-read.  This patch extends this test by compiling test c
    file with and without -fPIE.
    
    (gdb) run ^M
    The program being debugged has been started already.^M
    Start it from the beginning? (y or n) y^M
    x86_64/gdb/testsuite/outputs/gdb.base/reread/reread' has changed; re-reading symbols.
    Error in re-setting breakpoint 1: Cannot access memory at address 0x555555554790^M
    Error in re-setting breakpoint 2: Cannot access memory at address 0x555555554790^M
    Starting program: /scratch/yao/gdb/build-git/x86_64/gdb/testsuite/outputs/gdb.base/reread/reread ^M
    This is foo^M
    [Inferior 1 (process 27720) exited normally]^M
    (gdb) FAIL: gdb.base/reread.exp: opts= "-fPIE" "ldflags=-pie" : run to foo() second time (the program exited)
    
    This patch doesn't re-indent the code, to keep the patch simple.
    
    gdb:
    
    2017-07-25  Yao Qi  <yao.qi@linaro.org>
    
            PR gdb/21555
            * arch-utils.c (gdbarch_skip_prologue_noexcept): New function.
            * arch-utils.h (gdbarch_skip_prologue_noexcept): Declare.
            * infrun.c: Include arch-utils.h
            (handle_step_into_function): Call gdbarch_skip_prologue_noexcept.
            (handle_step_into_function_backward): Likewise.
            * symtab.c (skip_prologue_sal): Likewise.
    
    gdb/testsuite:
    
    2017-07-25  Yao Qi  <yao.qi@linaro.org>
    
            PR gdb/21555
            * gdb.base/reread.exp: Wrap the whole test with two kinds of
            compilation flags, with -fPIE and without -fPIE.

--- a/gdb/arch-utils.c
+++ b/gdb/arch-utils.c
@@ -964,6 +964,24 @@ default_guess_tracepoint_registers (struct gdbarch *gdbarch,
   regcache_raw_supply (regcache, pc_regno, regs);
 }
 
+/* See arch-utils.h.  */
+
+CORE_ADDR
+gdbarch_skip_prologue_noexcept (gdbarch *gdbarch, CORE_ADDR pc) noexcept
+{
+  CORE_ADDR new_pc = pc;
+
+  TRY
+    {
+      new_pc = gdbarch_skip_prologue (gdbarch, pc);
+    }
+  CATCH (ex, RETURN_MASK_ALL)
+    {}
+  END_CATCH
+
+  return new_pc;
+}
+
 /* -Wmissing-prototypes */
 extern initialize_file_ftype _initialize_gdbarch_utils;
 
--- a/gdb/arch-utils.h
+++ b/gdb/arch-utils.h
@@ -267,4 +267,10 @@ extern void default_guess_tracepoint_registers (struct gdbarch *gdbarch,
 						struct regcache *regcache,
 						CORE_ADDR addr);
 
+/* Wrapper to gdbarch_skip_prologue, but doesn't throw exception.  Catch
+   exception thrown from gdbarch_skip_prologue, and return PC.  */
+
+extern CORE_ADDR gdbarch_skip_prologue_noexcept (gdbarch *gdbarch,
+						 CORE_ADDR pc) noexcept;
+
 #endif
--- a/gdb/infrun.c
+++ b/gdb/infrun.c
@@ -64,6 +64,7 @@
 #include "event-loop.h"
 #include "thread-fsm.h"
 #include "common/enum-flags.h"
+#include "arch-utils.h"
 
 /* Prototypes for local functions */
 
@@ -7314,8 +7315,8 @@ handle_step_into_function (struct gdbarch *gdbarch,
 
   cust = find_pc_compunit_symtab (stop_pc);
   if (cust != NULL && compunit_language (cust) != language_asm)
-    ecs->stop_func_start = gdbarch_skip_prologue (gdbarch,
-						  ecs->stop_func_start);
+    ecs->stop_func_start
+      = gdbarch_skip_prologue_noexcept (gdbarch, ecs->stop_func_start);
 
   stop_func_sal = find_pc_line (ecs->stop_func_start, 0);
   /* Use the step_resume_break to step until the end of the prologue,
@@ -7393,8 +7394,8 @@ handle_step_into_function_backward (struct gdbarch *gdbarch,
 
   cust = find_pc_compunit_symtab (stop_pc);
   if (cust != NULL && compunit_language (cust) != language_asm)
-    ecs->stop_func_start = gdbarch_skip_prologue (gdbarch,
-						  ecs->stop_func_start);
+    ecs->stop_func_start
+      = gdbarch_skip_prologue_noexcept (gdbarch, ecs->stop_func_start);
 
   stop_func_sal = find_pc_line (stop_pc, 0);
 
--- a/gdb/symtab.c
+++ b/gdb/symtab.c
@@ -61,6 +61,7 @@
 
 #include "parser-defs.h"
 #include "completer.h"
+#include "arch-utils.h"
 
 /* Forward declarations for local functions.  */
 
@@ -3626,7 +3627,7 @@ skip_prologue_sal (struct symtab_and_line *sal)
       if (gdbarch_skip_entrypoint_p (gdbarch))
         pc = gdbarch_skip_entrypoint (gdbarch, pc);
       if (skip)
-	pc = gdbarch_skip_prologue (gdbarch, pc);
+	pc = gdbarch_skip_prologue_noexcept (gdbarch, pc);
 
       /* For overlays, map pc back into its mapped VMA range.  */
       pc = overlay_mapped_address (pc, section);
--- a/gdb/testsuite/gdb.base/reread.exp
+++ b/gdb/testsuite/gdb.base/reread.exp
@@ -15,111 +15,131 @@
 
 set prototypes 1
 
-# build the first test case
+# Build programs in PIE mode, to reproduce PR 21555.
+foreach_with_prefix opts {
+    { "" "" }
+    { "-fPIE" "ldflags=-pie" } } {
 
-set testfile1 "reread1"
-set srcfile1 ${testfile1}.c
-# Cygwin needs $EXEEXT.
-set binfile1 [standard_output_file ${testfile1}$EXEEXT]
-
-if  { [gdb_compile "${srcdir}/${subdir}/${srcfile1}" "${binfile1}" executable {debug nowarnings}] != "" } {
-    untested "failed to compile first testcase"
-    return -1
-}
-
-# build the second test case
-
-set testfile2 "reread2"
-set srcfile2 ${testfile2}.c
-set binfile2 [standard_output_file ${testfile2}$EXEEXT]
-
-if  { [gdb_compile "${srcdir}/${subdir}/${srcfile2}" "${binfile2}" executable {debug nowarnings}] != ""
-      && [gdb_compile "${srcdir}/${subdir}/${srcfile2}" "${binfile2}" executable {debug nowarnings additional_flags=-DNO_SECTIONS}] != ""} {
-    untested "failed to compile second testcase"
-    return -1
-}
-
-# Start with a fresh gdb.
-
-set testfile "reread"
-set binfile [standard_output_file ${testfile}$EXEEXT]
-
-gdb_start
-gdb_reinitialize_dir $srcdir/$subdir
-
-# Load the first executable.
-
-gdb_rename_execfile ${binfile1} ${binfile}
-gdb_load ${binfile}
-
-# Set a breakpoint at foo
-
-gdb_test "break foo" \
-    "Breakpoint.*at.* file .*$srcfile1, line 14.*" \
-    "breakpoint foo in first file"
-
-
-# Run, should see "Breakpoint 1, foo () at hello1.c:14"
-
-gdb_run_cmd
-gdb_test "" "Breakpoint.* foo .* at .*$srcfile1:14.*" "run to foo()"
-
-# Restore first executable to its original name, and move
-# second executable into its place.  Ensure that the new
-# executable is at least a second newer than the old.
-
-gdb_rename_execfile ${binfile} ${binfile1}
-gdb_rename_execfile ${binfile2} ${binfile}
-gdb_test "shell sleep 1" ".*" ""
-gdb_touch_execfile ${binfile}
-
-# Run a second time; GDB should detect that the executable has changed
-# and reset the breakpoints correctly.
-# Should see "Breakpoint 1, foo () at reread2.c:9"
-
-set test "run to foo() second time"
-if [is_remote target] {
-    unsupported $test
-} else {
-    gdb_run_cmd
-    gdb_test "" "Breakpoint.* foo .* at .*:9.*" $test
-}
-
-
-### Second pass: verify that GDB checks the executable file's
-### timestamp when the program is *restarted*, not just when it exits.
-
-if [is_remote target] {
-    unsupported "second pass: GDB should check for changes before running"
-} else {
-
-    # Put the older executable back in place.
-    gdb_rename_execfile ${binfile} ${binfile2}
-    gdb_rename_execfile ${binfile1} ${binfile}
-
-    # Restart GDB entirely.
-    clean_restart ${binfile}
-
-    # Set a breakpoint on foo and run to it.
-    gdb_test "break foo" \
-            "Breakpoint.*at.* file .*$srcfile1, line 14.*" \
-            "second pass: breakpoint foo in first file"
-    gdb_run_cmd
-    gdb_test "" "Breakpoint.* foo .* at .*$srcfile1:14.*" "second pass: run to foo()"
-
-    # This time, let the program run to completion.  If GDB checks the
-    # executable file's timestamp now, it won't notice any change.
-    gdb_continue_to_end "second pass"
-    
-    # Now move the newer executable into place, and re-run.  GDB
-    # should still notice that the executable file has changed,
-    # and still re-set the breakpoint appropriately.
-    gdb_rename_execfile ${binfile} ${binfile1}
-    gdb_rename_execfile ${binfile2} ${binfile}
-    gdb_run_cmd
-    gdb_test "" "Breakpoint.* foo .* at .*:9.*" "second pass: run to foo() second time"
-}
+	# build the first test case
 
+	set testfile1 "reread1"
+	set srcfile1 ${testfile1}.c
+	# Cygwin needs $EXEEXT.
+	set binfile1 [standard_output_file ${testfile1}$EXEEXT]
+
+	set testfile1_opt [list debug nowarnings \
+			       additional_flags=[lindex $opts 0] \
+			       [lindex $opts 1] ]
+	if  { [gdb_compile "${srcdir}/${subdir}/${srcfile1}" "${binfile1}" \
+		   executable ${testfile1_opt}] != "" } {
+	    untested "failed to compile first testcase"
+	    return -1
+	}
+
+	# build the second test case
+
+	set testfile2 "reread2"
+	set srcfile2 ${testfile2}.c
+	set binfile2 [standard_output_file ${testfile2}$EXEEXT]
+
+	set testfile2_opt1 [list debug nowarnings \
+				additional_flags=[lindex $opts 0] \
+				[lindex $opts 1]]
+	set testfile2_op2 [list debug nowarnings \
+			       "additional_flags=-DNO_SECTIONS [lindex $opts 0]" \
+			       [lindex $opts 1]]
+	if  { [gdb_compile "${srcdir}/${subdir}/${srcfile2}" "${binfile2}" \
+		   executable ${testfile2_opt1}] != ""
+	      && [gdb_compile "${srcdir}/${subdir}/${srcfile2}" "${binfile2}" \
+		      executable ${testfile2_opt2}] != ""} {
+	    untested "failed to compile second testcase"
+	    return -1
+	}
+
+	# Start with a fresh gdb.
+
+	set testfile "reread"
+	set binfile [standard_output_file ${testfile}$EXEEXT]
+
+	gdb_start
+	gdb_reinitialize_dir $srcdir/$subdir
+
+	# Load the first executable.
+
+	gdb_rename_execfile ${binfile1} ${binfile}
+	gdb_load ${binfile}
+
+	# Set a breakpoint at foo
+
+	gdb_test "break foo" \
+	    "Breakpoint.*at.* file .*$srcfile1, line 14.*" \
+	    "breakpoint foo in first file"
+
+
+	# Run, should see "Breakpoint 1, foo () at hello1.c:14"
+
+	gdb_run_cmd
+	gdb_test "" "Breakpoint.* foo .* at .*$srcfile1:14.*" "run to foo()"
+
+	# Restore first executable to its original name, and move
+	# second executable into its place.  Ensure that the new
+	# executable is at least a second newer than the old.
+
+	gdb_rename_execfile ${binfile} ${binfile1}
+	gdb_rename_execfile ${binfile2} ${binfile}
+	gdb_test "shell sleep 1" ".*" ""
+	gdb_touch_execfile ${binfile}
+
+	# Run a second time; GDB should detect that the executable has changed
+	# and reset the breakpoints correctly.
+	# Should see "Breakpoint 1, foo () at reread2.c:9"
+
+	set test "run to foo() second time"
+	if [is_remote target] {
+	    unsupported $test
+	} else {
+	    gdb_run_cmd
+	    gdb_test "" "Breakpoint.* foo .* at .*:9.*" $test
+	}
+
+
+	### Second pass: verify that GDB checks the executable file's
+	### timestamp when the program is *restarted*, not just when it exits.
+
+	if [is_remote target] {
+	    unsupported "second pass: GDB should check for changes before running"
+	} else {
+
+	    # Put the older executable back in place.
+	    gdb_rename_execfile ${binfile} ${binfile2}
+	    gdb_rename_execfile ${binfile1} ${binfile}
+
+	    # Restart GDB entirely.
+	    clean_restart ${binfile}
+
+	    # Set a breakpoint on foo and run to it.
+	    gdb_test "break foo" \
+		"Breakpoint.*at.* file .*$srcfile1, line 14.*" \
+		"second pass: breakpoint foo in first file"
+	    gdb_run_cmd
+	    gdb_test "" "Breakpoint.* foo .* at .*$srcfile1:14.*" \
+		"second pass: run to foo()"
+
+	    # This time, let the program run to completion.  If GDB checks the
+	    # executable file's timestamp now, it won't notice any change.
+	    gdb_continue_to_end "second pass"
+
+	    # Now move the newer executable into place, and re-run.  GDB
+	    # should still notice that the executable file has changed,
+	    # and still re-set the breakpoint appropriately.
+	    gdb_rename_execfile ${binfile} ${binfile1}
+	    gdb_rename_execfile ${binfile2} ${binfile}
+	    gdb_run_cmd
+	    gdb_test "" "Breakpoint.* foo .* at .*:9.*" \
+		"second pass: run to foo() second time"
+	}
+
+    }
 # End of tests.
 
 return 0



commit 16eb6b2db49e6cf2fdca56efd37689fcc170cd37
Author: Leszek Swirski <leszeks@google.com>
Date:   Mon Aug 7 16:40:38 2017 +0200

    Fix dwarf2_string_attr for -gsplit-dwarf
    
    The dwarf2_string_attr did not allow DW_FORM_GNU_str_index as a form for
    string types. This manifested as null strings in the namespace_name
    lookup (replaced with "(anonymous namespace)") when debugging
    Fission-compiled code.
    
    gdb/ChangeLog:
    
            * dwarf2read.c (dwarf2_string_attr): Allow DW_FORM_GNU_strp_alt.

### a/gdb/ChangeLog
### b/gdb/ChangeLog
## -1,3 +1,7 @@
+2017-08-07  Leszek Swirski  <leszeks@google.com>
+
+	* dwarf2read.c (dwarf2_string_attr): Allow DW_FORM_GNU_strp_alt.
+
 2017-08-07  Simon Marchi  <simon.marchi@ericsson.com>
 
 	* remote-sim.c (gdbsim_load): Remove char **argv local variable.
--- a/gdb/dwarf2read.c
+++ b/gdb/dwarf2read.c
@@ -17623,7 +17623,8 @@ dwarf2_string_attr (struct die_info *die, unsigned int name, struct dwarf2_cu *c
   if (attr != NULL)
     {
       if (attr->form == DW_FORM_strp || attr->form == DW_FORM_line_strp
-	  || attr->form == DW_FORM_string || attr->form == DW_FORM_GNU_strp_alt)
+	  || attr->form == DW_FORM_string || DW_FORM_GNU_str_index
+	  || attr->form == DW_FORM_GNU_strp_alt)
 	str = DW_STRING (attr);
       else
         complaint (&symfile_complaints,



commit b33404388e5bbd8a1fddfde73cd4593ae2b557e8
Author: H.J. Lu <hjl.tools@gmail.com>
Date:   Wed Aug 9 05:01:55 2017 -0700

    gdb: Fix build failure with GCC 7
    
    Fix:
    
    /export/gnu/import/git/sources/binutils-gdb/gdb/dwarf2read.c: In function ‘const char* dwarf2_string_attr(die_info*, unsigned int, dwarf2_cu*)’:
    /export/gnu/import/git/sources/binutils-gdb/gdb/dwarf2read.c:17626:39: error: enum constant in boolean context [-Werror=int-in-bool-context]
        || attr->form == DW_FORM_string || DW_FORM_GNU_str_index
    
            * dwarf2read.c (dwarf2_string_attr): Fix a typo.

### a/gdb/ChangeLog
### b/gdb/ChangeLog
## -1,3 +1,7 @@
+2017-08-09  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* dwarf2read.c (dwarf2_string_attr): Fix a typo.
+
 2017-08-09  Alex Lindsay  <alexlindsay239@gmail.com>
 	    Yao Qi  <yao.qi@linaro.org>
 
--- a/gdb/dwarf2read.c
+++ b/gdb/dwarf2read.c
@@ -17623,7 +17623,8 @@ dwarf2_string_attr (struct die_info *die, unsigned int name, struct dwarf2_cu *c
   if (attr != NULL)
     {
       if (attr->form == DW_FORM_strp || attr->form == DW_FORM_line_strp
-	  || attr->form == DW_FORM_string || DW_FORM_GNU_str_index
+	  || attr->form == DW_FORM_string
+	  || attr->form == DW_FORM_GNU_str_index
 	  || attr->form == DW_FORM_GNU_strp_alt)
 	str = DW_STRING (attr);
       else



commit b3e687f4c5e2bd847ea0608fd8960820f3efbda3
Author: Maciej W. Rozycki <macro@imgtec.com>
Date:   Fri Aug 11 10:40:06 2017 +0100

    PR breakpoints/21886: mem-break: Fix breakpoint insertion location
    
    Fix a commit cd6c3b4ffc4e ("New gdbarch methods breakpoint_kind_from_pc
    and sw_breakpoint_from_kind") regression and restore the use of
    `->placed_address' rather than `->reqstd_address' as the location for a
    memory breakpoint to be inserted at.  Previously
    `gdbarch_breakpoint_from_pc' was used that made that adjustment in
    `default_memory_insert_breakpoint' from the preinitialized value,
    however with the said commit that call is gone, so the passed
    `->placed_address' has to be used for the initialization.
    
    The regression manifests itself as the inability to debug any MIPS/Linux
    compressed ISA dynamic executable as GDB corrupts the dynamic loader
    with one of its implicit breakpoints, causing the program to crash, as
    seen for example with the `mips-linux-gnu' target, o32 ABI, MIPS16 code,
    and the gdb.base/advance.exp test case:
    
    (gdb) continue
    Continuing.
    
    Program received signal SIGBUS, Bus error.
    _dl_debug_initialize (ldbase=0, ns=0) at dl-debug.c:51
    51          r = &_r_debug;
    (gdb) FAIL: gdb.base/advance.exp: Can't run to main
    
            gdb/
            PR breakpoints/21886
            * mem-break.c (default_memory_insert_breakpoint): Use
            `->placed_address' rather than `->reqstd_address' for the
            breakpoint location.
    
    (cherry picked from commit ba7b109b296feac8cf8cab74db5f824dfa631610)

### a/gdb/ChangeLog
### b/gdb/ChangeLog
## -1,3 +1,10 @@
+2017-08-11  Maciej W. Rozycki  <macro@imgtec.com>
+
+	PR breakpoints/21886
+	* mem-break.c (default_memory_insert_breakpoint): Use
+	`->placed_address' rather than `->reqstd_address' for the
+	breakpoint location.
+
 2017-07-25  Yao Qi  <yao.qi@linaro.org>
 
 	PR gdb/21555
--- a/gdb/mem-break.c
+++ b/gdb/mem-break.c
@@ -37,7 +37,7 @@ int
 default_memory_insert_breakpoint (struct gdbarch *gdbarch,
 				  struct bp_target_info *bp_tgt)
 {
-  CORE_ADDR addr = bp_tgt->reqstd_address;
+  CORE_ADDR addr = bp_tgt->placed_address;
   const unsigned char *bp;
   gdb_byte *readbuf;
   int bplen;



commit 06f84c95a2d88d03c1c231bfd436ac9d225d6615
Author: Jan Kratochvil <jan.kratochvil@redhat.com>
Date:   Thu Aug 24 10:26:52 2017 +0200

    DWARF-5: Fix -fdebug-types-section
    
    GDB was now accessing as signatured_type memory allocated only by size of
    dwarf2_per_cu_data.
    
    gdb/ChangeLog
    2017-08-24  Jan Kratochvil  <jan.kratochvil@redhat.com>
    
            * dwarf2read.c (build_type_psymtabs_reader): New prototype.
            (process_psymtab_comp_unit): Accept IS_DEBUG_TYPES.
            (read_comp_units_from_section): New parameter abbrev_section, use
            read_and_check_comp_unit_head, allocate signatured_type if needed.
            (create_all_comp_units): Update read_comp_units_from_section caller.

### a/gdb/ChangeLog
### b/gdb/ChangeLog
## -1,3 +1,11 @@
+2017-08-24  Jan Kratochvil  <jan.kratochvil@redhat.com>
+
+	* dwarf2read.c (build_type_psymtabs_reader): New prototype.
+	(process_psymtab_comp_unit): Accept IS_DEBUG_TYPES.
+	(read_comp_units_from_section): New parameter abbrev_section, use
+	read_and_check_comp_unit_head, allocate signatured_type if needed.
+	(create_all_comp_units): Update read_comp_units_from_section caller.
+
 2017-08-11  Maciej W. Rozycki  <macro@imgtec.com>
 
 	PR breakpoints/21886
--- a/gdb/dwarf2read.c
+++ b/gdb/dwarf2read.c
@@ -1510,6 +1510,11 @@ static void dwarf2_find_base_address (struct die_info *die,
 static struct partial_symtab *create_partial_symtab
   (struct dwarf2_per_cu_data *per_cu, const char *name);
 
+static void build_type_psymtabs_reader (const struct die_reader_specs *reader,
+					const gdb_byte *info_ptr,
+					struct die_info *type_unit_die,
+					int has_children, void *data);
+
 static void dwarf2_build_psymtabs_hard (struct objfile *);
 
 static void scan_partial_symbols (struct partial_die_info *,
@@ -6247,8 +6252,6 @@ process_psymtab_comp_unit (struct dwarf2_per_cu_data *this_cu,
 			   int want_partial_unit,
 			   enum language pretend_language)
 {
-  struct process_psymtab_comp_unit_data info;
-
   /* If this compilation unit was already read in, free the
      cached copy in order to read it in again.	This is
      necessary because we skipped some symbols when we first
@@ -6257,12 +6260,17 @@ process_psymtab_comp_unit (struct dwarf2_per_cu_data *this_cu,
   if (this_cu->cu != NULL)
     free_one_cached_comp_unit (this_cu);
 
-  gdb_assert (! this_cu->is_debug_types);
-  info.want_partial_unit = want_partial_unit;
-  info.pretend_language = pretend_language;
-  init_cutu_and_read_dies (this_cu, NULL, 0, 0,
-			   process_psymtab_comp_unit_reader,
-			   &info);
+  if (this_cu->is_debug_types)
+    init_cutu_and_read_dies (this_cu, NULL, 0, 0, build_type_psymtabs_reader,
+			     NULL);
+  else
+    {
+      process_psymtab_comp_unit_data info;
+      info.want_partial_unit = want_partial_unit;
+      info.pretend_language = pretend_language;
+      init_cutu_and_read_dies (this_cu, NULL, 0, 0,
+			       process_psymtab_comp_unit_reader, &info);
+    }
 
   /* Age out any secondary CUs.  */
   age_cached_comp_units ();
@@ -6717,6 +6725,7 @@ load_partial_comp_unit (struct dwarf2_per_cu_data *this_cu)
 static void
 read_comp_units_from_section (struct objfile *objfile,
 			      struct dwarf2_section_info *section,
+			      struct dwarf2_section_info *abbrev_section,
 			      unsigned int is_dwz,
 			      int *n_allocated,
 			      int *n_comp_units,
@@ -6736,20 +6745,33 @@ read_comp_units_from_section (struct objfile *objfile,
 
   while (info_ptr < section->buffer + section->size)
     {
-      unsigned int length, initial_length_size;
       struct dwarf2_per_cu_data *this_cu;
 
       sect_offset sect_off = (sect_offset) (info_ptr - section->buffer);
 
-      /* Read just enough information to find out where the next
-	 compilation unit is.  */
-      length = read_initial_length (abfd, info_ptr, &initial_length_size);
+      comp_unit_head cu_header;
+      read_and_check_comp_unit_head (&cu_header, section, abbrev_section,
+				     info_ptr, rcuh_kind::COMPILE);
 
       /* Save the compilation unit for later lookup.  */
-      this_cu = XOBNEW (&objfile->objfile_obstack, struct dwarf2_per_cu_data);
-      memset (this_cu, 0, sizeof (*this_cu));
+      if (cu_header.unit_type != DW_UT_type)
+	{
+	  this_cu = XOBNEW (&objfile->objfile_obstack,
+			    struct dwarf2_per_cu_data);
+	  memset (this_cu, 0, sizeof (*this_cu));
+	}
+      else
+	{
+	  auto sig_type = XOBNEW (&objfile->objfile_obstack,
+				  struct signatured_type);
+	  memset (sig_type, 0, sizeof (*sig_type));
+	  sig_type->signature = cu_header.signature;
+	  sig_type->type_offset_in_tu = cu_header.type_cu_offset_in_tu;
+	  this_cu = &sig_type->per_cu;
+	}
+      this_cu->is_debug_types = (cu_header.unit_type == DW_UT_type);
       this_cu->sect_off = sect_off;
-      this_cu->length = length + initial_length_size;
+      this_cu->length = cu_header.length + cu_header.initial_length_size;
       this_cu->is_dwz = is_dwz;
       this_cu->objfile = objfile;
       this_cu->section = section;
@@ -6782,12 +6804,13 @@ create_all_comp_units (struct objfile *objfile)
   n_allocated = 10;
   all_comp_units = XNEWVEC (struct dwarf2_per_cu_data *, n_allocated);
 
-  read_comp_units_from_section (objfile, &dwarf2_per_objfile->info, 0,
+  read_comp_units_from_section (objfile, &dwarf2_per_objfile->info,
+				&dwarf2_per_objfile->abbrev, 0,
 				&n_allocated, &n_comp_units, &all_comp_units);
 
   dwz = dwarf2_get_dwz_file ();
   if (dwz != NULL)
-    read_comp_units_from_section (objfile, &dwz->info, 1,
+    read_comp_units_from_section (objfile, &dwz->info, &dwz->abbrev, 1,
 				  &n_allocated, &n_comp_units,
 				  &all_comp_units);
 



commit f74f69f45570ced87b9f778983a63157b551a129
Author: Jan Kratochvil <jan.kratochvil@redhat.com>
Date:   Thu Aug 24 16:39:11 2017 +0200

    DWARF-5 Fix DW_FORM_implicit_const
    
    -gdwarf-4:
    ptype logical
    type = const char [2]
    (gdb) PASS: gdb.base/constvars.exp: ptype logical
    
    -gdwarf-5:
    ptype logical
    type = const char []
    (gdb) FAIL: gdb.base/constvars.exp: ptype logical
    
     <2><2fc>: Abbrev Number: 1 (DW_TAG_variable)
        <2fd>   DW_AT_name        : (indirect string, offset: 0x2eb): logical
        <301>   DW_AT_decl_file   : 1
    
       1      DW_TAG_variable    [no children]
        DW_AT_name         DW_FORM_strp
        DW_AT_decl_file    DW_FORM_implicit_const: 1
    
    During symbol reading, invalid attribute class or form for
    'DW_FORM_implicit_const' in '(null)'.
    
    gdb/ChangeLog
    2017-08-24  Jan Kratochvil  <jan.kratochvil@redhat.com>
    
            PR symtab/22003
            * dwarf2read.c (dwarf2_const_value_attr, dump_die_shallow)
            (dwarf2_get_attr_constant_value, dwarf2_fetch_constant_bytes)
            (skip_form_bytes, attr_form_is_constant): Handle DW_FORM_implicit_const.

### a/gdb/ChangeLog
### b/gdb/ChangeLog
## -1,5 +1,12 @@
 2017-08-24  Jan Kratochvil  <jan.kratochvil@redhat.com>
 
+	PR symtab/22003
+	* dwarf2read.c (dwarf2_const_value_attr, dump_die_shallow)
+	(dwarf2_get_attr_constant_value, dwarf2_fetch_constant_bytes)
+	(skip_form_bytes, attr_form_is_constant): Handle DW_FORM_implicit_const.
+
+2017-08-24  Jan Kratochvil  <jan.kratochvil@redhat.com>
+
 	* dwarf2read.c (build_type_psymtabs_reader): New prototype.
 	(process_psymtab_comp_unit): Accept IS_DEBUG_TYPES.
 	(read_comp_units_from_section): New parameter abbrev_section, use
--- a/gdb/dwarf2read.c
+++ b/gdb/dwarf2read.c
@@ -19430,6 +19430,7 @@ dwarf2_const_value_attr (const struct attribute *attr, struct type *type,
       break;
 
     case DW_FORM_sdata:
+    case DW_FORM_implicit_const:
       *value = DW_SND (attr);
       break;
 
@@ -20423,6 +20424,10 @@ dump_die_shallow (struct ui_file *f, int indent, struct die_info *die)
 	  fprintf_unfiltered (f, 
 			      "unexpected attribute form: DW_FORM_indirect");
 	  break;
+	case DW_FORM_implicit_const:
+	  fprintf_unfiltered (f, "constant: %s",
+			      plongest (DW_SND (&die->attrs[i])));
+	  break;
 	default:
 	  fprintf_unfiltered (f, "unsupported attribute form: %d.",
 		   die->attrs[i].form);
@@ -20514,7 +20519,7 @@ dwarf2_get_ref_die_offset (const struct attribute *attr)
 static LONGEST
 dwarf2_get_attr_constant_value (const struct attribute *attr, int default_value)
 {
-  if (attr->form == DW_FORM_sdata)
+  if (attr->form == DW_FORM_sdata || attr->form == DW_FORM_implicit_const)
     return DW_SND (attr);
   else if (attr->form == DW_FORM_udata
            || attr->form == DW_FORM_data1
@@ -20849,6 +20854,7 @@ dwarf2_fetch_constant_bytes (sect_offset sect_off,
       break;
 
     case DW_FORM_sdata:
+    case DW_FORM_implicit_const:
       type = die_type (die, cu);
       result = write_constant_as_bytes (obstack, byte_order,
 					type, DW_SND (attr), len);
@@ -21785,6 +21791,9 @@ skip_form_bytes (bfd *abfd, const gdb_byte *bytes, const gdb_byte *buffer_end,
 	}
       break;
 
+    case DW_FORM_implicit_const:
+      break;
+
     default:
       {
       complain:
@@ -22426,6 +22435,7 @@ attr_form_is_constant (const struct attribute *attr)
     case DW_FORM_data2:
     case DW_FORM_data4:
     case DW_FORM_data8:
+    case DW_FORM_implicit_const:
       return 1;
     default:
       return 0;
