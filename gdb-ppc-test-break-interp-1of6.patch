http://sourceware.org/ml/gdb-cvs/2010-07/msg00070.html

[ Left only lib/gdb.exp.  ]

### src/gdb/testsuite/ChangeLog	2010/07/07 18:49:50	1.2377
### src/gdb/testsuite/ChangeLog	2010/07/12 17:33:14	1.2378
## -1,3 +1,33 @@
+2010-07-12  Ulrich Weigand  <uweigand@de.ibm.com>
+	    H.J. Lu  <hongjiu.lu@intel.com>
+
+	* lib/gdb.exp (is_ilp32_target): New.
+	(is_lp64_target): Likewise.
+
+	* gdb.arch/amd64-byte.exp: Use is_lp64_target to check 64bit
+	target.
+	* gdb.arch/amd64-disp-step.exp: Likewise.
+	* gdb.arch/amd64-dword.exp: Likewise.
+	* gdb.arch/amd64-i386-address.exp: Likewise.
+	* gdb.arch/amd64-word.exp: Likewise.
+	
+	* gdb.arch/i386-avx.exp: Use is_ilp32_target to check for 32bit
+	target.
+	* gdb.arch/i386-bp_permanent.exp: Likewise.
+	* gdb.arch/i386-byte.exp: Likewise.
+	* gdb.arch/i386-disp-step.exp: Likewise.
+	* gdb.arch/i386-gnu-cfi.exp: Likewise.
+	* gdb.arch/i386-prologue.exp: Likewise.
+	* gdb.arch/i386-size-overlap.exp: Likewise.
+	* gdb.arch/i386-size.exp: Likewise.
+	* gdb.arch/i386-sse.exp: Likewise.
+	* gdb.arch/i386-unwind.exp: Likewise.
+	* gdb.arch/i386-word.exp: Likewise.
+
+	* gdb.arch/ppc64-atomic-inst.exp: Use is_lp64_target to execute
+	test only when building 64-bit executables.  Do not hard-code
+	-m64 option.
+
 2010-07-07  Doug Evans  <dje@google.com>
 
 	* lib/gdb.exp (gdb_test_list_exact): New function.
--- src/gdb/testsuite/lib/gdb.exp	2010/07/07 18:49:51	1.153
+++ src/gdb/testsuite/lib/gdb.exp	2010/07/12 17:33:15	1.154
@@ -1454,6 +1454,83 @@
     return 1
 }
 
+# Return 1 if target is ILP32.
+# This cannot be decided simply from looking at the target string,
+# as it might depend on externally passed compiler options like -m64.
+proc is_ilp32_target {} {
+    global is_ilp32_target_saved
+
+    # Use the cached value, if it exists.  Cache value per "board" to handle
+    # runs with multiple options (e.g. unix/{-m32,-64}) correctly.
+    set me "is_ilp32_target"
+    set board [target_info name]
+    if [info exists is_ilp32_target_saved($board)] {
+        verbose "$me:  returning saved $is_ilp32_target_saved($board)" 2
+        return $is_ilp32_target_saved($board)
+    }
+
+
+    set src ilp32[pid].c
+    set obj ilp32[pid].o
+
+    set f [open $src "w"]
+    puts $f "int dummy\[sizeof (int) == 4"
+    puts $f "           && sizeof (void *) == 4"
+    puts $f "           && sizeof (long) == 4 ? 1 : -1\];"
+    close $f
+
+    verbose "$me:  compiling testfile $src" 2
+    set lines [gdb_compile $src $obj object {quiet}]
+    file delete $src
+    file delete $obj
+
+    if ![string match "" $lines] then {
+        verbose "$me:  testfile compilation failed, returning 0" 2
+        return [set is_ilp32_target_saved($board) 0]
+    }
+
+    verbose "$me:  returning 1" 2
+    return [set is_ilp32_target_saved($board) 1]
+}
+
+# Return 1 if target is LP64.
+# This cannot be decided simply from looking at the target string,
+# as it might depend on externally passed compiler options like -m64.
+proc is_lp64_target {} {
+    global is_lp64_target_saved
+
+    # Use the cached value, if it exists.  Cache value per "board" to handle
+    # runs with multiple options (e.g. unix/{-m32,-64}) correctly.
+    set me "is_lp64_target"
+    set board [target_info name]
+    if [info exists is_lp64_target_saved($board)] {
+        verbose "$me:  returning saved $is_lp64_target_saved($board)" 2
+        return $is_lp64_target_saved($board)
+    }
+
+    set src lp64[pid].c
+    set obj lp64[pid].o
+
+    set f [open $src "w"]
+    puts $f "int dummy\[sizeof (int) == 4"
+    puts $f "           && sizeof (void *) == 8"
+    puts $f "           && sizeof (long) == 8 ? 1 : -1\];"
+    close $f
+
+    verbose "$me:  compiling testfile $src" 2
+    set lines [gdb_compile $src $obj object {quiet}]
+    file delete $src
+    file delete $obj
+
+    if ![string match "" $lines] then {
+        verbose "$me:  testfile compilation failed, returning 0" 2
+        return [set is_lp64_target_saved($board) 0]
+    }
+
+    verbose "$me:  returning 1" 2
+    return [set is_lp64_target_saved($board) 1]
+}
+
 # Run a test on the target to see if it supports vmx hardware.  Return 0 if so, 
 # 1 if it does not.  Based on 'check_vmx_hw_available' from the GCC testsuite.
 
