http://sourceware.org/ml/gdb-patches/2010-02/msg00477.html
Subject: Re: [patch] Fix crash on stale addrinfo->sectindex

On Fri, 19 Feb 2010 04:01:05 +0100, Tom Tromey wrote:
> >>>>> "Jan" == Jan Kratochvil <jan.kratochvil@redhat.com> writes:
> I think you ought to move this comment as well.
> It appears to just be hanging at the end of a block after the patch.

Yes; forgot.

> This is ok with that change.  Thanks.

Checked-in.

On Fri, 19 Feb 2010 04:10:30 +0100, Tom Tromey wrote:
> Oh, by the way, I think this is reasonable for 7.1.  It is
> straightforward and fixes a reported crash.  If Joel agrees, please put
> it on the branch.  Thanks.

OK for the branch?


Thanks,
Jan


http://sourceware.org/ml/gdb-cvs/2010-02/msg00162.html

### src/gdb/ChangeLog	2010/02/19 00:35:53	1.11380
### src/gdb/ChangeLog	2010/02/19 06:19:44	1.11381
## -1,3 +1,10 @@
+2010-02-19  Jan Kratochvil  <jan.kratochvil@redhat.com>
+
+	* symfile.c (addr_info_make_relative): Extend comment.  Move SECT to
+	a more inner block.  Initialize ADDR by LOWER_OFFSET only if it was
+	found by bfd_get_section_by_name.
+	* symfile.h (struct section_addr_info) <sectindex>: New comment.
+
 2010-02-19  Joel Brobecker  <brobecker@adacore.com>
 
 	* NEWS: Add new "[...] since 7.1" section.  Rename the "[...] since
--- src/gdb/symfile.c	2010/02/18 19:17:00	1.272
+++ src/gdb/symfile.c	2010/02/19 06:19:45	1.273
@@ -562,13 +562,13 @@
 }
 
 /* Relativize absolute addresses in ADDRS into offsets based on ABFD.  Fill-in
-   also SECTINDEXes there.  */
+   also SECTINDEXes specific to ABFD there.  This function can be used to
+   rebase ADDRS to start referencing different BFD than before.  */
 
 void
 addr_info_make_relative (struct section_addr_info *addrs, bfd *abfd)
 {
   asection *lower_sect;
-  asection *sect;
   CORE_ADDR lower_offset;
   int i;
 
@@ -597,25 +597,29 @@
 
   for (i = 0; i < addrs->num_sections && addrs->other[i].name; i++)
     {
-      if (addrs->other[i].addr != 0)
+      asection *sect = bfd_get_section_by_name (abfd, addrs->other[i].name);
+
+      if (sect)
 	{
-	  sect = bfd_get_section_by_name (abfd, addrs->other[i].name);
-	  if (sect)
+	  /* This is the index used by BFD. */
+	  addrs->other[i].sectindex = sect->index;
+
+	  if (addrs->other[i].addr != 0)
 	    {
 	      addrs->other[i].addr -= bfd_section_vma (abfd, sect);
 	      lower_offset = addrs->other[i].addr;
-	      /* This is the index used by BFD. */
-	      addrs->other[i].sectindex = sect->index;
 	    }
 	  else
-	    {
-	      warning (_("section %s not found in %s"), addrs->other[i].name,
-		       bfd_get_filename (abfd));
-	      addrs->other[i].addr = 0;
-	    }
+	    addrs->other[i].addr = lower_offset;
 	}
       else
-	addrs->other[i].addr = lower_offset;
+	{
+	  warning (_("section %s not found in %s"), addrs->other[i].name,
+		   bfd_get_filename (abfd));
+	  addrs->other[i].addr = 0;
+
+	  /* SECTINDEX is invalid if ADDR is zero.  */
+	}
     }
 }
 
--- src/gdb/symfile.h	2010/02/03 14:13:16	1.64
+++ src/gdb/symfile.h	2010/02/19 06:19:45	1.65
@@ -80,6 +80,8 @@
   {
     CORE_ADDR addr;
     char *name;
+
+    /* SECTINDEX must be valid for associated BFD if ADDR is not zero.  */
     int sectindex;
   } other[1];
 };

