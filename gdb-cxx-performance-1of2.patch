http://sourceware.org/ml/gdb-cvs/2013-06/msg00034.html

### src/gdb/ChangeLog	2013/06/05 20:43:53	1.15689
### src/gdb/ChangeLog	2013/06/05 22:28:51	1.15690
## -1,3 +1,14 @@
+2013-06-05  Doug Evans  <dje@google.com>
+	    Keith Seitz  <keiths@redhat.com>
+
+	PR 15519
+	* cp-namespace.c (find_symbol_in_baseclass): Call
+	cp_lookup_symbol_in_namespace instead of cp_lookup_symbol_namespace.
+	Check result of call to lookup_symbol_static.
+	Call lookup_static_symbol_aux unconditionally.
+	Call check_typedef on base types before accessing them.
+	(cp_lookup_nested_symbol): Fix comment.
+
 2013-06-05  Luis Machado  <lgustavo@codesourcery.com>
 
 	* gnu-v3-abi.c (gnuv3_skip_trampoline): Handle thunk
--- src/gdb/cp-namespace.c	2013/05/30 17:29:06	1.67
+++ src/gdb/cp-namespace.c	2013/06/05 22:28:51	1.68
@@ -720,36 +720,40 @@
   for (i = 0; i < TYPE_N_BASECLASSES (parent_type); ++i)
     {
       size_t len;
+      struct type *base_type = TYPE_BASECLASS (parent_type, i);
       const char *base_name = TYPE_BASECLASS_NAME (parent_type, i);
 
       if (base_name == NULL)
 	continue;
 
       /* Search this particular base class.  */
-      sym = cp_lookup_symbol_namespace (base_name, name, block, VAR_DOMAIN);
+      sym = cp_lookup_symbol_in_namespace (base_name, name, block,
+					   VAR_DOMAIN, 0);
       if (sym != NULL)
 	break;
 
+      /* Now search all static file-level symbols.  We have to do this for
+	 things like typedefs in the class.  First search in this symtab,
+	 what we want is possibly there.  */
       len = strlen (base_name) + 2 + strlen (name) + 1;
       concatenated_name = xrealloc (concatenated_name, len);
       xsnprintf (concatenated_name, len, "%s::%s", base_name, name);
       sym = lookup_symbol_static (concatenated_name, block, VAR_DOMAIN);
+      if (sym != NULL)
+	break;
 
-      /* If there is currently no BLOCK, e.g., the inferior hasn't yet
-	 been started, then try searching all STATIC_BLOCK symbols in
-	 all objfiles.  */
-      if (block == NULL)
-	{
-	  sym = lookup_static_symbol_aux (concatenated_name, VAR_DOMAIN);
-	  if (sym != NULL)
-	    break;
-	}
+      /* Nope.  We now have to search all static blocks in all objfiles,
+	 even if block != NULL, because there's no guarantees as to which
+	 symtab the symbol we want is in.  */
+      sym = lookup_static_symbol_aux (concatenated_name, VAR_DOMAIN);
+      if (sym != NULL)
+	break;
 
       /* If this class has base classes, search them next.  */
-      if (TYPE_N_BASECLASSES (TYPE_BASECLASS (parent_type, i)) > 0)
+      CHECK_TYPEDEF (base_type);
+      if (TYPE_N_BASECLASSES (base_type) > 0)
 	{
-	  sym = find_symbol_in_baseclass (TYPE_BASECLASS (parent_type, i),
-					  name, block);
+	  sym = find_symbol_in_baseclass (base_type, name, block);
 	  if (sym != NULL)
 	    break;
 	}
@@ -797,8 +801,8 @@
 	if (sym != NULL)
 	  return sym;
 
-	/* Now search all static file-level symbols.  Not strictly
-	   correct, but more useful than an error.  We do not try to
+	/* Now search all static file-level symbols.  We have to do this
+	   for things like typedefs in the class.  We do not try to
 	   guess any imported namespace as even the fully specified
 	   namespace search is already not C++ compliant and more
 	   assumptions could make it too magic.  */
### src/gdb/testsuite/ChangeLog	2013/06/05 20:38:37	1.3685
### src/gdb/testsuite/ChangeLog	2013/06/05 22:28:51	1.3686
## -1,3 +1,11 @@
+2013-06-05  Doug Evans  <dje@google.com>
+	    Keith Seitz  <keiths@redhat.com>
+
+	* gdb.cp/derivation2.cc: New file.
+	* gdb.cp/derivation.cc (main): Call foo2.
+	* gdb.cp/derivation.exp: Add tests for typedefs in another
+	file, and when there's an active block.
+
 2013-06-05  Luis Machado  <lgustavo@codesourcery.com>
 
 	* gdb.cp/virtfunc.exp (make_one_vtable_result): Handle extra output
--- src/gdb/testsuite/gdb.cp/derivation2.cc
+++ src/gdb/testsuite/gdb.cp/derivation2.cc	2013-06-10 12:35:14.881272247 +0000
@@ -0,0 +1,49 @@
+/* This testcase is part of GDB, the GNU debugger.
+
+   Copyright 2013 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+   */
+
+/* A copy of some classes in derivation.cc so that we can test symbol lookup
+   in other CUs.  */
+
+class A2 {
+public:
+    typedef int value_type;
+    value_type a;
+
+    A2()
+    {
+        a=1;
+    }
+};
+
+class D2 : public A2 {
+public:
+    value_type d;
+
+    D2()
+    {
+        d=7;
+    }
+};
+
+void
+foo2 ()
+{
+  D2 d2_instance;
+  d2_instance.a = 42;
+  d2_instance.d = 43;
+}
--- src/gdb/testsuite/gdb.cp/derivation.cc	2013/01/01 06:33:27	1.5
+++ src/gdb/testsuite/gdb.cp/derivation.cc	2013/06/05 22:28:51	1.6
@@ -16,6 +16,8 @@
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
    */
 
+extern void foo2 (); /* from derivation2.cc */
+
 namespace N {
   typedef double value_type;
   struct Base { typedef int value_type; };
@@ -306,9 +308,7 @@
     N::Derived::value_type d = 1;
     N::value_type n = 3.0;
     dobj.doit ();
+    foo2 ();
     return 0;
     
 }
-
-    
-    
--- src/gdb/testsuite/gdb.cp/derivation.exp	2013/01/01 06:33:27	1.24
+++ src/gdb/testsuite/gdb.cp/derivation.exp	2013/06/05 22:28:51	1.25
@@ -32,14 +32,15 @@
 
 load_lib "cp-support.exp"
 
-standard_testfile .cc
+standard_testfile derivation.cc derivation2.cc
 
-if {[prepare_for_testing $testfile.exp $testfile $srcfile {debug c++}]} {
+if {[prepare_for_testing $testfile.exp $testfile \
+	[list $srcfile $srcfile2] {debug c++}]} {
     return -1
 }
 
 # Check inheritance of typedefs.
-foreach klass {"A" "D" "E" "F"} {
+foreach klass {"A" "D" "E" "F" "A2" "D2"} {
     gdb_test "ptype ${klass}::value_type" "type = int"
     gdb_test "whatis ${klass}::value_type" "type = int"
     gdb_test "p (${klass}::value_type) 0" " = 0"
@@ -57,6 +58,13 @@
     continue
 }
 
+# Check inheritance of typedefs again, but this time with an active block.
+foreach klass {"A" "D" "A2" "D2"} {
+    gdb_test "ptype ${klass}::value_type" "type = int"
+    gdb_test "whatis ${klass}::value_type" "type = int"
+    gdb_test "p (${klass}::value_type) 0" " = 0"
+}
+
 gdb_test "up" ".*main.*" "up from marker1"
 
 # Print class types and values.
