http://sourceware.org/ml/gdb-cvs/2010-10/msg00067.html

### src/gdb/ChangeLog	2010/10/08 20:45:20	1.12248
### src/gdb/ChangeLog	2010/10/11 08:50:28	1.12249
## -1,3 +1,9 @@
+2010-10-11  Jan Kratochvil  <jan.kratochvil@redhat.com>
+
+	Fix attaching to re-prelinked executables on ppc64.
+	* solib-svr4.c (svr4_exec_displacement): New variable plt2_asect,
+	initialize it, try to adjust FILESZ field by it.
+
 2010-10-08  Daniel Jacobowitz  <dan@codesourcery.com>
 
 	* tracepoint.c (merge_uploaded_trace_state_variables): Only print
--- src/gdb/solib-svr4.c	2010/08/03 22:35:41	1.138
+++ src/gdb/solib-svr4.c	2010/10/11 08:50:33	1.139
@@ -1844,6 +1844,7 @@
 		  Elf32_External_Phdr *phdr2p;
 		  gdb_byte *buf_vaddr_p, *buf_paddr_p;
 		  CORE_ADDR vaddr, paddr;
+		  asection *plt2_asect;
 
 		  phdrp = &((Elf32_External_Phdr *) buf)[i];
 		  buf_vaddr_p = (gdb_byte *) &phdrp->p_vaddr;
@@ -1869,6 +1870,34 @@
 		  if (memcmp (phdrp, phdr2p, sizeof (*phdrp)) == 0)
 		    continue;
 
+		  /* prelink can convert .plt SHT_NOBITS to SHT_PROGBITS.  */
+		  plt2_asect = bfd_get_section_by_name (exec_bfd, ".plt");
+		  if (plt2_asect)
+		    {
+		      int content2;
+		      gdb_byte *buf_filesz_p = (gdb_byte *) &phdrp->p_filesz;
+		      CORE_ADDR filesz;
+
+		      content2 = (bfd_get_section_flags (exec_bfd, plt2_asect)
+				  & SEC_HAS_CONTENTS) != 0;
+
+		      filesz = extract_unsigned_integer (buf_filesz_p, 4,
+							 byte_order);
+
+		      /* PLT2_ASECT is from on-disk file (exec_bfd) while
+			 FILESZ is from the in-memory image.  */
+		      if (content2)
+			filesz += bfd_get_section_size (plt2_asect);
+		      else
+			filesz -= bfd_get_section_size (plt2_asect);
+
+		      store_unsigned_integer (buf_filesz_p, 4, byte_order,
+					      filesz);
+
+		      if (memcmp (phdrp, phdr2p, sizeof (*phdrp)) == 0)
+			continue;
+		    }
+
 		  ok = 0;
 		  break;
 		}
@@ -1921,6 +1950,7 @@
 		  Elf64_External_Phdr *phdr2p;
 		  gdb_byte *buf_vaddr_p, *buf_paddr_p;
 		  CORE_ADDR vaddr, paddr;
+		  asection *plt2_asect;
 
 		  phdrp = &((Elf64_External_Phdr *) buf)[i];
 		  buf_vaddr_p = (gdb_byte *) &phdrp->p_vaddr;
@@ -1946,6 +1976,34 @@
 		  if (memcmp (phdrp, phdr2p, sizeof (*phdrp)) == 0)
 		    continue;
 
+		  /* prelink can convert .plt SHT_NOBITS to SHT_PROGBITS.  */
+		  plt2_asect = bfd_get_section_by_name (exec_bfd, ".plt");
+		  if (plt2_asect)
+		    {
+		      int content2;
+		      gdb_byte *buf_filesz_p = (gdb_byte *) &phdrp->p_filesz;
+		      CORE_ADDR filesz;
+
+		      content2 = (bfd_get_section_flags (exec_bfd, plt2_asect)
+				  & SEC_HAS_CONTENTS) != 0;
+
+		      filesz = extract_unsigned_integer (buf_filesz_p, 8,
+							 byte_order);
+
+		      /* PLT2_ASECT is from on-disk file (exec_bfd) while
+			 FILESZ is from the in-memory image.  */
+		      if (content2)
+			filesz += bfd_get_section_size (plt2_asect);
+		      else
+			filesz -= bfd_get_section_size (plt2_asect);
+
+		      store_unsigned_integer (buf_filesz_p, 8, byte_order,
+					      filesz);
+
+		      if (memcmp (phdrp, phdr2p, sizeof (*phdrp)) == 0)
+			continue;
+		    }
+
 		  ok = 0;
 		  break;
 		}
