TODO: ./gdb/testsuite/gdb.threads/watchthreads2.exp

It applies only to recent (~2.6.20) Linux kernels, on RHEL4 the behavior is not
changed (and this patch has no effect there).


--- ./gdb/testsuite/gdb.threads/watchthreads.exp	9 Jan 2007 17:59:14 -0000	1.3
+++ ./gdb/testsuite/gdb.threads/watchthreads.exp	20 Apr 2007 19:11:01 -0000
@@ -65,25 +65,42 @@ set inc_line [gdb_get_line_number "Loop 
 
 # Loop and continue to allow both watchpoints to be triggered.
 for {set i 0} {$i < 30} {incr i} {
-  set test_flag 0
+  set test_flag_0 0
+  set test_flag_1 0
   gdb_test_multiple "continue" "threaded watch loop" {
-    -re "Hardware watchpoint 2: args\\\[0\\\].*Old value = 0.*New value = 1.*main \\\(\\\) at .*watchthreads.c:$init_line.*$gdb_prompt $"
-       { set args_0 1; set test_flag 1 }
-    -re "Hardware watchpoint 3: args\\\[1\\\].*Old value = 0.*New value = 1.*main \\\(\\\) at .*watchthreads.c:$init_line.*$gdb_prompt $"
-       { set args_1 1; set test_flag 1 }
-    -re "Hardware watchpoint 2: args\\\[0\\\].*Old value = $args_0.*New value = [expr $args_0+1].*in thread_function \\\(arg=0x0\\\) at .*watchthreads.c:$inc_line.*$gdb_prompt $"
-       { set args_0 [expr $args_0+1]; set test_flag 1 }
-    -re "Hardware watchpoint 3: args\\\[1\\\].*Old value = $args_1.*New value = [expr $args_1+1].*in thread_function \\\(arg=0x1\\\) at .*watchthreads.c:$inc_line.*$gdb_prompt $"
-       { set args_1 [expr $args_1+1]; set test_flag 1 }
+    -re "(.*)$gdb_prompt $" {
+      set test_flag_1 1
+      set string $expect_out(1,string)
+      foreach match [regexp -nocase -all -inline "Hardware watchpoint .*? at .*?watchthreads.c:\[0-9\]*\r" $string] {
+	# FIXME: Test also for the trailing: \[^\r\]*main \\\(\\\) at .*?watchthreads.c:$init_line\r
+	# We cannot test the line position as we do not get it for the
+	# non-active threads (not being last in the list).
+	if [regexp "Hardware watchpoint 2: args\\\[0\\\]\[^\r\]*\r\[^\r\]*\r\[^\r\]*Old value = 0\[^\r\]*\r\[^\r\]*New value = 1\r" $match] {
+	  set args_0 1; set test_flag_0 1
+	}
+	# FIXME: Test also for the trailing: \[^\r\]*main \\\(\\\) at .*?watchthreads.c:$init_line\r
+	if [regexp "Hardware watchpoint 3: args\\\[1\\\]\[^\r\]*\r\[^\r\]*\r\[^\r\]*Old value = 0\[^\r\]*\r\[^\r\]*New value = 1\r" $match] {
+	  set args_1 1; set test_flag_0 1
+	}
+	# FIXME: Test also for the trailing: \[^\r\]*thread_function \\\(arg=0x0\\\) at .*?watchthreads.c:$inc_line\r
+	if [regexp "Hardware watchpoint 2: args\\\[0\\\]\[^\r\]*\r\[^\r\]*\r\[^\r\]*Old value = $args_0\[^\r\]*\r\[^\r\]*New value = [expr $args_0+1]\r" $match] {
+	  set args_0 [expr $args_0+1]; set test_flag_0 1
+	}
+	# FIXME: Test also for the trailing: \[^\r\]*thread_function \\\(arg=0x0\\\) at .*?watchthreads.c:$inc_line\r
+	if [regexp "Hardware watchpoint 3: args\\\[1\\\]\[^\r\]*\r\[^\r\]*\r\[^\r\]*Old value = $args_1\[^\r\]*\r\[^\r\]*New value = [expr $args_1+1]\r" $match] {
+	  set args_1 [expr $args_1+1]; set test_flag_0 1
+	}
+      }
+    }
   }
   # If we fail above, don't bother continuing loop
-  if { $test_flag == 0 } {
+  if { $test_flag_0 == 0 || $test_flag_1 == 0 } {
     set i 30;
   }
 }
 
 # Print success message if loop succeeded.
-if { $test_flag == 1 } {
+if { $test_flag_0 == 1 && $test_flag_1 == 1 } {
   pass "threaded watch loop"
 }
 
