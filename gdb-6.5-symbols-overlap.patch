2006-10-30  Jan Kratochvil  <jan.kratochvil@redhat.com>

	* gdb/minsyms.c (lookup_minimal_symbol_by_pc_section): Handle
	overlapping non-zero sized functions (for glibc `__nanosleep').

2006-10-30  Jan Kratochvil  <jan.kratochvil@redhat.com>

	* gdb.arch/i386-size-overlap.c, gdb.arch/i386-size-overlap.exp: New
	file, provide nested (overlapping) functions for the PC resolving.


--- gdb-6.5/gdb/minsyms.c-orig	2006-10-31 08:21:32.000000000 -0500
+++ gdb-6.5/gdb/minsyms.c	2006-10-31 08:24:37.000000000 -0500
@@ -464,6 +464,7 @@
 	         objfile's minimal symbol table.  See if it is the best one
 	         overall. */
 
+	      while (0
 	      /* Skip any absolute symbols.  This is apparently what adb
 	         and dbx do, and is needed for the CM-5.  There are two
 	         known possible problems: (1) on ELF, apparently end, edata,
@@ -473,8 +474,27 @@
 	         NeXT are absolute.  If we want special handling for this
 	         it probably should be triggered by a special
 	         mst_abs_or_lib or some such.  */
-	      while (hi >= 0
-		     && msymbol[hi].type == mst_abs)
+		     || (hi >= 0
+			 && msymbol[hi].type == mst_abs)
+		  /* We are behind the current symbol's size.
+		     Try the previous symbol - if it is non-zero sized one it
+		     may overlap the current one and reach our PC.
+		     It occurs for GNU/Linux glibc `__nanosleep' overlapping
+		     later `__nanosleep_nocancel' with PC at 0077ec66:
+   Num:    Value  Size Type    Bind   Vis      Ndx Name
+  7247: 0077ec20   124 FUNC    WEAK   DEFAULT   11 __nanosleep
+  4651: 0077ec2a    32 FUNC    LOCAL  DEFAULT   11 __nanosleep_nocancel
+		     Test `gdb.arch/i386-size' + `gdb.arch/i386-unwind'.
+		     Limit it only for the overlapping cases as we could harm
+		     the zero-sized symbols detection logic around.
+		     */
+		     || (hi > 0
+			 && MSYMBOL_SIZE (&msymbol[hi]) != 0
+			 && pc >= (SYMBOL_VALUE_ADDRESS (&msymbol[hi])
+				   + MSYMBOL_SIZE (&msymbol[hi]))
+			 && pc < (SYMBOL_VALUE_ADDRESS (&msymbol[hi - 1])
+				  + MSYMBOL_SIZE (&msymbol[hi - 1])))
+		     )
 		--hi;
 
 	      /* If "section" specified, skip any symbol from wrong section */
Index: ./gdb/testsuite/gdb.arch/i386-size-overlap.c
===================================================================
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ ./gdb/testsuite/gdb.arch/i386-size-overlap.c	30 Oct 2006 12:41:35 -0000
@@ -0,0 +1,53 @@
+/* Overlapping symbol sizes test program.
+
+   Copyright 2006 Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifdef SYMBOL_PREFIX
+#define SYMBOL(str)	SYMBOL_PREFIX #str
+#else
+#define SYMBOL(str)	#str
+#endif
+
+void
+trap (void)
+{
+  asm ("int $0x03");
+}
+
+/* Jump from a function with its symbol size set, to a function
+   named by a local label.  GDB should report the `main' function
+   even for the rest, after the global `inner' ends.  */
+
+asm(".text\n"
+    "    .align 8\n"
+    "    .globl " SYMBOL (main) "\n"
+    SYMBOL (main) ":\n"
+    "    pushl %ebp\n"
+    "    mov   %esp, %ebp\n"
+    "    call  .Lfunc\n"
+    "    ret\n"
+    SYMBOL (inner) ":\n"
+    "    ret\n"
+    "    .size " SYMBOL (inner) ", .-" SYMBOL (inner) "\n"
+    ".Lfunc:\n"
+    "    pushl %ebp\n"
+    "    mov   %esp, %ebp\n"
+    "    call  " SYMBOL (trap) "\n"
+    "    .size " SYMBOL (main) ", .-" SYMBOL (main) "\n");
Index: ./gdb/testsuite/gdb.arch/i386-size-overlap.exp
===================================================================
RCS file: gdb/testsuite/gdb.arch/i386-size-overlap.exp
diff -N gdb/testsuite/gdb.arch/i386-size-overlap.exp
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ ./gdb/testsuite/gdb.arch/i386-size-overlap.exp	30 Oct 2006 12:41:35 -0000
@@ -0,0 +1,79 @@
+# Copyright 2006 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
+
+# Please email any bugs, comments, and/or additions to this file to:
+# bug-gdb@gnu.org
+
+# This file is part of the gdb testsuite.
+
+if $tracelevel {
+    strace $tracelevel
+}
+
+# Test that GDB can handle overlapping sizes of symbols.
+
+if ![istarget "i?86-*-*"] then {
+    verbose "Skipping i386 unwinder tests."
+    return
+}
+
+set testfile "i386-size-overlap"
+set srcfile ${testfile}.c
+set binfile ${objdir}/${subdir}/${testfile}
+
+# some targets have leading underscores on assembly symbols.
+# TODO: detect this automatically
+set additional_flags ""
+if [istarget "i?86-*-cygwin*"] then {
+  set additional_flags "additional_flags=-DSYMBOL_PREFIX=\"_\""
+}
+
+if { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" \
+	  executable [list debug $additional_flags]] != "" } {
+    untested "i386-size"
+    return -1
+}
+
+gdb_exit
+gdb_start
+gdb_reinitialize_dir $srcdir/$subdir
+gdb_load ${binfile}
+
+# We use gdb_run_cmd so this stands a chance to work for remote
+# targets too.
+gdb_run_cmd
+
+gdb_expect {
+    -re "Program received signal SIGTRAP.*$gdb_prompt $" {
+	pass "run past main"
+    }
+    -re ".*$gdb_prompt $" {
+	fail "run past main"
+    }
+    timeout {
+	fail "run past main (timeout)"
+    }
+}
+
+set message "backtrace shows the outer function"
+gdb_test_multiple "backtrace 10" $message {
+    -re "#1\[ \t]*$hex in inner.*$gdb_prompt $" {
+	fail $message
+    }
+    -re "#1\[ \t]*$hex in main.*$gdb_prompt $" {
+	pass $message
+    }
+}
