Index: objfiles.c
===================================================================
RCS file: /cvs/src/src/gdb/objfiles.c,v
retrieving revision 1.93
diff -p -u -r1.93 objfiles.c
--- ./gdb/objfiles.c	21 Aug 2009 17:57:17 -0000	1.93
+++ ./gdb/objfiles.c	26 Aug 2009 07:07:04 -0000
@@ -790,15 +790,9 @@ qsort_cmp (const void *a, const void *b)
   const CORE_ADDR sect2_addr = obj_section_addr (sect2);
 
   if (sect1_addr < sect2_addr)
-    {
-      gdb_assert (obj_section_endaddr (sect1) <= sect2_addr);
-      return -1;
-    }
+    return -1;
   else if (sect1_addr > sect2_addr)
-    {
-      gdb_assert (sect1_addr >= obj_section_endaddr (sect2));
-      return 1;
-    }
+    return 1;
 
   return 0;
 }
@@ -823,12 +817,133 @@ preferred_obj_section (struct obj_sectio
   return b;
 }
 
+/* Return 1 if SECTION should be inserted into the section map.
+   We want to insert only non-overlay and non-TLS section.  */
+
+static int
+insert_section_p (const struct bfd *abfd,
+		  const struct bfd_section *section)
+{
+  const bfd_vma lma = bfd_section_lma (abfd, section);
+
+  if (lma != 0 && lma != bfd_section_vma (abfd, section)
+      && (bfd_get_file_flags (abfd) & BFD_IN_MEMORY) == 0)
+    /* This is an overlay section.  IN_MEMORY check is needed to avoid
+       discarding sections from the "system supplied DSO" (aka vdso)
+       on Linux.  */
+    return 0;
+  if ((bfd_get_section_flags (abfd, section) & SEC_THREAD_LOCAL) != 0)
+    /* This is a TLS section.  */
+    return 0;
+
+  return 1;
+}
+
+/* Filter out overlapping sections where one section came from the real
+   objfile, and the other from a separate debuginfo file.
+   Return the size of table after redundant sections have been eliminated.  */
+
+static int
+filter_debuginfo_sections (struct obj_section **map, int map_size)
+{
+  int i, j;
+
+  for (i = 0, j = 0; i < map_size - 1; i++)
+    {
+      struct obj_section *const sect1 = map[i];
+      struct obj_section *const sect2 = map[i + 1];
+      const struct objfile *const objfile1 = sect1->objfile;
+      const struct objfile *const objfile2 = sect2->objfile;
+      const CORE_ADDR sect1_addr = obj_section_addr (sect1);
+      const CORE_ADDR sect2_addr = obj_section_addr (sect2);
+
+      if (sect1_addr == sect2_addr
+	  && (objfile1->separate_debug_objfile == objfile2
+	      || objfile2->separate_debug_objfile == objfile1))
+	{
+	  map[j++] = preferred_obj_section (sect1, sect2);
+	  ++i;
+	}
+      else
+	map[j++] = sect1;
+    }
+
+  if (i < map_size)
+    map[j++] = map[i];
+
+  /* The map should not have shrunk to less than half the original size.  */
+  gdb_assert (map_size / 2 <= j);
+
+  return j;
+}
+
+/* Filter out overlapping sections, issuing a warning if any are found.
+   Overlapping sections could really be overlay sections which we didn't
+   classify as such in insert_section_p, or we could be dealing with a
+   corrupt binary.  */
+
+static int
+filter_overlapping_sections (struct obj_section **map, int map_size)
+{
+  int i, j;
+
+  for (i = 0, j = 0; i < map_size - 1; )
+    {
+      int k;
+
+      map[j++] = map[i];
+      for (k = i + 1; k < map_size; k++)
+	{
+	  struct obj_section *const sect1 = map[i];
+	  struct obj_section *const sect2 = map[k];
+	  const CORE_ADDR sect1_addr = obj_section_addr (sect1);
+	  const CORE_ADDR sect2_addr = obj_section_addr (sect2);
+	  const CORE_ADDR sect1_endaddr = obj_section_endaddr (sect1);
+
+	  gdb_assert (sect1_addr <= sect2_addr);
+
+	  if (sect1_endaddr <= sect2_addr)
+	    break;
+	  else
+	    {
+	      /* We have an overlap.  Report it.  */
+
+	      struct objfile *const objf1 = sect1->objfile;
+	      struct objfile *const objf2 = sect2->objfile;
+
+	      const struct bfd *const abfd1 = objf1->obfd;
+	      const struct bfd *const abfd2 = objf2->obfd;
+
+	      const struct bfd_section *const bfds1 = sect1->the_bfd_section;
+	      const struct bfd_section *const bfds2 = sect2->the_bfd_section;
+
+	      const CORE_ADDR sect2_endaddr = obj_section_endaddr (sect2);
+
+	      struct gdbarch *const gdbarch = get_objfile_arch (objf1);
+
+	      warning (_("Unexpected overlap between "
+			 "section `%s' from `%s' [%s, %s) and "
+			 "section `%s' from `%s' [%s, %s)"),
+		       bfd_section_name (abfd1, bfds1), objf1->name,
+		       paddress (gdbarch, sect1_addr),
+		       paddress (gdbarch, sect1_endaddr),
+		       bfd_section_name (abfd2, bfds2), objf2->name,
+		       paddress (gdbarch, sect2_addr),
+		       paddress (gdbarch, sect2_endaddr));
+	    }
+	}
+      i = k;
+    }
+  return map_size;
+}
+
+
 /* Update PMAP, PMAP_SIZE with non-TLS sections from all objfiles.  */
 
 static void
 update_section_map (struct obj_section ***pmap, int *pmap_size)
 {
-  int map_size, i, j;
+  int alloc_size, map_size, i;
   struct obj_section *s, **map;
   struct objfile *objfile;
 
@@ -837,55 +952,27 @@ update_section_map (struct obj_section *
   map = *pmap;
   xfree (map);
 
-#define insert_p(objf, sec) \
-  ((bfd_get_section_flags ((objf)->obfd, (sec)->the_bfd_section) \
-    & SEC_THREAD_LOCAL) == 0)
-
-  map_size = 0;
+  alloc_size = 0;
   ALL_OBJSECTIONS (objfile, s)
-    if (insert_p (objfile, s))
-      map_size += 1;
+    if (insert_section_p (objfile->obfd, s->the_bfd_section))
+      alloc_size += 1;
 
-  map = xmalloc (map_size * sizeof (*map));
+  map = xmalloc (alloc_size * sizeof (*map));
 
   i = 0;
   ALL_OBJSECTIONS (objfile, s)
-    if (insert_p (objfile, s))
+    if (insert_section_p (objfile->obfd, s->the_bfd_section))
       map[i++] = s;
 
-#undef insert_p
-
-  qsort (map, map_size, sizeof (*map), qsort_cmp);
-
-  /* With separate debuginfo files, we may have up to two (almost)
-     identical copies of some obj_sections in the map.
-     Filter out duplicates.  */
-  for (i = 0, j = 0; i < map_size; ++i)
-    {
-      struct obj_section *sect1 = map[i];
-      struct obj_section *sect2 = (i + 1 < map_size) ? map[i + 1] : NULL;
-
-      if (sect2 == NULL
-	  || obj_section_addr (sect1) != obj_section_addr (sect2))
-	map[j++] = sect1;
-      else
-	{
-	  map[j++] = preferred_obj_section (sect1, sect2);
-	  ++i;
-	}
-    }
-
-  if (j < map_size)
-    {
-      /* Some duplicates were eliminated.
-	 The new size shouldn't be less than half of the original. */
-      gdb_assert (map_size / 2 <= j);
-      map_size = j;
-
-      map = xrealloc (map, map_size * sizeof (*map));  /* Trim excess space.  */
-    }
+  qsort (map, alloc_size, sizeof (*map), qsort_cmp);
+  map_size = filter_debuginfo_sections(map, alloc_size);
+  map_size = filter_overlapping_sections(map, map_size);
+
+  if (map_size < alloc_size)
+    /* Some sections were eliminated.  Trim excess space.  */
+    map = xrealloc (map, map_size * sizeof (*map));
   else
-    gdb_assert (j == map_size);
+    gdb_assert (alloc_size == map_size);
 
   *pmap = map;
   *pmap_size = map_size;

2009-08-25  Jan Kratochvil  <jan.kratochvil@redhat.com>

	* gdb.base/solib-overlap.exp, gdb.base/solib-overlap-lib.c,
	gdb.base/solib-overlap-main.c: New.

--- /dev/null
+++ b/gdb/testsuite/gdb.base/solib-overlap-lib.c
@@ -0,0 +1,27 @@
+/* Copyright 2009 Free Software Foundation, Inc.
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+   Contributed by Jan Kratochvil <jan.kratochvil@redhat.com>.  */
+
+void
+libsym (void)
+{
+}
+
+#ifdef SYMB
+void
+libsymb (void)
+{
+}
+#endif
--- /dev/null
+++ b/gdb/testsuite/gdb.base/solib-overlap-main.c
@@ -0,0 +1,25 @@
+/* Copyright 2009 Free Software Foundation, Inc.
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+   Contributed by Jan Kratochvil <jan.kratochvil@redhat.com>.  */
+
+#include <unistd.h>
+
+int
+main (void)
+{
+  sleep (60);
+
+  return 1;
+}
--- /dev/null
+++ b/gdb/testsuite/gdb.base/solib-overlap.exp
@@ -0,0 +1,135 @@
+# Copyright 2009 Free Software Foundation, Inc.
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+#
+# Contributed by Jan Kratochvil <jan.kratochvil@redhat.com>.
+
+# Test GDB can cope with two libraries loaded with overlapping VMA ranges.
+# Prelink libraries first so they can be loaded and their native address.
+# In such case `struct linkmap'.l_addr will be zero.  Provide different
+# unprelinked library files on the disk which have zero-based VMAs.  These
+# different files should have their .dynamic section at a different offset in
+# page size so that we get for
+#   warning: .dynamic section for "..." is not at the expected address
+# the reason
+#   (wrong library or version mismatch?)
+# and not:
+#   difference appears to be caused by prelink, adjusting expectations
+# In such case both disk libraries will be loaded at VMAs starting at zero.
+
+if [skip_shlib_tests] {
+    return 0
+}
+
+# Are we on a target board?  It is required for attaching to a process.
+if [is_remote target] {
+    return 0
+}
+
+# Library file.
+set libname "solib-overlap-lib"
+set srcfile_lib ${srcdir}/${subdir}/${libname}.c
+# Binary file.
+set testfile "solib-overlap-main"
+set srcfile ${srcdir}/${subdir}/${testfile}.c
+
+# Base addresses for `prelink -r' which should be compatible with both -m32 and
+# -m64 targets.  If it clashes with system prelinked libraries it would give
+# false PASS.
+# Prelink first lib1 at 0x40000000 and lib2 at 0x41000000.
+# During second pass try lib1 at 0x50000000 and lib2 at 0x51000000.
+foreach prelink_lib1 {0x40000000 0x50000000} {
+    set prelink_lib2 [format "0x%x" [expr $prelink_lib1 + 0x01000000]]
+
+    set old_prefix $pf_prefix
+    lappend pf_prefix "$prelink_lib1:"
+
+    # Library file.
+    set binfile_lib1 ${objdir}/${subdir}/${libname}1-${prelink_lib1}.so
+    set binfile_lib2 ${objdir}/${subdir}/${libname}2-${prelink_lib1}.so
+    set lib_flags {debug}
+    # Binary file.
+    set binfile_base ${testfile}-${prelink_lib1}
+    set binfile ${objdir}/${subdir}/${binfile_base}
+    set bin_flags [list debug shlib=${binfile_lib1} shlib=${binfile_lib2}]
+    set escapedbinfile  [string_to_regexp ${binfile}]
+
+    if { [gdb_compile_shlib ${srcfile_lib} ${binfile_lib1} $lib_flags] != ""
+	 || [gdb_compile_shlib ${srcfile_lib} ${binfile_lib2} $lib_flags] != ""
+	 || [gdb_compile ${srcfile} ${binfile} executable $bin_flags] != "" } {
+	untested "Could not compile ${binfile_lib1}, ${binfile_lib2} or ${binfile}."
+	return -1
+    }
+
+    if {[catch "system \"prelink -N -r ${prelink_lib1} ${binfile_lib1}\""] != 0
+	|| [catch "system \"prelink -N -r ${prelink_lib2} ${binfile_lib2}\""] != 0} {
+	# Maybe we don't have prelink.
+	untested "Could not prelink ${binfile_lib1} or ${binfile_lib2}."
+	return -1
+    }
+
+    # Start the program running and then wait for a bit, to be sure
+    # that it can be attached to.
+
+    set testpid [eval exec $binfile &]
+    sleep 2
+    if { [istarget "*-*-cygwin*"] } {
+	# testpid is the Cygwin PID, GDB uses the Windows PID, which might be
+	# different due to the way fork/exec works.
+	set testpid [ exec ps -e | gawk "{ if (\$1 == $testpid) print \$4; }" ]
+    }
+
+    remote_exec build "mv -f ${binfile_lib1} ${binfile_lib1}-running"
+    remote_exec build "mv -f ${binfile_lib2} ${binfile_lib2}-running"
+
+    # Provide another exported function name to cause different sizes of sections.
+    lappend lib_flags additional_flags=-DSYMB
+
+    if { [gdb_compile_shlib ${srcfile_lib} ${binfile_lib1} $lib_flags] != ""
+	 || [gdb_compile_shlib ${srcfile_lib} ${binfile_lib2} $lib_flags] != ""} {
+	untested "Could not recompile ${binfile_lib1} or ${binfile_lib2}."
+	remote_exec build "kill -9 ${testpid}"
+	return -1
+    }
+
+    clean_restart ${binfile_base}
+    # This testcase currently does not support remote targets.
+    # gdb_load_shlibs ${binfile_lib1} ${binfile_lib2}
+
+    # Here we should get:
+    # warning: .dynamic section for ".../solib-overlap-lib1.so" is not at the expected address (wrong library or version mismatch?)
+    # warning: .dynamic section for ".../solib-overlap-lib2.so" is not at the expected address (wrong library or version mismatch?)
+
+    set test attach
+    gdb_test_multiple "attach $testpid" $test {
+	-re "Attaching to program.*`?$escapedbinfile'?, process $testpid.*$gdb_prompt $" {
+	    pass $test
+	}
+	-re "Attaching to program.*`?$escapedbinfile\.exe'?, process $testpid.*\[Switching to thread $testpid\..*\].*$gdb_prompt $" {
+	    # Response expected on Cygwin
+	    pass $test
+	}
+    }
+
+    # Detach the process.
+
+    gdb_test "detach" "Detaching from program: .*$escapedbinfile, process $testpid"
+
+    # Wait a bit for gdb to finish detaching
+
+    sleep 5
+
+    remote_exec build "kill -9 ${testpid}"
+
+    set pf_prefix $old_prefix
+}
