gdb/testsuite/gdb.base/fileio.c:
gdb/testsuite/gdb.base/fileio.exp:
2007-12-08  Jan Kratochvil  <jan.kratochvil@redhat.com>

	* gdb.base/fileio.c (ROOTSUBDIR): New macro.
	(main): CHDIR into ROOTSUBDIR.  CHOWN ROOTSUBDIR and CHDIR into
	ROOTSUBDIR if we are being run as root.
	* gdb.base/fileio.exp: Change the startup and finish cleanup.
	Change the test file reference to be into the `fileio.dir' directory.


sources/gdb/testsuite/gdb.base/dump.exp:
Found on RHEL-5.s390x.


gdb-6.8.50.20090209/gdb/testsuite/gdb.base/auxv.exp:
random FAIL: gdb.base/auxv.exp: matching auxv data from live and gcore


gdb-6.8.50.20090209/gdb/testsuite/gdb.base/annota1.exp:
frames-invalid can happen asynchronously.

--- ./gdb/testsuite/gdb.base/fileio.c	13 Jun 2006 08:55:22 -0000	1.10
+++ ./gdb/testsuite/gdb.base/fileio.c	8 Dec 2007 16:04:10 -0000
@@ -58,6 +58,8 @@ system (const char * string);
 1) Invalid string/command. -  returns 127.  */
 static const char *strerrno (int err);
 
+#define ROOTSUBDIR "fileio.dir"
+
 #define FILENAME    "foo.fileio.test"
 #define RENAMED     "bar.fileio.test"
 #define NONEXISTANT "nofoo.fileio.test"
@@ -542,6 +544,37 @@ strerrno (int err)
 int
 main ()
 {
+  /* ROOTSUBDIR is already prepared by fileio.exp.  We use it for easy cleanup
+     (by fileio.exp) if we are run by multiple users in the same directory.  */
+
+  if (chdir (ROOTSUBDIR) != 0)
+    {
+      printf ("chdir " ROOTSUBDIR ": %s\n", strerror (errno));
+      exit (1);
+    }
+
+  /* These tests
+       Open for write but no write permission returns EACCES
+       Unlinking a file in a directory w/o write access returns EACCES
+     fail if we are being run as root - drop the privileges here.  */
+
+  if (geteuid () == 0)
+    {
+      uid_t uid = 99;
+
+      if (chown (".", uid, uid) != 0)
+	{
+	  printf ("chown %d.%d " ROOTSUBDIR ": %s\n", (int) uid, (int) uid,
+		  strerror (errno));
+	  exit (1);
+	}
+      if (setuid (uid) || geteuid () == 0)
+	{
+	  printf ("setuid %d: %s\n", (int) uid, strerror (errno));
+	  exit (1);
+	}
+    }
+
   /* Don't change the order of the calls.  They partly depend on each other */
   test_open ();
   test_write ();
--- ./gdb/testsuite/gdb.base/fileio.exp	23 Aug 2007 18:14:16 -0000	1.12
+++ ./gdb/testsuite/gdb.base/fileio.exp	8 Dec 2007 16:04:10 -0000
@@ -46,8 +46,8 @@ if [get_compiler_info ${binfile}] {
     return -1;
 }
 
-remote_exec build {sh -xc test\ -r\ dir2.fileio.test\ &&\ chmod\ -f\ +w\ dir2.fileio.test}
-remote_exec build {sh -xc rm\ -rf\ *.fileio.test}
+remote_exec build {sh -xc rm\ -rf\ fileio.dir}
+remote_exec build {sh -xc mkdir\ -m777\ fileio.dir}
 
 set oldtimeout $timeout
 set timeout [expr "$timeout + 60"]
@@ -88,7 +88,7 @@ gdb_test continue \
 "Opening nonexistant file returns ENOENT"
 
 send_gdb "continue\n" ; gdb_expect -re "$gdb_prompt $"
-catch "system \"chmod -f -w nowrt.fileio.test\""
+catch "system \"chmod -f -w fileio.dir/nowrt.fileio.test\""
 
 gdb_test continue \
 "Continuing\\..*open 5:.*EACCES$stop_msg" \
@@ -252,8 +252,8 @@ gdb_test continue \
 send_gdb "quit\n"
 send_gdb "y\n"
 
-remote_exec build {sh -xc test\ -r\ dir2.fileio.test\ &&\ chmod\ -f\ +w\ dir2.fileio.test}
-remote_exec build {sh -xc rm\ -rf\ *.fileio.test}
+remote_exec build {sh -xc test\ -r\ fileio.dir/dir2.fileio.test\ &&\ chmod\ -f\ +w\ fileio.dir/dir2.fileio.test}
+remote_exec build {sh -xc rm\ -rf\ fileio.dir}
 
 set timeout $oldtimeout
 return 0



http://sourceware.org/ml/gdb-patches/2009-12/msg00234.html
Subject: [patch] testsuite: Fix a race by me - watchthreads-reorder.exp

Hi,

there is a bug explainable by man pthread_cond_signal:
	The [...] pthread_cond_signal() functions shall have no effect if
	there are no threads currently blocked on cond.

meaning a race for the testcase.
	+FAIL: gdb.threads/watchthreads-reorder.exp: reorder1: continue a (timeout)

One can reproduce the race on CVS HEAD by:
#	--- a/gdb/testsuite/gdb.threads/watchthreads-reorder.c
#	+++ b/gdb/testsuite/gdb.threads/watchthreads-reorder.c
#	@@ -89,6 +89,7 @@ thread1_func (void *unused)
#	   int i;
#	   volatile int rwatch_store;
#	 
#	+sleep(1);
#	   thread1_tid = gettid ();
#	   i = pthread_cond_signal (&thread1_tid_cond);
#	   assert (i == 0);
#	@@ -317,6 +318,7 @@ main (int argc, char **argv)
#	 
#	   if (thread1_tid == 0)
#	     {
#	+sleep(2);
#	       i = pthread_cond_wait (&thread1_tid_cond, &thread1_tid_mutex);
#	       assert (i == 0);
#	 

Fixed; gdbstop_mutex got removed as it became redundant there.

Going to check it in as obvious in several days (code is by me + it is just
a testcase).


Sorry,
Jan


gdb/testsuite/
2009-12-17  Jan Kratochvil  <jan.kratochvil@redhat.com>

	* gdb.threads/watchthreads-reorder.c (gdbstop_mutex): Remove.
	(thread1_func): Protect thread1_tid_cond by thread1_tid_mutex.  Remove
	gdbstop_mutex handling.
	(thread2_func): Protect thread2_tid_cond by thread2_tid_mutex.  Remove
	gdbstop_mutex handling.
	(main): Move thread1_tid_mutex and thread2_tid_mutex locks before
	pthread_create.  Remove gdbstop_mutex handling.  New comment.  Remove
	pthread_cond_wait conditionalizations.

--- a/gdb/testsuite/gdb.threads/watchthreads-reorder.c
+++ b/gdb/testsuite/gdb.threads/watchthreads-reorder.c
@@ -34,8 +34,6 @@
    otherwise.  */
 #define TIMEOUT (gettid () == getpid() ? 10 : 15)
 
-static pthread_mutex_t gdbstop_mutex = PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP;
-
 static pid_t thread1_tid;
 static pthread_cond_t thread1_tid_cond = PTHREAD_COND_INITIALIZER;
 static pthread_mutex_t thread1_tid_mutex = PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP;
@@ -90,12 +88,11 @@ thread1_func (void *unused)
   volatile int rwatch_store;
 
   thread1_tid = gettid ();
+
+  timed_mutex_lock (&thread1_tid_mutex);
   i = pthread_cond_signal (&thread1_tid_cond);
   assert (i == 0);
-
-  /* Be sure GDB is already stopped before continuing.  */
-  timed_mutex_lock (&gdbstop_mutex);
-  i = pthread_mutex_unlock (&gdbstop_mutex);
+  i = pthread_mutex_unlock (&thread1_tid_mutex);
   assert (i == 0);
 
   rwatch_store = thread1_rwatch;
@@ -115,12 +112,11 @@ thread2_func (void *unused)
   volatile int rwatch_store;
 
   thread2_tid = gettid ();
+
+  timed_mutex_lock (&thread2_tid_mutex);
   i = pthread_cond_signal (&thread2_tid_cond);
   assert (i == 0);
-
-  /* Be sure GDB is already stopped before continuing.  */
-  timed_mutex_lock (&gdbstop_mutex);
-  i = pthread_mutex_unlock (&gdbstop_mutex);
+  i = pthread_mutex_unlock (&thread2_tid_mutex);
   assert (i == 0);
 
   rwatch_store = thread2_rwatch;
@@ -267,7 +263,8 @@ main (int argc, char **argv)
 
   setbuf (stdout, NULL);
 
-  timed_mutex_lock (&gdbstop_mutex);
+  timed_mutex_lock (&thread1_tid_mutex);
+  timed_mutex_lock (&thread2_tid_mutex);
 
   timed_mutex_lock (&terminate_mutex);
 
@@ -306,30 +303,21 @@ main (int argc, char **argv)
       state_wait (tracer, "T (stopped)");
     }
 
-  timed_mutex_lock (&thread1_tid_mutex);
-  timed_mutex_lock (&thread2_tid_mutex);
-
-  /* Let the threads start.  */
-  i = pthread_mutex_unlock (&gdbstop_mutex);
-  assert (i == 0);
+  /* Threads are now waiting at timed_mutex_lock (thread1_tid_mutex) and so
+     they could not trigger the watchpoints before GDB gets unstopped later.
+     Threads get resumed at pthread_cond_wait below.  */
 
   printf ("Waiting till the threads initialize their TIDs.\n");
 
-  if (thread1_tid == 0)
-    {
-      i = pthread_cond_wait (&thread1_tid_cond, &thread1_tid_mutex);
-      assert (i == 0);
+  i = pthread_cond_wait (&thread1_tid_cond, &thread1_tid_mutex);
+  assert (i == 0);
 
-      assert (thread1_tid > 0);
-    }
+  assert (thread1_tid > 0);
 
-  if (thread2_tid == 0)
-    {
-      i = pthread_cond_wait (&thread2_tid_cond, &thread2_tid_mutex);
-      assert (i == 0);
+  i = pthread_cond_wait (&thread2_tid_cond, &thread2_tid_mutex);
+  assert (i == 0);
 
-      assert (thread2_tid > 0);
-    }
+  assert (thread2_tid > 0);
 
   printf ("Thread 1 TID = %lu, thread 2 TID = %lu, PID = %lu.\n",
 	  (unsigned long) thread1_tid, (unsigned long) thread2_tid,

