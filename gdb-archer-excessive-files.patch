Remove some files accidentally created (and not used) by gdb-archer.patch.

diff -up -ruNp gdb-7.0.1-orig/gdb/config/i386/nm-i386.h gdb-7.0.1/gdb/config/i386/nm-i386.h
--- gdb-7.0.1-orig/gdb/config/i386/nm-i386.h	2010-02-09 11:22:39.000000000 +0100
+++ gdb-7.0.1/gdb/config/i386/nm-i386.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,125 +0,0 @@
-/* Native macro definitions for GDB on an Intel i[3456]86.
-   Copyright 2001, 2004, 2007, 2008, 2009 Free Software Foundation, Inc.
-
-   This file is part of GDB.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#ifndef NM_I386_H
-#define NM_I386_H 1
-
-/* Hardware-assisted breakpoints and watchpoints.  */
-
-/* Targets should define this to use the generic x86 watchpoint support.  */
-#ifdef I386_USE_GENERIC_WATCHPOINTS
-
-/* Add watchpoint methods to the provided target_ops.  Targets which call
-   this should also define I386_WATCHPOINTS_IN_TARGET_VECTOR.  */
-struct target_ops;
-void i386_use_watchpoints (struct target_ops *);
-
-/* Clear the reference counts and forget everything we knew about DRi.  */
-extern void i386_cleanup_dregs (void);
-
-/* Insert a watchpoint to watch a memory region which starts at
-   address ADDR and whose length is LEN bytes.  Watch memory accesses
-   of the type TYPE.  Return 0 on success, -1 on failure.  */
-extern int i386_insert_watchpoint (CORE_ADDR addr, int len, int type);
-
-/* Remove a watchpoint that watched the memory region which starts at
-   address ADDR, whose length is LEN bytes, and for accesses of the
-   type TYPE.  Return 0 on success, -1 on failure.  */
-extern int i386_remove_watchpoint (CORE_ADDR addr, int len, int type);
-
-/* Return non-zero if we can watch a memory region that starts at
-   address ADDR and whose length is LEN bytes.  */
-extern int i386_region_ok_for_watchpoint (CORE_ADDR addr, int len);
-
-/* Return non-zero if the inferior has some break/watchpoint that
-   triggered.  */
-extern int i386_stopped_by_hwbp (void);
-
-/* If the inferior has some break/watchpoint that triggered, set
-   the address associated with that break/watchpoint and return
-   true.  Otherwise, return false.  */
-extern int i386_stopped_data_address (struct target_ops *, CORE_ADDR *);
-
-/* Insert a hardware-assisted breakpoint at BP_TGT->placed_address.
-   Return 0 on success, EBUSY on failure.  */
-struct bp_target_info;
-extern int i386_insert_hw_breakpoint (struct bp_target_info *bp_tgt);
-
-/* Remove a hardware-assisted breakpoint at BP_TGT->placed_address.
-   Return 0 on success, -1 on failure.  */
-extern int  i386_remove_hw_breakpoint (struct bp_target_info *bp_tgt);
-
-extern int i386_stopped_by_watchpoint (void);
-
-#ifndef I386_WATCHPOINTS_IN_TARGET_VECTOR
-
-/* Returns the number of hardware watchpoints of type TYPE that we can
-   set.  Value is positive if we can set CNT watchpoints, zero if
-   setting watchpoints of type TYPE is not supported, and negative if
-   CNT is more than the maximum number of watchpoints of type TYPE
-   that we can support.  TYPE is one of bp_hardware_watchpoint,
-   bp_read_watchpoint, bp_write_watchpoint, or bp_hardware_breakpoint.
-   CNT is the number of such watchpoints used so far (including this
-   one).  OTHERTYPE is non-zero if other types of watchpoints are
-   currently enabled.
-
-   We always return 1 here because we don't have enough information
-   about possible overlap of addresses that they want to watch.  As an
-   extreme example, consider the case where all the watchpoints watch
-   the same address and the same region length: then we can handle a
-   virtually unlimited number of watchpoints, due to debug register
-   sharing implemented via reference counts in i386-nat.c.  */
-
-#define TARGET_CAN_USE_HARDWARE_WATCHPOINT(type, cnt, ot) 1
-
-/* Returns non-zero if we can use hardware watchpoints to watch a
-   region whose address is ADDR and whose length is LEN.  */
-
-#define TARGET_REGION_OK_FOR_HW_WATCHPOINT(addr, len) \
-  i386_region_ok_for_watchpoint (addr, len)
-
-/* After a watchpoint trap, the PC points to the instruction after the
-   one that caused the trap.  Therefore we don't need to step over it.
-   But we do need to reset the status register to avoid another trap.  */
-
-#define HAVE_CONTINUABLE_WATCHPOINT 1
-
-#define STOPPED_BY_WATCHPOINT(W)       (i386_stopped_by_watchpoint () != 0)
-
-#define target_stopped_data_address(target, x) \
-  i386_stopped_data_address(target, x)
-
-/* Use these macros for watchpoint insertion/removal.  */
-
-#define target_insert_watchpoint(addr, len, type) \
-  i386_insert_watchpoint (addr, len, type)
-
-#define target_remove_watchpoint(addr, len, type) \
-  i386_remove_watchpoint (addr, len, type)
-
-#define target_insert_hw_breakpoint(bp_tgt) \
-  i386_insert_hw_breakpoint (bp_tgt)
-
-#define target_remove_hw_breakpoint(bp_tgt) \
-  i386_remove_hw_breakpoint (bp_tgt)
-
-#endif /* I386_WATCHPOINTS_IN_TARGET_VECTOR */
-
-#endif /* I386_USE_GENERIC_WATCHPOINTS */
-
-#endif /* NM_I386_H */
diff -up -ruNp gdb-7.0.1-orig/gdb/config/i386/nm-linux64.h gdb-7.0.1/gdb/config/i386/nm-linux64.h
--- gdb-7.0.1-orig/gdb/config/i386/nm-linux64.h	2010-02-09 11:22:39.000000000 +0100
+++ gdb-7.0.1/gdb/config/i386/nm-linux64.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,54 +0,0 @@
-/* Native support for GNU/Linux x86-64.
-
-   Copyright 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009
-   Free Software Foundation, Inc.
-
-   Contributed by Jiri Smid, SuSE Labs.
-
-   This file is part of GDB.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#ifndef NM_LINUX64_H
-#define NM_LINUX64_H
-
-/* GNU/Linux supports the i386 hardware debugging registers.  */
-#define I386_USE_GENERIC_WATCHPOINTS
-#define I386_WATCHPOINTS_IN_TARGET_VECTOR
-
-#include "i386/nm-i386.h"
-#include "config/nm-linux.h"
-
-/* Support for 8-byte wide hardware watchpoints.  */
-#define TARGET_HAS_DR_LEN_8 1
-
-/* Provide access to the i386 hardware debugging registers.  */
-
-extern void amd64_linux_dr_set_control (unsigned long control);
-#define I386_DR_LOW_SET_CONTROL(control) \
-  amd64_linux_dr_set_control (control)
-
-extern void amd64_linux_dr_set_addr (int regnum, CORE_ADDR addr);
-#define I386_DR_LOW_SET_ADDR(regnum, addr) \
-  amd64_linux_dr_set_addr (regnum, addr)
-
-extern void amd64_linux_dr_reset_addr (int regnum);
-#define I386_DR_LOW_RESET_ADDR(regnum) \
-  amd64_linux_dr_reset_addr (regnum)
-
-extern unsigned long amd64_linux_dr_get_status (void);
-#define I386_DR_LOW_GET_STATUS() \
-  amd64_linux_dr_get_status ()
-
-#endif /* nm-linux64.h */
diff -up -ruNp gdb-7.0.1-orig/gdb/config/mips/nm-irix5.h gdb-7.0.1/gdb/config/mips/nm-irix5.h
--- gdb-7.0.1-orig/gdb/config/mips/nm-irix5.h	2010-02-09 11:22:39.000000000 +0100
+++ gdb-7.0.1/gdb/config/mips/nm-irix5.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,44 +0,0 @@
-/* Definitions for native support of irix5.
-
-   Copyright 1993, 1996, 1998, 1999, 2000, 2007, 2008, 2009
-   Free Software Foundation, Inc.
-
-   This file is part of GDB.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#define TARGET_HAS_HARDWARE_WATCHPOINTS
-
-/* TARGET_CAN_USE_HARDWARE_WATCHPOINT is now defined to go through
-   the target vector.  For Irix5, procfs_can_use_hw_watchpoint()
-   should be invoked.  */
-
-/* When a hardware watchpoint fires off the PC will be left at the
-   instruction which caused the watchpoint.  It will be necessary for
-   GDB to step over the watchpoint. */
-
-#define STOPPED_BY_WATCHPOINT(W) \
-     procfs_stopped_by_watchpoint(inferior_ptid)
-extern int procfs_stopped_by_watchpoint (ptid_t);
-
-/* Use these macros for watchpoint insertion/deletion.  */
-/* type can be 0: write watch, 1: read watch, 2: access watch (read/write) */
-#define target_insert_watchpoint(ADDR, LEN, TYPE) \
-     procfs_set_watchpoint (inferior_ptid, ADDR, LEN, TYPE, 0)
-#define target_remove_watchpoint(ADDR, LEN, TYPE) \
-     procfs_set_watchpoint (inferior_ptid, ADDR, 0, 0, 0)
-extern int procfs_set_watchpoint (ptid_t, CORE_ADDR, int, int, int);
-
-#define TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT(SIZE) 1
-
diff -up -ruNp gdb-7.0.1-orig/gdb/gdbserver/linux-i386-low.c gdb-7.0.1/gdb/gdbserver/linux-i386-low.c
--- gdb-7.0.1-orig/gdb/gdbserver/linux-i386-low.c	2010-02-09 11:22:39.000000000 +0100
+++ gdb-7.0.1/gdb/gdbserver/linux-i386-low.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,210 +0,0 @@
-/* GNU/Linux/i386 specific low level interface, for the remote server for GDB.
-   Copyright (C) 1995, 1996, 1998, 1999, 2000, 2001, 2002, 2004, 2005, 2006,
-   2007, 2008, 2009 Free Software Foundation, Inc.
-
-   This file is part of GDB.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "server.h"
-#include "linux-low.h"
-#include "i387-fp.h"
-
-#include "gdb_proc_service.h"
-
-#include <sys/ptrace.h>
-
-#ifdef HAVE_SYS_REG_H
-#include <sys/reg.h>
-#endif
-
-#ifndef PTRACE_GET_THREAD_AREA
-#define PTRACE_GET_THREAD_AREA 25
-#endif
-
-/* Defined in auto-generated file reg-i386-linux.c.  */
-void init_registers_i386_linux (void);
-
-
-/* This module only supports access to the general purpose registers.  */
-
-#define i386_num_regs 16
-
-/* This stuff comes from i386-linux-nat.c.  */
-
-/* Mapping between the general-purpose registers in `struct user'
-   format and GDB's register array layout.  */
-static int i386_regmap[] = 
-{
-  EAX * 4, ECX * 4, EDX * 4, EBX * 4,
-  UESP * 4, EBP * 4, ESI * 4, EDI * 4,
-  EIP * 4, EFL * 4, CS * 4, SS * 4,
-  DS * 4, ES * 4, FS * 4, GS * 4
-};
-
-/* Called by libthread_db.  */
-
-ps_err_e
-ps_get_thread_area (const struct ps_prochandle *ph, 
-		    lwpid_t lwpid, int idx, void **base)
-{
-  unsigned int desc[4];
-
-  if (ptrace (PTRACE_GET_THREAD_AREA, lwpid,
-	      (void *) idx, (unsigned long) &desc) < 0)
-    return PS_ERR;
-
-  *(int *)base = desc[1];
-  return PS_OK;
-}
-
-static int
-i386_cannot_store_register (int regno)
-{
-  return (regno >= i386_num_regs);
-}
-
-static int
-i386_cannot_fetch_register (int regno)
-{
-  return (regno >= i386_num_regs);
-}
-
-
-#ifdef HAVE_PTRACE_GETREGS
-#include <sys/procfs.h>
-#include <sys/ptrace.h>
-
-static void
-i386_fill_gregset (void *buf)
-{
-  int i;
-
-  for (i = 0; i < i386_num_regs; i++)
-    collect_register (i, ((char *) buf) + i386_regmap[i]);
-
-  collect_register_by_name ("orig_eax", ((char *) buf) + ORIG_EAX * 4);
-}
-
-static void
-i386_store_gregset (const void *buf)
-{
-  int i;
-
-  for (i = 0; i < i386_num_regs; i++)
-    supply_register (i, ((char *) buf) + i386_regmap[i]);
-
-  supply_register_by_name ("orig_eax", ((char *) buf) + ORIG_EAX * 4);
-}
-
-static void
-i386_fill_fpregset (void *buf)
-{
-  i387_cache_to_fsave (buf);
-}
-
-static void
-i386_store_fpregset (const void *buf)
-{
-  i387_fsave_to_cache (buf);
-}
-
-static void
-i386_fill_fpxregset (void *buf)
-{
-  i387_cache_to_fxsave (buf);
-}
-
-static void
-i386_store_fpxregset (const void *buf)
-{
-  i387_fxsave_to_cache (buf);
-}
-
-#endif /* HAVE_PTRACE_GETREGS */
-
-struct regset_info target_regsets[] = {
-#ifdef HAVE_PTRACE_GETREGS
-  { PTRACE_GETREGS, PTRACE_SETREGS, sizeof (elf_gregset_t),
-    GENERAL_REGS,
-    i386_fill_gregset, i386_store_gregset },
-# ifdef HAVE_PTRACE_GETFPXREGS
-  { PTRACE_GETFPXREGS, PTRACE_SETFPXREGS, sizeof (elf_fpxregset_t),
-    EXTENDED_REGS,
-    i386_fill_fpxregset, i386_store_fpxregset },
-# endif
-  { PTRACE_GETFPREGS, PTRACE_SETFPREGS, sizeof (elf_fpregset_t),
-    FP_REGS,
-    i386_fill_fpregset, i386_store_fpregset },
-#endif /* HAVE_PTRACE_GETREGS */
-  { 0, 0, -1, -1, NULL, NULL }
-};
-
-static const unsigned char i386_breakpoint[] = { 0xCC };
-#define i386_breakpoint_len 1
-
-extern int debug_threads;
-
-static CORE_ADDR
-i386_get_pc ()
-{
-  unsigned long pc;
-
-  collect_register_by_name ("eip", &pc);
-
-  if (debug_threads)
-    fprintf (stderr, "stop pc (before any decrement) is %08lx\n", pc);
-  return pc;
-}
-
-static void
-i386_set_pc (CORE_ADDR newpc)
-{
-  if (debug_threads)
-    fprintf (stderr, "set pc to %08lx\n", (long) newpc);
-  supply_register_by_name ("eip", &newpc);
-}
-
-static int
-i386_breakpoint_at (CORE_ADDR pc)
-{
-  unsigned char c;
-
-  read_inferior_memory (pc, &c, 1);
-  if (c == 0xCC)
-    return 1;
-
-  return 0;
-}
-
-struct linux_target_ops the_low_target = {
-  init_registers_i386_linux,
-  i386_num_regs,
-  i386_regmap,
-  i386_cannot_fetch_register,
-  i386_cannot_store_register,
-  i386_get_pc,
-  i386_set_pc,
-  i386_breakpoint,
-  i386_breakpoint_len,
-  NULL,
-  1,
-  i386_breakpoint_at,
-  NULL,
-  NULL,
-  NULL,
-  NULL,
-  NULL,
-  NULL,
-};
diff -up -ruNp gdb-7.0.1-orig/gdb/gdbserver/linux-x86-64-low.c gdb-7.0.1/gdb/gdbserver/linux-x86-64-low.c
--- gdb-7.0.1-orig/gdb/gdbserver/linux-x86-64-low.c	2010-02-09 11:22:39.000000000 +0100
+++ gdb-7.0.1/gdb/gdbserver/linux-x86-64-low.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,184 +0,0 @@
-/* GNU/Linux/x86-64 specific low level interface, for the remote server
-   for GDB.
-   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009
-   Free Software Foundation, Inc.
-
-   This file is part of GDB.
-
-   This program is free software; you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation; either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "server.h"
-#include "linux-low.h"
-#include "i387-fp.h"
-
-#include "gdb_proc_service.h"
-
-/* Defined in auto-generated file reg-x86-64-linux.c.  */
-void init_registers_x86_64_linux (void);
-
-#include <sys/reg.h>
-#include <sys/procfs.h>
-#include <sys/ptrace.h>
-
-/* This definition comes from prctl.h, but some kernels may not have it.  */
-#ifndef PTRACE_ARCH_PRCTL
-#define PTRACE_ARCH_PRCTL      30
-#endif
-
-/* The following definitions come from prctl.h, but may be absent
-   for certain configurations.  */
-#ifndef ARCH_GET_FS
-#define ARCH_SET_GS 0x1001
-#define ARCH_SET_FS 0x1002
-#define ARCH_GET_FS 0x1003
-#define ARCH_GET_GS 0x1004
-#endif
-
-static int x86_64_regmap[] = {
-  RAX * 8, RBX * 8, RCX * 8, RDX * 8,
-  RSI * 8, RDI * 8, RBP * 8, RSP * 8,
-  R8 * 8, R9 * 8, R10 * 8, R11 * 8,
-  R12 * 8, R13 * 8, R14 * 8, R15 * 8,
-  RIP * 8, EFLAGS * 8, CS * 8, SS * 8, 
-  DS * 8, ES * 8, FS * 8, GS * 8,
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  -1, -1, -1, -1, -1, -1, -1, -1,
-  -1, -1, -1, -1, -1, -1, -1, -1, -1,
-  ORIG_RAX * 8
-};
-
-#define X86_64_NUM_GREGS (sizeof(x86_64_regmap)/sizeof(int))
-
-/* Called by libthread_db.  */
-
-ps_err_e
-ps_get_thread_area (const struct ps_prochandle *ph,
-                    lwpid_t lwpid, int idx, void **base)
-{
-  switch (idx)
-    {
-    case FS:
-      if (ptrace (PTRACE_ARCH_PRCTL, lwpid, base, ARCH_GET_FS) == 0)
-	return PS_OK;
-      break;
-    case GS:
-      if (ptrace (PTRACE_ARCH_PRCTL, lwpid, base, ARCH_GET_GS) == 0)
-	return PS_OK;
-      break;
-    default:
-      return PS_BADADDR;
-    }
-  return PS_ERR;
-}
-
-static void
-x86_64_fill_gregset (void *buf)
-{
-  int i;
-
-  for (i = 0; i < X86_64_NUM_GREGS; i++)
-    if (x86_64_regmap[i] != -1)
-      collect_register (i, ((char *) buf) + x86_64_regmap[i]);
-}
-
-static void
-x86_64_store_gregset (const void *buf)
-{
-  int i;
-
-  for (i = 0; i < X86_64_NUM_GREGS; i++)
-    if (x86_64_regmap[i] != -1)
-      supply_register (i, ((char *) buf) + x86_64_regmap[i]);
-}
-
-static void
-x86_64_fill_fpregset (void *buf)
-{
-  i387_cache_to_fxsave (buf);
-}
-
-static void
-x86_64_store_fpregset (const void *buf)
-{
-  i387_fxsave_to_cache (buf);
-}
-
-struct regset_info target_regsets[] = {
-  { PTRACE_GETREGS, PTRACE_SETREGS, sizeof (elf_gregset_t),
-    GENERAL_REGS,
-    x86_64_fill_gregset, x86_64_store_gregset },
-  { PTRACE_GETFPREGS, PTRACE_SETFPREGS, sizeof (elf_fpregset_t),
-    FP_REGS,
-    x86_64_fill_fpregset, x86_64_store_fpregset },
-  { 0, 0, -1, -1, NULL, NULL }
-};
-
-static const unsigned char x86_64_breakpoint[] = { 0xCC };
-#define x86_64_breakpoint_len 1
-                
-extern int debug_threads;
-
-static CORE_ADDR
-x86_64_get_pc ()
-{
-  unsigned long pc;
-
-  collect_register_by_name ("rip", &pc);
-
-  if (debug_threads)
-    fprintf (stderr, "stop pc (before any decrement) is %08lx\n", pc);
-  return pc;
-}
-
-static void
-x86_64_set_pc (CORE_ADDR newpc)
-{
-  if (debug_threads)
-    fprintf (stderr, "set pc to %08lx\n", (long) newpc);
-  supply_register_by_name ("rip", &newpc);
-}
-
-static int
-x86_64_breakpoint_at (CORE_ADDR pc)
-{
-  unsigned char c;
-
-  read_inferior_memory (pc, &c, 1);
-  if (c == 0xCC)
-    return 1;
-
-  return 0;
-}
-
-struct linux_target_ops the_low_target = {
-  init_registers_x86_64_linux,
-  -1,
-  NULL,
-  NULL,
-  NULL,
-  x86_64_get_pc,
-  x86_64_set_pc,
-  x86_64_breakpoint,  
-  x86_64_breakpoint_len,
-  NULL,                                 
-  1,
-  x86_64_breakpoint_at,
-  NULL,
-  NULL,
-  NULL,
-  NULL,
-  NULL,
-  NULL,
-};
