https://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=140532


2007-01-01  Jan Kratochvil <jan.kratochvil@redhat.com>

	* rs6000-tdep.c (skip_prologue): Handle bl->brlr used by PIC code.


diff -u -rup gdb-6.5-orig/gdb/rs6000-tdep.c gdb-6.5/gdb/rs6000-tdep.c
--- gdb-6.5-orig/gdb/rs6000-tdep.c	2006-12-30 15:53:52.000000000 -0500
+++ gdb-6.5/gdb/rs6000-tdep.c	2006-12-31 19:06:28.000000000 -0500
@@ -1182,6 +1182,40 @@ skip_prologue (CORE_ADDR pc, CORE_ADDR l
       else if ((op & 0xfc000001) == 0x48000001)
 	{			/* bl foo, 
 				   to save fprs??? */
+	  CORE_ADDR bl_target;
+	  gdb_byte bl_target_op_buf[4];
+
+	  /* Safely skip:
+	     prologue: ...
+		       bl addr
+		       ...
+	     addr:     blrl
+	     as it could break the prologue by `prologue_sal.line'
+	     or `prologue_sal.line != this_sal.line' conditions below.  */
+	  /* Sign-extend it to the upper 6 bits.  */
+	  if (op & 0x02000000)
+	    bl_target = pc + -(long) (((~op) & 0x03fffffc) + 4);
+	  else
+	    bl_target = pc + (op & 0x03fffffc);
+	  if (target_read_memory (bl_target, bl_target_op_buf, 4) == 0)
+	    {
+	      unsigned long bl_target_op;
+
+	      bl_target_op = extract_signed_integer (bl_target_op_buf, 4);
+	      if (bl_target_op == 0x4e800021)	/* blrl  */
+		{
+		  /* If we did not yet retrieved LR into some GPR
+		     all our chances are lost.  On the other hand already
+		     stored LR is still kept intact in its GPR.  */
+		  if (lr_reg == -1)
+		    {
+		      /* Invalidate lr_reg, but don't set it to -1.
+			 That would mean that it had never been set.  */
+		      lr_reg = -2;
+		    }
+		  continue;
+		}
+	    }
 
 	  fdata->frameless = 0;
 	  /* Don't skip over the subroutine call if it is not within
