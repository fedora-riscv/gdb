http://sourceware.org/ml/gdb-patches/2010-01/msg00030.html
Subject: [patch] Re: Regression: field type preservation: 7.0 -> 7.0.1+HEAD

On Friday 01 January 2010 21:45:05 Jan Kratochvil wrote:
> -PASS: gdb.mi/mi-var-child.exp: get children of struct_declarations.s2.u2.u1s1
> +FAIL: gdb.mi/mi-var-child.exp: get children of struct_declarations.s2.u2.u1s1
> -PASS: gdb.mi/mi2-var-child.exp: get children of struct_declarations.s2.u2.u1s1
> +FAIL: gdb.mi/mi2-var-child.exp: get children of struct_declarations.s2.u2.u1s1
> -PASS: gdb.python/py-mi.exp: examine container children=0, no pretty-printing
> +FAIL: gdb.python/py-mi.exp: examine container children=0, no pretty-printing
> 
> due to:
> Re: RFA: unbreak typedefed bitfield
> http://sourceware.org/ml/gdb-patches/2009-12/msg00295.html
> commit fc85da4ee2a7c32afc53b1b334a4f84e2e9bd84e
> http://sourceware.org/ml/gdb-cvs/2009-12/msg00100.html

attached a fix on top of existing HEAD.

Original PR gdb/10884 was a regression 6.8 -> 7.0 due to:
RFC: Lazy bitfields
http://sourceware.org/ml/gdb-patches/2009-07/msg00437.html
http://sourceware.org/ml/gdb-cvs/2009-07/msg00143.html
07491b3409f6ace0b7a9a707775a56ce10fece1c

No regressions for HEAD on {x86_64,x86_64-m32,i686}-fedora12-linux-gnu.  Plus:
-FAIL: gdb.mi/mi-var-child.exp: get children of struct_declarations.s2.u2.u1s1
+PASS: gdb.mi/mi-var-child.exp: get children of struct_declarations.s2.u2.u1s1
-FAIL: gdb.mi/mi2-var-child.exp: get children of struct_declarations.s2.u2.u1s1
+PASS: gdb.mi/mi2-var-child.exp: get children of struct_declarations.s2.u2.u1s1
-FAIL: gdb.python/py-mi.exp: examine container children=0, no pretty-printing
+PASS: gdb.python/py-mi.exp: examine container children=0, no pretty-printing

Going to check it in also for gdb_7_0-branch after an approval.


Thanks,
Jan


gdb/
2010-01-02  Jan Kratochvil  <jan.kratochvil@redhat.com>

	* value.c (value_primitive_field): Remove one check_typedef call.
	Move bitpos and container_bitsize initialization after
	allocate_value_lazy.  New comment before accessing TYPE_LENGTH.

gdb/testsuite/
2010-01-02  Jan Kratochvil  <jan.kratochvil@redhat.com>

	* gdb.mi/var-cmd.c (do_bitfield_tests): Change "V.sharable" type to
	"uint_for_mi_testing".

--- a/gdb/testsuite/gdb.mi/var-cmd.c
+++ b/gdb/testsuite/gdb.mi/var-cmd.c
@@ -494,7 +494,7 @@ void do_bitfield_tests ()
     mi_create_varobj V d "create varobj for Data"
     mi_list_varobj_children "V" {
         {"V.alloc" "alloc" "0" "int"}
-        {"V.sharable" "sharable" "0" "unsigned int"}
+        {"V.sharable" "sharable" "0" "uint_for_mi_testing"}
     } "list children of Data"
     mi_check_varobj_value V.sharable 3 "access bitfield"
     :*/
--- a/gdb/value.c
+++ b/gdb/value.c
@@ -1873,7 +1873,6 @@ value_primitive_field (struct value *arg1, int offset,
 
   CHECK_TYPEDEF (arg_type);
   type = TYPE_FIELD_TYPE (arg_type, fieldno);
-  type = check_typedef (type);
 
   /* Handle packed fields */
 
@@ -1885,10 +1884,14 @@ value_primitive_field (struct value *arg1, int offset,
 	 Otherwise, adjust offset to the byte containing the first
 	 bit.  Assume that the address, offset, and embedded offset
 	 are sufficiently aligned.  */
-      int bitpos = TYPE_FIELD_BITPOS (arg_type, fieldno);
-      int container_bitsize = TYPE_LENGTH (type) * 8;
+      int bitpos, container_bitsize;
 
       v = allocate_value_lazy (type);
+
+      /* TYPE_LENGTH of TYPE gets initialized by allocate_value_lazy.  */
+      bitpos = TYPE_FIELD_BITPOS (arg_type, fieldno);
+      container_bitsize = TYPE_LENGTH (type) * 8;
+
       v->bitsize = TYPE_FIELD_BITSIZE (arg_type, fieldno);
       if ((bitpos % container_bitsize) + v->bitsize <= container_bitsize
 	  && TYPE_LENGTH (type) <= (int) sizeof (LONGEST))
@@ -1939,6 +1942,8 @@ value_primitive_field (struct value *arg1, int offset,
       else
 	{
 	  v = allocate_value (type);
+
+	  /* TYPE_LENGTH of TYPE gets initialized by allocate_value.  */
 	  memcpy (value_contents_raw (v),
 		  value_contents_raw (arg1) + offset,
 		  TYPE_LENGTH (type));

