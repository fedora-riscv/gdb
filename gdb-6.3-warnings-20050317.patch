http://sourceware.org/ml/gdb-patches/2008-12/msg00243.html

 	Check return values of functions declared with warn_unused_result
 	attribute in GLIBC 2.8.
 	* cli/cli-cmds.c (pwd_command): Check return value from getcwd.
 	* inflow.c (check_syscall): New function.
 	(new_tty): Use check_syscall to check return values from open and dup.
 	* linux-nat.c (linux_nat_info_proc_cmd): Check return value from fgets.
 	* main.c (captured_main): Call cwd after setting up gdb_stderr;
 	check for errors from getcwd.
 	* mi/mi-cmd-env.c (mi_cmd_env_pwd): Check return value from getcwd.
 	* ui-file.c (stdio_file_write): Check return value from fwrite.
 	(stdio_file_fputs): Check return value from fputs.
 	* utils.c (internal_vproblem): abort if last-ditch error message
 	write fails.

[ +linespec.c: Fedora patch. ]
[ +top.c: Fedora patch. ]

ui-file.c replaced by:
http://sourceware.org/ml/gdb-patches/2008-12/msg00260.html

---
 gdb/ChangeLog       |   14 ++++++++++++++
 gdb/cli/cli-cmds.c  |    4 +++-
 gdb/inflow.c        |   22 ++++++++++++++--------
 gdb/linux-nat.c     |    6 ++++--
 gdb/main.c          |   12 +++++++++---
 gdb/mi/mi-cmd-env.c |    5 ++++-
 gdb/ui-file.c       |    6 ++++--
 gdb/utils.c         |    8 +++++++-
 8 files changed, 59 insertions(+), 18 deletions(-)

diff --git a/gdb/cli/cli-cmds.c b/gdb/cli/cli-cmds.c
index 806a68a..b80bdfc 100644
--- a/gdb/cli/cli-cmds.c
+++ b/gdb/cli/cli-cmds.c
@@ -323,7 +323,9 @@ pwd_command (char *args, int from_tty)
 {
   if (args)
     error (_("The \"pwd\" command does not take an argument: %s"), args);
-  getcwd (gdb_dirbuf, sizeof (gdb_dirbuf));
+  if (! getcwd (gdb_dirbuf, sizeof (gdb_dirbuf)))
+    error (_("Error finding name of working directory: %s"),
+           safe_strerror (errno));
 
   if (strcmp (gdb_dirbuf, current_directory) != 0)
     printf_unfiltered (_("Working directory %s\n (canonically %s).\n"),
diff --git a/gdb/inflow.c b/gdb/inflow.c
index e82514e..7ecb5ab 100644
--- a/gdb/inflow.c
+++ b/gdb/inflow.c
@@ -523,6 +523,16 @@ new_tty_prefork (const char *ttyname)
   inferior_thisrun_terminal = ttyname;
 }
 
+static void
+check_syscall (const char *msg, int result)
+{
+  if (result < 0)
+    {
+      print_sys_errmsg (msg, errno);
+      _exit (1);
+    }
+}
+
 void
 new_tty (void)
 {
@@ -549,27 +559,23 @@ new_tty (void)
 
   /* Now open the specified new terminal.  */
   tty = open (inferior_thisrun_terminal, O_RDWR | O_NOCTTY);
-  if (tty == -1)
-    {
-      print_sys_errmsg (inferior_thisrun_terminal, errno);
-      _exit (1);
-    }
+  check_syscall (inferior_thisrun_terminal, tty);
 
   /* Avoid use of dup2; doesn't exist on all systems.  */
   if (tty != 0)
     {
       close (0);
-      dup (tty);
+      check_syscall ("dup'ing tty into fd 0", dup (tty));
     }
   if (tty != 1)
     {
       close (1);
-      dup (tty);
+      check_syscall ("dup'ing tty into fd 1", dup (tty));
     }
   if (tty != 2)
     {
       close (2);
-      dup (tty);
+      check_syscall ("dup'ing tty into fd 2", dup (tty));
     }
 
 #ifdef TIOCSCTTY
diff --git a/gdb/linux-nat.c b/gdb/linux-nat.c
index 913bfec..a829eb8 100644
--- a/gdb/linux-nat.c
+++ b/gdb/linux-nat.c
@@ -3666,8 +3666,10 @@ linux_nat_info_proc_cmd (char *args, int from_tty)
       if ((procfile = fopen (fname1, "r")) != NULL)
 	{
 	  struct cleanup *cleanup = make_cleanup_fclose (procfile);
-	  fgets (buffer, sizeof (buffer), procfile);
-	  printf_filtered ("cmdline = '%s'\n", buffer);
+          if (fgets (buffer, sizeof (buffer), procfile))
+            printf_filtered ("cmdline = '%s'\n", buffer);
+          else
+            warning (_("unable to read '/proc/%lld/cmdline'"), pid);
 	  do_cleanups (cleanup);
 	}
       else
diff --git a/gdb/main.c b/gdb/main.c
index a53002d..a9fd988 100644
--- a/gdb/main.c
+++ b/gdb/main.c
@@ -195,9 +195,6 @@ captured_main (void *data)
   line[0] = '\0';		/* Terminate saved (now empty) cmd line */
   instream = stdin;
 
-  getcwd (gdb_dirbuf, sizeof (gdb_dirbuf));
-  current_directory = gdb_dirbuf;
-
   gdb_stdout = stdio_fileopen (stdout);
   gdb_stderr = stdio_fileopen (stderr);
   gdb_stdlog = gdb_stderr;	/* for moment */
@@ -206,6 +203,15 @@ captured_main (void *data)
   gdb_stdtargerr = gdb_stderr;	/* for moment */
   gdb_stdtargin = gdb_stdin;	/* for moment */
 
+  if (! getcwd (gdb_dirbuf, sizeof (gdb_dirbuf)))
+    /* Don't use *_filtered or warning() (which relies on
+       current_target) until after initialize_all_files(). */
+    fprintf_unfiltered (gdb_stderr,
+                        _("%s: warning: error finding working directory: %s\n"),
+                        argv[0], safe_strerror (errno));
+    
+  current_directory = gdb_dirbuf;
+
   /* Set the sysroot path.  */
 #ifdef TARGET_SYSTEM_ROOT_RELOCATABLE
   gdb_sysroot = make_relative_prefix (argv[0], BINDIR, TARGET_SYSTEM_ROOT);
diff --git a/gdb/mi/mi-cmd-env.c b/gdb/mi/mi-cmd-env.c
index 327ddc5..0103153 100644
--- a/gdb/mi/mi-cmd-env.c
+++ b/gdb/mi/mi-cmd-env.c
@@ -78,7 +78,10 @@ mi_cmd_env_pwd (char *command, char **argv, int argc)
      
   /* Otherwise the mi level is 2 or higher.  */
 
-  getcwd (gdb_dirbuf, sizeof (gdb_dirbuf));
+  if (! getcwd (gdb_dirbuf, sizeof (gdb_dirbuf)))
+    error (_("mi_cmd_env_pwd: error finding name of working directory: %s"),
+           safe_strerror (errno));
+    
   ui_out_field_string (uiout, "cwd", gdb_dirbuf);
 }
 
diff --git a/gdb/utils.c b/gdb/utils.c
index d14009f..725f00b 100644
--- a/gdb/utils.c
+++ b/gdb/utils.c
@@ -865,7 +865,13 @@ internal_vproblem (struct internal_problem *problem,
 	abort ();	/* NOTE: GDB has only three calls to abort().  */
       default:
 	dejavu = 3;
-	write (STDERR_FILENO, msg, sizeof (msg));
+        /* Newer GLIBC versions put the warn_unused_result attribute
+           on write, but this is one of those rare cases where
+           ignoring the return value is correct.  Casting to (void)
+           does not fix this problem.  This is the solution suggested
+           at http://gcc.gnu.org/bugzilla/show_bug.cgi?id=25509.  */
+	if (write (STDERR_FILENO, msg, sizeof (msg)) != sizeof (msg))
+          abort ();
 	exit (1);
       }
   }
Index: gdb-6.7/gdb/linespec.c
===================================================================
--- gdb-6.7.orig/gdb/linespec.c	2007-10-14 23:31:03.000000000 +0200
+++ gdb-6.7/gdb/linespec.c	2007-10-14 23:53:57.000000000 +0200
@@ -1654,7 +1654,7 @@ static struct symtabs_and_lines
 find_method (int funfirstline, char ***canonical, char *saved_arg,
 	     char *copy, struct type *t, struct symbol *sym_class)
 {
-  struct symtabs_and_lines values;
+  struct symtabs_and_lines values = { NULL }; 
   struct symbol *sym = NULL;
   int i1;	/*  Counter for the symbol array.  */
   struct symbol **sym_arr =  alloca (total_number_of_methods (t)
Index: gdb-6.7/gdb/top.c
===================================================================
--- gdb-6.7.orig/gdb/top.c	2007-10-14 23:38:27.000000000 +0200
+++ gdb-6.7/gdb/top.c	2007-10-14 23:42:39.000000000 +0200
@@ -1636,7 +1636,8 @@ gdb_init (char *argv0)
 
   /* Run the init function of each source file */
 
-  getcwd (gdb_dirbuf, sizeof (gdb_dirbuf));
+  /* Unused result.  */
+  1 && getcwd (gdb_dirbuf, sizeof (gdb_dirbuf));
   current_directory = gdb_dirbuf;
 
 #ifdef __MSDOS__
--- ./gdb/ui-file.c	1 Jan 2008 22:53:13 -0000	1.15
+++ ./gdb/ui-file.c	14 Dec 2008 18:16:56 -0000
@@ -481,7 +481,9 @@ stdio_file_write (struct ui_file *file, 
   if (stdio->magic != &stdio_file_magic)
     internal_error (__FILE__, __LINE__,
 		    _("stdio_file_write: bad magic number"));
-  fwrite (buf, length_buf, 1, stdio->file);
+  /* Calling error crashes when we are called from the exception framework.  */
+  if (fwrite (buf, length_buf, 1, stdio->file))
+    ;
 }
 
 static void
@@ -491,7 +493,9 @@ stdio_file_fputs (const char *linebuffer
   if (stdio->magic != &stdio_file_magic)
     internal_error (__FILE__, __LINE__,
 		    _("stdio_file_fputs: bad magic number"));
-  fputs (linebuffer, stdio->file);
+  /* Calling error crashes when we are called from the exception framework.  */
+  if (fputs (linebuffer, stdio->file))
+    ;
 }
 
 static int
