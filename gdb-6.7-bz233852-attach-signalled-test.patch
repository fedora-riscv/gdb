2008-01-09  Jan Kratochvil  <jan.kratochvil@redhat.com>

	* gdb.threads/attach-into-signal.c, gdb.threads/attach-into-signal.exp,
	gdb.threads/attach-stopped.c, gdb.threads/attach-stopped.exp: New files.

2008-03-29  Jan Kratochvil  <jan.kratochvil@redhat.com>

	Bugreport by Petr Muller.
	* gdb.threads/attach-stopped.exp: Fix the `Second sleep' breakpoint,
	add there a comment.

Formerly gdb-6.3-bz202705-attach-stop-20051011-race-fix-test.patch:
	gdb.threads/attachstop-mt.exp, gdb.threads/attachstop-mt.c

diff -u -X /home/short/.diffi.list -ruNp gdb-6.5-unpatched/gdb/testsuite/gdb.threads/attach-into-signal.c gdb-6.5/gdb/testsuite/gdb.threads/attach-into-signal.c
--- gdb-6.5-unpatched/gdb/testsuite/gdb.threads/attach-into-signal.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.5/gdb/testsuite/gdb.threads/attach-into-signal.c	2008-01-09 15:26:30.000000000 +0100
@@ -0,0 +1,70 @@
+/* This testcase is part of GDB, the GNU debugger.
+
+   Copyright 2007 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+ 
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
+
+#include <signal.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#ifdef USE_THREADS
+#include <pthread.h>
+#endif
+
+void action(int sig, siginfo_t * info, void *uc)
+{
+  raise (SIGALRM);
+}
+
+static void *func (void *arg)
+{
+  struct sigaction act;
+
+  memset (&act, 0, sizeof(struct sigaction));
+  act.sa_sigaction = action;
+  act.sa_flags = SA_RESTART;
+  sigaction (SIGALRM, &act, 0);
+
+  raise (SIGALRM);
+
+  /* This should be NOTREACHED but sometimes it is reached - Bug 427860.
+     We never get here without ptrace(2).  It may also be a kernel bug.  */
+  for (;;)
+    pause ();
+
+  abort ();
+  /* NOTREACHED */
+  return NULL;
+}
+
+int main ()
+{
+
+#ifndef USE_THREADS
+
+  func (NULL);
+
+#else
+
+  pthread_t th;
+  pthread_create (&th, NULL, func, NULL);
+  pthread_join (th, NULL);
+
+#endif
+
+  return 0;
+}
diff -u -X /home/short/.diffi.list -ruNp gdb-6.5-unpatched/gdb/testsuite/gdb.threads/attach-into-signal.exp gdb-6.5/gdb/testsuite/gdb.threads/attach-into-signal.exp
--- gdb-6.5-unpatched/gdb/testsuite/gdb.threads/attach-into-signal.exp	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.5/gdb/testsuite/gdb.threads/attach-into-signal.exp	2008-01-09 15:26:30.000000000 +0100
@@ -0,0 +1,179 @@
+# Copyright 2007
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+# This test was created by modifying attach-stopped.exp.
+# This file was created by Jan Kratochvil <jan.kratochvil@redhat.com>.
+
+if $tracelevel then {
+    strace $tracelevel
+}
+
+set prms_id 0
+set bug_id 0
+
+set testfile "attach-into-signal"
+set srcfile  ${testfile}.c
+set binfile  ${objdir}/${subdir}/${testfile}
+set escapedbinfile  [string_to_regexp ${objdir}/${subdir}/${testfile}]
+
+remote_exec build "rm -f ${binfile}"
+# For debugging this test
+#
+#log_user 1
+
+proc corefunc { threadtype } {
+    global srcfile
+    global binfile
+    global escapedbinfile
+    global srcdir
+    global subdir
+    global gdb_prompt
+
+    if [get_compiler_info ${binfile}] {
+	return -1
+    }
+
+    # Start the program running and then wait for a bit, to be sure
+    # that it can be attached to.
+    # Statistically there is a better chance without giving process a nice.
+
+    set testpid [eval exec $binfile &]
+    exec sleep 2
+
+    # Run 2 passes of the test.
+    # The C file inferior stops pending its signals if a single one is lost,
+    # we test successful redelivery of the caught signal by the 2nd pass.
+
+    # linux-2.6.20.4.x86_64 had maximal attempt # 20 in 4 test runs.
+    set attempts 100
+    set attempt 1
+    set passes 1
+    while { $passes < 3 && $attempt <= $attempts } {
+
+	# Start with clean gdb
+	gdb_exit
+
+	set stoppedtry 0
+	while { $stoppedtry < 10 } {
+	    if [catch {open /proc/${testpid}/status r} fileid] {
+		set stoppedtry 10
+		break
+	    }
+	    gets $fileid line1;
+	    gets $fileid line2;
+	    close $fileid;
+
+	    if {![string match "*(stopped)*" $line2]} {
+		# No PASS message as we may be looping in multiple attempts.
+		break
+	    }
+	    sleep 1
+	    set stoppedtry [expr $stoppedtry + 1]
+	}
+	if { $stoppedtry >= 10 } {
+	    verbose -log $line2
+	    set test "$threadtype: process is still running on the attempt # $attempt of $attempts"
+	    break
+	}
+
+	gdb_start
+	gdb_reinitialize_dir $srcdir/$subdir
+	gdb_load ${binfile}
+
+	# No PASS message as we may be looping in multiple attempts.
+	gdb_test "set debug lin-lwp 1" "" ""
+
+	set test "$threadtype: set file (pass $passes), before attach1 to stopped process"
+	if {[gdb_test_multiple "file $binfile" $test {
+	   -re "Load new symbol table from.*y or n. $" {
+		# No PASS message as we may be looping in multiple attempts.
+		gdb_test "y" "Reading symbols from $escapedbinfile\.\.\.*done." ""
+	    }
+	    -re "Reading symbols from $escapedbinfile\.\.\.*done.*$gdb_prompt $" {
+		# No PASS message as we may be looping in multiple attempts.
+	    }
+	}] != 0 } {
+	    break
+	}
+
+	# Main test:
+	set test "$threadtype: attach (pass $passes), pending signal catch"
+	if {[gdb_test_multiple "attach $testpid" $test {
+	    -re "Attaching to program.*`?$escapedbinfile'?, process $testpid.*Redelivering pending Alarm clock..*$gdb_prompt $" {
+		# nonthreaded:
+		pass $test
+		verbose -log "$test succeeded on the attempt # $attempt of $attempts"
+		set passes [expr $passes + 1]
+	    }
+	    -re "Attaching to program.*`?$escapedbinfile'?, process $testpid.*$gdb_prompt $" {
+		# nonthreaded:
+		# We just lack the luck, we should try it again.
+		set attempt [expr $attempt + 1]
+	    }
+	    -re "Attaching to process $testpid.*Redelivering pending Alarm clock..*$gdb_prompt $" {
+		# threaded:
+		pass $test
+		verbose -log "$test succeeded on the attempt # $attempt of $attempts"
+		set passes [expr $passes + 1]
+	    }
+	    -re "Attaching to process $testpid.*$gdb_prompt $" {
+		# threaded:
+		# We just lack the luck, we should try it again.
+		set attempt [expr $attempt - 1]
+	    }
+	}] != 0 } {
+	    break
+	}
+    }
+    if {$passes < 3} {
+	if {$attempt > $attempts} {
+	    unresolved $test
+	} else {
+	    fail $test
+	}
+    }
+
+    # Exit and detach the process.
+       
+    gdb_exit
+
+    # Make sure we don't leave a process around to confuse
+    # the next test run (and prevent the compile by keeping
+    # the text file busy), in case the "set should_exit" didn't
+    # work.
+
+    # Continue the program - some Linux kernels need it before -9 if the
+    # process is stopped.
+    remote_exec build "kill -s CONT ${testpid}"
+       
+    remote_exec build "kill -9 ${testpid}"
+}
+
+# build the test case first without threads
+#
+if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug}] != "" } {
+    gdb_suppress_entire_file "Testcase nonthraded compile failed, so all tests in this file will automatically fail."
+}
+
+corefunc nonthreaded
+
+# build the test case also with threads
+#
+if  { [gdb_compile_pthreads "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug additional_flags=-DUSE_THREADS}] != "" } {
+    gdb_suppress_entire_file "Testcase threaded compile failed, so all tests in this file will automatically fail."
+}
+
+corefunc threaded
diff -u -X /home/short/.diffi.list -ruNp gdb-6.5-unpatched/gdb/testsuite/gdb.threads/attach-stopped.c gdb-6.5/gdb/testsuite/gdb.threads/attach-stopped.c
--- gdb-6.5-unpatched/gdb/testsuite/gdb.threads/attach-stopped.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.5/gdb/testsuite/gdb.threads/attach-stopped.c	2008-01-09 15:26:30.000000000 +0100
@@ -0,0 +1,51 @@
+/* This testcase is part of GDB, the GNU debugger.
+
+   Copyright 2005-2007 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+ 
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
+
+/* This program is intended to be started outside of gdb, then
+   manually stopped via a signal.  */
+
+#include <stddef.h>
+#include <unistd.h>
+#ifdef USE_THREADS
+#include <pthread.h>
+#endif
+
+static void *func (void *arg)
+{
+  sleep (10000);  /* Ridiculous time, but we will eventually kill it.  */
+  sleep (10000);  /* Second sleep.  */
+  return NULL;
+}
+
+int main ()
+{
+
+#ifndef USE_THREADS
+
+  func (NULL);
+
+#else
+
+  pthread_t th;
+  pthread_create (&th, NULL, func, NULL);
+  pthread_join (th, NULL);
+
+#endif
+
+  return 0;
+}
diff -u -X /home/short/.diffi.list -ruNp gdb-6.5-unpatched/gdb/testsuite/gdb.threads/attach-stopped.exp gdb-6.5/gdb/testsuite/gdb.threads/attach-stopped.exp
--- gdb-6.5-unpatched/gdb/testsuite/gdb.threads/attach-stopped.exp	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.5/gdb/testsuite/gdb.threads/attach-stopped.exp	2008-01-09 15:26:30.000000000 +0100
@@ -0,0 +1,222 @@
+# Copyright 2005-2007
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+# This test was created by modifying attach.exp.
+# This file was created by Jeff Johnston <jjohnstn@redhat.com>.
+# This file was updated by Jan Kratochvil <jan.kratochvil@redhat.com>.
+
+if $tracelevel then {
+    strace $tracelevel
+}
+
+set prms_id 0
+set bug_id 0
+
+# This test only works on Linux
+if { ![istarget "*-*-linux-gnu*"] } {
+    return 0
+}
+
+set testfile "attach-stopped"
+set srcfile  ${testfile}.c
+set binfile  ${objdir}/${subdir}/${testfile}
+set escapedbinfile  [string_to_regexp ${objdir}/${subdir}/${testfile}]
+
+#execute_anywhere "rm -f ${binfile}"
+remote_exec build "rm -f ${binfile}"
+# For debugging this test
+#
+#log_user 1
+
+proc corefunc { threadtype } {
+    global srcfile
+    global binfile
+    global escapedbinfile
+    global srcdir
+    global subdir
+    global gdb_prompt
+
+    if [get_compiler_info ${binfile}] {
+	return -1
+    }
+
+    # Start the program running and then wait for a bit, to be sure
+    # that it can be attached to.
+
+    set testpid [eval exec $binfile &]
+
+    # Avoid some race:
+    sleep 2
+
+    # Stop the program 
+    remote_exec build "kill -s STOP ${testpid}"
+
+    # Start with clean gdb
+    gdb_exit
+    gdb_start
+    gdb_reinitialize_dir $srcdir/$subdir
+    gdb_load ${binfile}
+
+    # Verify that we can attach to the process by first giving its
+    # executable name via the file command, and using attach with the
+    # process ID.
+
+    set test "$threadtype: set file, before attach1 to stopped process"
+    gdb_test_multiple "file $binfile" "$test" {
+       -re "Load new symbol table from.*y or n. $" {
+	    gdb_test "y" "Reading symbols from $escapedbinfile\.\.\.*done." \
+		    "$test (re-read)"
+	}
+	-re "Reading symbols from $escapedbinfile\.\.\.*done.*$gdb_prompt $" {
+	    pass "$test"
+	}
+    }
+
+    set test "$threadtype: attach1 to stopped, after setting file"
+    gdb_test_multiple "attach $testpid" "$test" {
+	-re "Attaching to program.*`?$escapedbinfile'?, process $testpid.*$gdb_prompt $" {
+	    pass "$test"
+	}
+    }
+
+    # ".*sleep.*clone.*" would fail on s390x as bt stops at START_THREAD there.
+    if {[string equal $threadtype threaded]} {
+	gdb_test "thread apply all bt" ".*sleep.*start_thread.*" "$threadtype: attach1 to stopped bt"
+    } else {
+	gdb_test "bt" ".*sleep.*main.*" "$threadtype: attach1 to stopped bt"
+    }
+
+    # Exit and detach the process.
+       
+    gdb_exit
+
+    # Avoid some race:
+    sleep 2
+
+    if [catch {open /proc/${testpid}/status r} fileid] {
+	set line2 "NOTFOUND"
+    } else {
+	gets $fileid line1;
+	gets $fileid line2;
+	close $fileid;
+    }
+
+    set test "$threadtype: attach1, exit leaves process stopped"
+    if {[string match "*(stopped)*" $line2]} {
+      pass $test
+    } else {
+      fail $test
+    }
+
+    # At this point, the process should still be stopped
+
+    gdb_start
+    gdb_reinitialize_dir $srcdir/$subdir
+    gdb_load ${binfile}
+
+    # Verify that we can attach to the process just by giving the
+    # process ID.
+       
+    set test "$threadtype: attach2 to stopped, after setting file"
+    gdb_test_multiple "attach $testpid" "$test" {
+	-re "Attaching to program.*`?$escapedbinfile'?, process $testpid.*$gdb_prompt $" {
+	    pass "$test"
+	}
+    }
+
+    # ".*sleep.*clone.*" would fail on s390x as bt stops at START_THREAD there.
+    if {[string equal $threadtype threaded]} {
+	gdb_test "thread apply all bt" ".*sleep.*start_thread.*" "$threadtype: attach2 to stopped bt"
+    } else {
+	gdb_test "bt" ".*sleep.*main.*" "$threadtype: attach2 to stopped bt"
+    }
+    # This breakpoint is there for old/non-x86 kernels not restarting syscalls.
+    gdb_breakpoint [gdb_get_line_number "Second sleep"]
+    set test "$threadtype: attach2 continue"
+    send_gdb "continue\n"
+    gdb_expect {
+      -re "Continuing"
+	{ pass "continue ($test)" }
+      timeout
+	{ fail "continue ($test) (timeout)" }
+    }
+
+    # For this to work we must be sure to consume the "Continuing."
+    # message first, or GDB's signal handler may not be in place.
+    after 1000 {send_gdb "\003"}
+    set test "$threadtype: attach2 stop interrupt"
+    gdb_expect 10 {
+      -re "Program received signal SIGINT.*$gdb_prompt $"
+	{
+	  pass $test
+	}
+      -re "Breakpoint \[0-9\].*$srcfile.*$gdb_prompt $"
+	{
+	  pass $test
+	}
+      timeout
+	{
+	  fail $test
+	}
+    }
+
+    gdb_exit
+
+    # Avoid some race:
+    sleep 2
+
+    # At this point, the process should be sleeping
+
+    if [catch {open /proc/${testpid}/status r} fileid2] {
+	set line2 "NOTFOUND"
+    } else {
+	gets $fileid2 line1;
+	gets $fileid2 line2;
+	close $fileid2;
+    }
+
+    set test "$threadtype: attach2, exit leaves process sleeping"
+    if {[string match "*(sleeping)*" $line2]} {
+      pass $test
+    } else {
+      fail $test
+    }
+
+    # Make sure we don't leave a process around to confuse
+    # the next test run (and prevent the compile by keeping
+    # the text file busy), in case the "set should_exit" didn't
+    # work.
+       
+    remote_exec build "kill -9 ${testpid}"
+}
+
+# build the test case first without threads
+#
+if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug}] != "" } {
+    gdb_suppress_entire_file "Testcase nonthraded compile failed, so all tests in this file will automatically fail."
+}
+
+corefunc nonthreaded
+
+# build the test case first without threads
+#
+if  { [gdb_compile_pthreads "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug additional_flags=-DUSE_THREADS}] != "" } {
+    gdb_suppress_entire_file "Testcase threaded compile failed, so all tests in this file will automatically fail."
+}
+
+corefunc threaded
+
+return 0
diff -u -X /home/short/.diffi.list -ruNp gdb-6.5-unpatched/gdb/testsuite/gdb.threads/attachstop-mt.c gdb-6.5/gdb/testsuite/gdb.threads/attachstop-mt.c
--- gdb-6.5-unpatched/gdb/testsuite/gdb.threads/attachstop-mt.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.5/gdb/testsuite/gdb.threads/attachstop-mt.c	2008-01-09 15:26:29.000000000 +0100
@@ -0,0 +1,56 @@
+/* This testcase is part of GDB, the GNU debugger.
+
+   Copyright 2005 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+ 
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
+
+/* This program is intended to be started outside of gdb, then
+   manually stopped via a signal.  */
+
+#include <unistd.h>
+#include <pthread.h>
+#include <stdio.h>
+
+/* Red Hat BZ PR 197584.c */
+
+void *func (void *arg)
+{
+  sleep (10000);  /* Ridiculous time, but we will eventually kill it.  */
+  sleep (10000);	/* RHEL3U8 kernel-2.4.21-47.EL will cut the sleep time.  */
+
+  return NULL;	/* thread-sleep */
+}
+
+int main ()
+{
+  pthread_t t1,t2;
+  int ret;
+
+  ret = pthread_create (&t1, NULL, func, NULL);
+  if (ret)
+    fprintf(stderr, "pthread_create(): %s", strerror (ret));
+  ret = pthread_create (&t2, NULL, func, NULL);
+  if (ret)
+    fprintf(stderr, "pthread_create(): %s", strerror (ret));
+
+  ret = pthread_join (t1, NULL);
+  if (ret)	/* first-join */
+    fprintf(stderr, "pthread_join(): %s", strerror (ret));
+  ret = pthread_join (t2, NULL);
+  if (ret)
+    fprintf(stderr, "pthread_join(): %s", strerror (ret));
+
+  return 0;
+}
diff -u -X /home/short/.diffi.list -ruNp gdb-6.5-unpatched/gdb/testsuite/gdb.threads/attachstop-mt.exp gdb-6.5/gdb/testsuite/gdb.threads/attachstop-mt.exp
--- gdb-6.5-unpatched/gdb/testsuite/gdb.threads/attachstop-mt.exp	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.5/gdb/testsuite/gdb.threads/attachstop-mt.exp	2008-01-09 18:13:49.000000000 +0100
@@ -0,0 +1,278 @@
+# Copyright 2006
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+# This test was created by modifying gdb.threads/attachstop.
+# This file was created by Jan Kratochvil <jan.kratochvil@redhat.com>.
+# Regression for: https://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=197584
+
+if $tracelevel then {
+    strace $tracelevel
+}
+
+set prms_id 0
+set bug_id 0
+
+# This test only works on Linux
+if { ![istarget "*-*-linux-gnu*"] } {
+    return 0
+}
+
+set testfile "attachstop-mt"
+set srcfile  ${testfile}.c
+set binfile  ${objdir}/${subdir}/${testfile}
+set escapedbinfile  [string_to_regexp ${objdir}/${subdir}/${testfile}]
+
+#execute_anywhere "rm -f ${binfile}"
+remote_exec build "rm -f ${binfile}"
+# For debugging this test
+#
+#log_user 1
+
+# build the test case
+#
+if  { [gdb_compile_pthreads "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug}] != "" } {
+    gdb_suppress_entire_file "Testcase compile failed, so all tests in this file will automatically fail."
+}
+
+if [get_compiler_info ${binfile}] {
+    return -1
+}
+
+# Start the program running and then wait for a bit, to be sure
+# that it can be attached to.
+
+set testpid [eval exec $binfile &]
+
+# No race
+sleep 2
+
+# Do not: set testpid2 [expr $testpid + 1]
+# as it will not exist on Red Hat 2.6.9-34.0.2.ELsmp
+set testpid2 [expr $testpid + 2]
+
+set status2 /proc/${testpid}/task/${testpid2}/status
+if {[expr ! [file exists $status2]]} {
+  # kernel-2.4
+  set status2 /proc/${testpid2}/status
+}
+
+# Initial sanity test it is normally sleeping
+set fileid0 [open $status2 r];
+gets $fileid0 line1;
+gets $fileid0 line2;
+close $fileid0;
+
+set test "attach0, initial sanity check of the sleeping state"
+if {[string match "*(sleeping)*" $line2]} {
+  pass $test
+} else {
+  fail $test
+}
+
+# Sttach and detach to test it will not become stopped
+gdb_start
+gdb_reinitialize_dir $srcdir/$subdir
+gdb_load ${binfile}
+
+set test "attach0 to sleeping"
+gdb_test_multiple "attach $testpid" "$test" {
+    -re "Attaching to program.*`?$escapedbinfile'?, process $testpid.*$gdb_prompt $" {
+        pass "$test"
+    }
+}
+
+gdb_test "gcore /dev/null" ".*aved corefile.*" "attach0 to sleeping gcore invocation"
+
+gdb_test "thread 2" ".*witching to thread 2 .*" "attach0 to sleeping switch thread"
+
+gdb_test "bt" ".*sleep.*func.*" "attach0 to sleeping bt"
+
+# Exit and detach the process.
+
+gdb_exit
+
+# No race
+sleep 2
+
+# Check it did not get stopped by our gdb
+set fileid1 [open $status2 r];
+gets $fileid1 line1;
+gets $fileid1 line2;
+close $fileid1;
+
+set test "attach1, post-gdb sanity check of the sleeping state - Red Hat BZ 197584"
+if {[string match "*(sleeping)*" $line2]} {
+  pass $test
+} else {
+  fail $test
+}
+
+# Stop the program 
+remote_exec build "kill -s STOP ${testpid}"
+
+# No race
+sleep 2
+
+# Check it really got stopped by kill(1)
+set fileid2 [open $status2 r];
+gets $fileid2 line1;
+gets $fileid2 line2;
+close $fileid2;
+
+set test "attach2, initial sanity check of the stopped state"
+if {[string match "*(stopped)*" $line2]} {
+  pass $test
+} else {
+  fail $test
+}
+
+# Start with clean gdb
+gdb_start
+gdb_reinitialize_dir $srcdir/$subdir
+gdb_load ${binfile}
+
+# Verify that we can attach to the process by first giving its
+# executable name via the file command, and using attach with the
+# process ID.
+
+set test "set file, before attach3 to stopped process"
+gdb_test_multiple "file $binfile" "$test" {
+   -re "Load new symbol table from.*y or n. $" {
+        gdb_test "y" "Reading symbols from $escapedbinfile\.\.\.*done." \
+		"$test (re-read)"
+    }
+    -re "Reading symbols from $escapedbinfile\.\.\.*done.*$gdb_prompt $" {
+        pass "$test"
+    }
+}
+
+set test "attach3 to stopped, after setting file"
+gdb_test_multiple "attach $testpid" "$test" {
+    -re "Attaching to program.*`?$escapedbinfile'?, process $testpid.*$gdb_prompt $" {
+        pass "$test"
+    }
+}
+
+# We may be already after the threads phase.
+# `thread 2' command is important for the test to switch the current thread to
+# a non-primary one for the detach process.
+
+gdb_test "thread 2" ".*(witching to thread 2 |hread ID 2 not known).*" "attach3 to stopped switch thread"
+gdb_test "bt" ".*sleep.*(func|main).*" "attach3 to stopped bt"
+
+# Exit and detach the process.
+gdb_exit
+
+# No race
+sleep 2
+
+set fileid3 [open $status2 r];
+gets $fileid3 line1;
+gets $fileid3 line2;
+close $fileid3;
+
+set test "attach3, exit leaves process stopped"
+if {[string match "*(stopped)*" $line2]} {
+  pass $test
+} else {
+  fail $test
+}
+
+# At this point, the process should still be stopped
+
+# Continue the test as we would hit another expected bug regarding
+# 	Program received signal SIGSTOP, Stopped (signal).
+# across NPTL threads.
+
+gdb_start
+gdb_reinitialize_dir $srcdir/$subdir
+gdb_load ${binfile}
+
+# Verify that we can attach to the process just by giving the
+# process ID.
+   
+set test "attach4 to stopped, after setting file"
+gdb_test_multiple "attach $testpid" "$test" {
+    -re "Attaching to program.*`?$escapedbinfile'?, process $testpid.*$gdb_prompt $" {
+        pass "$test"
+    }
+}
+
+# We may be already after the threads phase.
+# `thread 2' command is important for the test to switch the current thread to
+# a non-primary one for the detach process.
+
+gdb_test "thread 2" ".*(witching to thread 2 |hread ID 2 not known).*" "attach4 to stopped switch thread"
+gdb_test "bt" ".*sleep.*(func|main).*" "attach4 to stopped bt"
+
+# RHEL3U8 kernel-2.4.21-47.EL will not return SIGINT but only shorten the sleep.
+gdb_breakpoint [gdb_get_line_number "Ridiculous time"]
+gdb_breakpoint [gdb_get_line_number "cut the sleep time"]
+set test "attach4 continue"
+send_gdb "continue\n"
+gdb_expect {
+  -re "Continuing"
+    { pass "continue ($test)" }
+  timeout
+    { fail "continue ($test) (timeout)" }
+}
+
+# For this to work we must be sure to consume the "Continuing."
+# message first, or GDB's signal handler may not be in place.
+after 1000 {send_gdb "\003"}
+set test "attach4 stop by interrupt"
+gdb_expect {
+  -re "Program received signal SIGINT.*$gdb_prompt $"
+    {
+      pass $test
+    }
+  -re "Breakpoint \[0-9\].*$srcfile.*$gdb_prompt $"
+    {
+      pass $test
+    }
+  timeout
+    {
+      fail "$test (timeout)"
+    }
+}
+
+gdb_exit
+
+# No race
+sleep 2
+
+# At this point, the process should be sleeping
+
+set fileid4 [open $status2 r];
+gets $fileid4 line1;
+gets $fileid4 line2;
+close $fileid4;
+
+set test "attach4, exit leaves process sleeping"
+if {[string match "*(sleeping)*" $line2]} {
+  pass $test
+} else {
+  fail $test
+}
+
+# Make sure we don't leave a process around to confuse
+# the next test run (and prevent the compile by keeping
+# the text file busy), in case the "set should_exit" didn't
+# work.
+   
+remote_exec build "kill -9 ${testpid}"
+
+return 0
