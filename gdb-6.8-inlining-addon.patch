Index: gdb-6.8.50.20081128/gdb/testsuite/gdb.opt/inline-bt.c
===================================================================
--- gdb-6.8.50.20081128.orig/gdb/testsuite/gdb.opt/inline-bt.c	2008-12-10 00:25:31.000000000 +0100
+++ gdb-6.8.50.20081128/gdb/testsuite/gdb.opt/inline-bt.c	2008-12-10 00:37:26.000000000 +0100
@@ -13,10 +13,16 @@
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
-int x, y;
+/* VOLATILE forces all the inlining to happen as otherwise the whole program
+   gets optimized by CSE to just simple assignments of the results.  */
+volatile int x, y;
 volatile int result;
 
-void bar(void);
+inline void bar(void)
+{
+  x += y; /* set breakpoint 1 here */
+}
+
 
 inline int func1(void)
 {
Index: gdb-6.8.50.20081128/gdb/testsuite/gdb.opt/inline-bt.exp
===================================================================
--- gdb-6.8.50.20081128.orig/gdb/testsuite/gdb.opt/inline-bt.exp	2008-12-10 00:25:31.000000000 +0100
+++ gdb-6.8.50.20081128/gdb/testsuite/gdb.opt/inline-bt.exp	2008-12-10 00:37:26.000000000 +0100
@@ -41,18 +41,19 @@ if { [skip_inline_frame_tests] } {
     return
 }
 
-set line1 [gdb_get_line_number "set breakpoint 1 here" ${fullsrcfile2}]
-gdb_breakpoint $srcfile2:$line1
+set line1 [gdb_get_line_number "set breakpoint 1 here" ${srcfile}]
+gdb_breakpoint $srcfile:$line1
 
 gdb_test "continue" ".*set breakpoint 1 here.*" "continue to bar (1)"
 gdb_test "backtrace" "#0  bar.*#1  .*main.*" "backtrace from bar (1)"
-gdb_test "info frame" ".*called by frame.*" "bar not inlined"
+gdb_test "info frame" ".*inlined into frame.*" "bar inlined"
 
-gdb_test "continue" ".*set breakpoint 1 here.*" "continue to bar (2)"
-gdb_test "backtrace" "#0  bar.*#1  .*func1.*#2  .*main.*" \
-    "backtrace from bar (2)"
-gdb_test "up" "#1  .*func1.*" "up from bar (2)"
-gdb_test "info frame" ".*inlined into frame.*" "func1 inlined (2)"
+# gcc-4.3.1 omits the line number information for (2).
+#gdb_test "continue" ".*set breakpoint 1 here.*" "continue to bar (2)"
+#gdb_test "backtrace" "#0  bar.*#1  .*func1.*#2  .*main.*" \
+#    "backtrace from bar (2)"
+#gdb_test "up" "#1  .*func1.*" "up from bar (2)"
+#gdb_test "info frame" ".*inlined into frame.*" "func1 inlined (2)"
 
 gdb_test "continue" ".*set breakpoint 1 here.*" "continue to bar (3)"
 gdb_test "backtrace" "#0  bar.*#1  .*func1.*#2  .*func2.*#3  .*main.*" \
Index: gdb-6.8.50.20081128/gdb/testsuite/gdb.opt/inline-cmds.c
===================================================================
--- gdb-6.8.50.20081128.orig/gdb/testsuite/gdb.opt/inline-cmds.c	2008-12-10 00:25:31.000000000 +0100
+++ gdb-6.8.50.20081128/gdb/testsuite/gdb.opt/inline-cmds.c	2008-12-10 00:37:26.000000000 +0100
@@ -13,13 +13,19 @@
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
-int x, y;
+/* VOLATILE forces all the inlining to happen as otherwise the whole program
+   gets optimized by CSE to just simple assignments of the results.  */
+volatile int x, y;
 volatile int result;
 
-void bar(void);
 void marker(void);
 void noinline(void);
 
+inline void bar(void)
+{
+  x += y; /* set breakpoint 1 here */
+}
+
 inline int func1(void)
 {
   bar ();
Index: gdb-6.8.50.20081128/gdb/testsuite/gdb.opt/inline-cmds.exp
===================================================================
--- gdb-6.8.50.20081128.orig/gdb/testsuite/gdb.opt/inline-cmds.exp	2008-12-10 00:25:31.000000000 +0100
+++ gdb-6.8.50.20081128/gdb/testsuite/gdb.opt/inline-cmds.exp	2008-12-10 00:36:27.000000000 +0100
@@ -45,9 +45,9 @@ if { [skip_inline_frame_tests] } {
 
 # First, check that the things we expected to be inlined really were,
 # and those that shouldn't be weren't.
-set line1 [gdb_get_line_number "set breakpoint 1 here" ${fullsrcfile2}]
+set line1 [gdb_get_line_number "set breakpoint 1 here" ${srcfile2}]
 gdb_breakpoint $srcfile2:$line1
-set line2 [gdb_get_line_number "set breakpoint 2 here" ${fullsrcfile2}]
+set line2 [gdb_get_line_number "set breakpoint 2 here" ${srcfile2}]
 gdb_breakpoint $srcfile2:$line2
 
 gdb_test "continue" ".*set breakpoint 1 here.*" "continue to bar (1)"
@@ -66,7 +66,7 @@ gdb_test "info frame" ".*inlined into fr
 
 gdb_test "continue" ".*set breakpoint 2 here.*" "continue to marker"
 gdb_test "backtrace" "#0  marker.*#1  .*main.*" "backtrace from marker"
-gdb_test "info frame" ".*called by frame.*" "marker not inlined"
+gdb_test "info frame" ".*\n called by frame.*" "marker not inlined"
 
 # Next, check that we can next over inlined functions.  We should not end up
 # inside any of them.
Index: gdb-6.8.50.20081128/gdb/testsuite/gdb.opt/inline-locals.c
===================================================================
--- gdb-6.8.50.20081128.orig/gdb/testsuite/gdb.opt/inline-locals.c	2008-12-10 00:25:31.000000000 +0100
+++ gdb-6.8.50.20081128/gdb/testsuite/gdb.opt/inline-locals.c	2008-12-10 00:37:26.000000000 +0100
@@ -13,11 +13,16 @@
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
 
-int x, y;
+/* VOLATILE forces all the inlining to happen as otherwise the whole program
+   gets optimized by CSE to just simple assignments of the results.  */
+volatile int x, y;
 volatile int result;
 volatile int *array_p;
 
-void bar(void);
+inline void bar(void)
+{
+  x += y; /* set breakpoint 1 here */
+}
 
 inline int func1(int arg1)
 {
Index: gdb-6.8.50.20081128/gdb/testsuite/gdb.opt/inline-locals.exp
===================================================================
--- gdb-6.8.50.20081128.orig/gdb/testsuite/gdb.opt/inline-locals.exp	2008-12-10 00:25:31.000000000 +0100
+++ gdb-6.8.50.20081128/gdb/testsuite/gdb.opt/inline-locals.exp	2008-12-10 00:37:26.000000000 +0100
@@ -43,8 +43,8 @@ if { [skip_inline_var_tests] } {
 
 set no_frames [skip_inline_frame_tests]
 
-set line1 [gdb_get_line_number "set breakpoint 1 here" ${fullsrcfile2}]
-gdb_breakpoint $srcfile2:$line1
+set line1 [gdb_get_line_number "set breakpoint 1 here" ${srcfile}]
+gdb_breakpoint $srcfile:$line1
 
 gdb_test "continue" ".*set breakpoint 1 here.*" "continue to bar (1)"
 
@@ -77,6 +77,9 @@ if { ! $no_frames } {
 
 # Make sure that locals on the stack are found.  This is an array to
 # prevent it from living in a register.
+if [test_compiler_info "gcc-4-3-*"] {
+    setup_kfail *-*-* "gcc/debug.optimization"
+}
 gdb_test "print array\[0\]" "\\\$$decimal = 0" "print local (2)"
 
 if { ! $no_frames } {
@@ -115,4 +118,7 @@ if { ! $no_frames } {
     gdb_test "info locals" ".*arg2 = 184.*" "info locals above bar (3b)"
 }
 
+if [test_compiler_info "gcc-4-3-*"] {
+    setup_kfail *-*-* "gcc/debug.optimization"
+}
 gdb_test "print array\[0\]" "\\\$$decimal = 184" "print local (3)"
Index: gdb-6.8.50.20081128/gdb/frame.c
===================================================================
--- gdb-6.8.50.20081128.orig/gdb/frame.c	2008-12-10 00:25:31.000000000 +0100
+++ gdb-6.8.50.20081128/gdb/frame.c	2008-12-10 00:25:31.000000000 +0100
@@ -269,7 +269,7 @@ fprint_frame (struct ui_file *file, stru
 static struct frame_info *
 skip_inlined_frames (struct frame_info *frame)
 {
-  while (get_frame_type (frame) == INLINE_FRAME)
+  while (frame && get_frame_type (frame) == INLINE_FRAME)
     frame = get_prev_frame (frame);
 
   return frame;
Index: gdb-6.8.50.20081128/gdb/breakpoint.c
===================================================================
--- gdb-6.8.50.20081128.orig/gdb/breakpoint.c	2008-12-10 00:25:31.000000000 +0100
+++ gdb-6.8.50.20081128/gdb/breakpoint.c	2008-12-10 00:36:27.000000000 +0100
@@ -57,6 +57,7 @@
 #include "top.h"
 #include "wrapper.h"
 #include "valprint.h"
+#include "inline-frame.h"
 
 #include "mi/mi-common.h"
 
@@ -2976,6 +2977,12 @@ bpstat_stop_status (CORE_ADDR bp_addr, p
 	    bs->print = 0;
 	  }
 	bs->commands = copy_command_lines (bs->commands);
+
+	/* Display the innermost inlined frame at a breakpont as it gives to
+	   most of the available information.  */
+	if (b->type != bp_until && b->type != bp_finish)
+	  while (inline_skipped_frames (ptid))
+	    step_into_inline_frame (ptid);
       }
 
     /* Print nothing for this entry if we dont stop or if we dont print.  */
Index: gdb-6.8.50.20081128/gdb/inline-frame.c
===================================================================
--- gdb-6.8.50.20081128.orig/gdb/inline-frame.c	2008-12-10 00:25:31.000000000 +0100
+++ gdb-6.8.50.20081128/gdb/inline-frame.c	2008-12-10 00:40:49.000000000 +0100
@@ -183,6 +183,12 @@ inline_frame_sniffer (const struct frame
   if (frame_block == NULL)
     return 0;
 
+  /* For >=2 inlined functions SKIPPED_SYMBOL needs to be different after each
+     step_into_inline_frame call.  But skip_inline_frames is called only once
+     and thus SKIPPED_SYMBOL needs to be calculated by INLINE_FRAME_SNIFFER.  */
+  if (state)
+    state->skipped_symbol = NULL;
+
   /* Calculate DEPTH, the number of inlined functions at this
      location.  */
   depth = 0;
@@ -192,6 +198,10 @@ inline_frame_sniffer (const struct frame
       if (block_inlined_p (cur_block))
 	depth++;
 
+      if (state && depth == state->skipped_frames
+	  && state->skipped_symbol == NULL)
+	state->skipped_symbol = BLOCK_FUNCTION (cur_block);
+
       cur_block = BLOCK_SUPERBLOCK (cur_block);
     }
 
@@ -275,7 +285,6 @@ skip_inline_frames (ptid_t ptid)
 {
   CORE_ADDR this_pc;
   struct block *frame_block, *cur_block;
-  struct symbol *last_sym = NULL;
   int skip_count = 0;
   struct inline_state *state;
 
@@ -296,10 +305,7 @@ skip_inline_frames (ptid_t ptid)
 		 of BLOCK_START.  */
 	      if (BLOCK_START (cur_block) == this_pc
 		  || block_starting_point_at (this_pc, cur_block))
-		{
-		  skip_count++;
-		  last_sym = BLOCK_FUNCTION (cur_block);
-		}
+		skip_count++;
 	      else
 		break;
 	    }
@@ -311,7 +317,6 @@ skip_inline_frames (ptid_t ptid)
   state = allocate_inline_frame_state (ptid);
   state->skipped_frames = skip_count;
   state->saved_pc = this_pc;
-  state->skipped_symbol = last_sym;
 
   if (skip_count != 0)
     reinit_frame_cache ();
Index: gdb-6.8.50.20081128/gdb/testsuite/gdb.opt/inline-markers.c
===================================================================
--- gdb-6.8.50.20081128.orig/gdb/testsuite/gdb.opt/inline-markers.c	2008-12-10 00:25:31.000000000 +0100
+++ gdb-6.8.50.20081128/gdb/testsuite/gdb.opt/inline-markers.c	2008-12-10 00:37:26.000000000 +0100
@@ -15,11 +15,6 @@
 
 extern int x, y;
 
-void bar(void)
-{
-  x += y; /* set breakpoint 1 here */
-}
-
 void marker(void)
 {
   x += y; /* set breakpoint 2 here */
