http://sourceware.org/ml/gdb-cvs/2012-09/msg00084.html

### src/gdb/ChangeLog	2012/09/17 08:42:07	1.14666
### src/gdb/ChangeLog	2012/09/17 08:52:17	1.14667
## -1,3 +1,23 @@
+2012-09-17  Siddhesh Poyarekar  <siddhesh@redhat.com>
+
+	* m2-valprint.c (m2_print_array_contents): Eliminate variable
+	ELTLEN and use TYPE_LENGTH directly.
+	(m2_val_print): Likewise.
+	* m68k-tdep.c (m68k_svr4_extract_return_value): Eliminate
+	variable LEN and use TYPE_LENGTH directly.
+	(m68k_svr4_store_return_value): Likewise.
+	* mips-tdep.c (mips_o32_push_dummy_call): Eliminate variable
+	ARGLEN and use TYPE_LENGTH directly.
+	(mips_o64_push_dummy_call): Likewise.
+	* s390-tdep (s390_function_arg_pass_by_reference): Eliminate
+	variable LENGTH and use TYPE_LENGTH directly.
+	(s390_function_arg_float): Likewise.
+	(s390_function_arg_integer): Likewise.
+	(s390_push_dummy_call): Likewise.
+	(s390_return_value_convention): Likewise.
+	* spu-tdep.c (spu_push_dummy_call): Eliminate LEN and use
+	TYPE_LENGTH directly.
+
 2012-09-17  Yao Qi  <yao@codesourcery.com>
 
 	* cli/cli-decode.c (add_setshow_zuinteger_unlimited_cmd): New.
--- src/gdb/m2-valprint.c	2012/08/16 07:36:20	1.45
+++ src/gdb/m2-valprint.c	2012/09/17 08:52:18	1.46
@@ -269,16 +269,14 @@
 			 const struct value_print_options *options,
 			 int len)
 {
-  int eltlen;
   CHECK_TYPEDEF (type);
 
   if (TYPE_LENGTH (type) > 0)
     {
-      eltlen = TYPE_LENGTH (type);
       if (options->prettyprint_arrays)
 	print_spaces_filtered (2 + 2 * recurse, stream);
       /* For an array of chars, print with string syntax.  */
-      if (eltlen == 1 &&
+      if (TYPE_LENGTH (type) == 1 &&
 	  ((TYPE_CODE (type) == TYPE_CODE_INT)
 	   || ((current_language->la_language == language_m2)
 	       && (TYPE_CODE (type) == TYPE_CODE_CHAR)))
@@ -320,7 +318,6 @@
   unsigned int i = 0;	/* Number of characters printed.  */
   unsigned len;
   struct type *elttype;
-  unsigned eltlen;
   CORE_ADDR addr;
 
   CHECK_TYPEDEF (type);
@@ -330,12 +327,11 @@
       if (TYPE_LENGTH (type) > 0 && TYPE_LENGTH (TYPE_TARGET_TYPE (type)) > 0)
 	{
 	  elttype = check_typedef (TYPE_TARGET_TYPE (type));
-	  eltlen = TYPE_LENGTH (elttype);
-	  len = TYPE_LENGTH (type) / eltlen;
+	  len = TYPE_LENGTH (type) / TYPE_LENGTH (elttype);
 	  if (options->prettyprint_arrays)
 	    print_spaces_filtered (2 + 2 * recurse, stream);
 	  /* For an array of chars, print with string syntax.  */
-	  if (eltlen == 1 &&
+	  if (TYPE_LENGTH (elttype) == 1 &&
 	      ((TYPE_CODE (elttype) == TYPE_CODE_INT)
 	       || ((current_language->la_language == language_m2)
 		   && (TYPE_CODE (elttype) == TYPE_CODE_CHAR)))
--- src/gdb/m68k-tdep.c	2012/07/24 16:37:24	1.159
+++ src/gdb/m68k-tdep.c	2012/09/17 08:52:18	1.160
@@ -315,7 +315,6 @@
 m68k_svr4_extract_return_value (struct type *type, struct regcache *regcache,
 				gdb_byte *valbuf)
 {
-  int len = TYPE_LENGTH (type);
   gdb_byte buf[M68K_MAX_REGISTER_SIZE];
   struct gdbarch *gdbarch = get_regcache_arch (regcache);
   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
@@ -326,7 +325,7 @@
       regcache_raw_read (regcache, M68K_FP0_REGNUM, buf);
       convert_typed_floating (buf, fpreg_type, valbuf, type);
     }
-  else if (TYPE_CODE (type) == TYPE_CODE_PTR && len == 4)
+  else if (TYPE_CODE (type) == TYPE_CODE_PTR && TYPE_LENGTH (type) == 4)
     regcache_raw_read (regcache, M68K_A0_REGNUM, valbuf);
   else
     m68k_extract_return_value (type, regcache, valbuf);
@@ -357,7 +356,6 @@
 m68k_svr4_store_return_value (struct type *type, struct regcache *regcache,
 			      const gdb_byte *valbuf)
 {
-  int len = TYPE_LENGTH (type);
   struct gdbarch *gdbarch = get_regcache_arch (regcache);
   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
 
@@ -368,7 +366,7 @@
       convert_typed_floating (valbuf, type, buf, fpreg_type);
       regcache_raw_write (regcache, M68K_FP0_REGNUM, buf);
     }
-  else if (TYPE_CODE (type) == TYPE_CODE_PTR && len == 4)
+  else if (TYPE_CODE (type) == TYPE_CODE_PTR && TYPE_LENGTH (type) == 4)
     {
       regcache_raw_write (regcache, M68K_A0_REGNUM, valbuf);
       regcache_raw_write (regcache, M68K_D0_REGNUM, valbuf);
--- src/gdb/mips-tdep.c	2012/08/19 22:22:49	1.561
+++ src/gdb/mips-tdep.c	2012/09/17 08:52:18	1.562
@@ -5174,13 +5174,12 @@
   for (argnum = 0; argnum < nargs; argnum++)
     {
       struct type *arg_type = check_typedef (value_type (args[argnum]));
-      int arglen = TYPE_LENGTH (arg_type);
 
       /* Align to double-word if necessary.  */
       if (mips_type_needs_double_align (arg_type))
 	len = align_up (len, MIPS32_REGSIZE * 2);
       /* Allocate space on the stack.  */
-      len += align_up (arglen, MIPS32_REGSIZE);
+      len += align_up (TYPE_LENGTH (arg_type), MIPS32_REGSIZE);
     }
   sp -= align_up (len, 16);
 
@@ -5703,10 +5702,9 @@
   for (argnum = 0; argnum < nargs; argnum++)
     {
       struct type *arg_type = check_typedef (value_type (args[argnum]));
-      int arglen = TYPE_LENGTH (arg_type);
 
       /* Allocate space on the stack.  */
-      len += align_up (arglen, MIPS64_REGSIZE);
+      len += align_up (TYPE_LENGTH (arg_type), MIPS64_REGSIZE);
     }
   sp -= align_up (len, 16);
 
--- src/gdb/s390-tdep.c	2012/05/18 21:02:50	1.206
+++ src/gdb/s390-tdep.c	2012/09/17 08:52:18	1.207
@@ -2489,8 +2489,7 @@
 static int
 s390_function_arg_pass_by_reference (struct type *type)
 {
-  unsigned length = TYPE_LENGTH (type);
-  if (length > 8)
+  if (TYPE_LENGTH (type) > 8)
     return 1;
 
   return (is_struct_like (type) && !is_power_of_two (TYPE_LENGTH (type)))
@@ -2503,8 +2502,7 @@
 static int
 s390_function_arg_float (struct type *type)
 {
-  unsigned length = TYPE_LENGTH (type);
-  if (length > 8)
+  if (TYPE_LENGTH (type) > 8)
     return 0;
 
   return is_float_like (type);
@@ -2515,13 +2513,12 @@
 static int
 s390_function_arg_integer (struct type *type)
 {
-  unsigned length = TYPE_LENGTH (type);
-  if (length > 8)
+  if (TYPE_LENGTH (type) > 8)
     return 0;
 
    return is_integer_like (type)
 	  || is_pointer_like (type)
-	  || (is_struct_like (type) && is_power_of_two (length));
+	  || (is_struct_like (type) && is_power_of_two (TYPE_LENGTH (type)));
 }
 
 /* Return ARG, a `SIMPLE_ARG', sign-extended or zero-extended to a full
@@ -2616,11 +2613,10 @@
     {
       struct value *arg = args[i];
       struct type *type = check_typedef (value_type (arg));
-      unsigned length = TYPE_LENGTH (type);
 
       if (s390_function_arg_pass_by_reference (type))
         {
-          sp -= length;
+          sp -= TYPE_LENGTH (type);
           sp = align_down (sp, alignment_of (type));
           copy_addr[i] = sp;
         }
@@ -2799,8 +2795,7 @@
 static enum return_value_convention
 s390_return_value_convention (struct gdbarch *gdbarch, struct type *type)
 {
-  int length = TYPE_LENGTH (type);
-  if (length > 8)
+  if (TYPE_LENGTH (type) > 8)
     return RETURN_VALUE_STRUCT_CONVENTION;
 
   switch (TYPE_CODE (type))
--- src/gdb/spu-tdep.c	2012/05/18 21:02:50	1.81
+++ src/gdb/spu-tdep.c	2012/09/17 08:52:18	1.82
@@ -1373,8 +1373,7 @@
       struct value *arg = args[i];
       struct type *type = check_typedef (value_type (arg));
       const gdb_byte *contents = value_contents (arg);
-      int len = TYPE_LENGTH (type);
-      int n_regs = align_up (len, 16) / 16;
+      int n_regs = align_up (TYPE_LENGTH (type), 16) / 16;
 
       /* If the argument doesn't wholly fit into registers, it and
 	 all subsequent arguments go to the stack.  */
