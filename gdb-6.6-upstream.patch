2006-12-28  Daniel Jacobowitz  <dan@codesourcery.com>

	* ia64-tdep.c (get_kernel_table): Correct signedness in check
	for a negative return value.


--- ./gdb/ia64-tdep.c	12 Jul 2006 18:13:45 -0000	1.140
+++ ./gdb/ia64-tdep.c	28 Dec 2006 23:48:51 -0000	1.141
@@ -2486,13 +2486,14 @@ get_kernel_table (unw_word_t ip, unw_dyn
   if (!ktab) 
     {
       gdb_byte *ktab_buf;
-      size_t size;
+      LONGEST size;
 
-      ktab_size = getunwind_table (&ktab_buf);
-      if (ktab_size <= 0)
+      size = getunwind_table (&ktab_buf);
+      if (size <= 0)
 	return -UNW_ENOINFO;
-      else
-	ktab = (struct ia64_table_entry *) ktab_buf;
+
+      ktab = (struct ia64_table_entry *) ktab_buf;
+      ktab_size = size;
 
       for (etab = ktab; etab->start_offset; ++etab)
         etab->info_offset += KERNEL_START;


2007-01-11  Daniel Jacobowitz  <dan@codesourcery.com>

	* frame.c (get_prev_frame_1): Check PC_REGNUM before using it.


--- ./gdb/frame.c	9 Jan 2007 20:19:15 -0000	1.218
+++ ./gdb/frame.c	11 Jan 2007 17:18:22 -0000	1.219
@@ -1221,10 +1221,17 @@ get_prev_frame_1 (struct frame_info *thi
      have different frame IDs, the new frame will be bogus; two
      functions can't share a register save slot for the PC.  This can
      happen when the prologue analyzer finds a stack adjustment, but
-     no PC save.  This check does assume that the "PC register" is
-     roughly a traditional PC, even if the gdbarch_unwind_pc method
-     frobs it.  */
+     no PC save.
+
+     This check does assume that the "PC register" is roughly a
+     traditional PC, even if the gdbarch_unwind_pc method adjusts
+     it (we do not rely on the value, only on the unwound PC being
+     dependent on this value).  A potential improvement would be
+     to have the frame prev_pc method and the gdbarch unwind_pc
+     method set the same lval and location information as
+     frame_register_unwind.  */
   if (this_frame->level > 0
+      && PC_REGNUM >= 0
       && get_frame_type (this_frame) == NORMAL_FRAME
       && get_frame_type (this_frame->next) == NORMAL_FRAME)
     {


2007-01-20  Daniel Jacobowitz  <dan@codesourcery.com>

	* arch-utils.c (show_endian): Correct reversed condition.


--- ./gdb/arch-utils.c	13 Jan 2007 23:24:43 -0000	1.138
+++ ./gdb/arch-utils.c	20 Jan 2007 18:16:33 -0000
@@ -322,7 +322,7 @@ static void
 show_endian (struct ui_file *file, int from_tty, struct cmd_list_element *c,
 	     const char *value)
 {
-  if (target_byte_order_user != BFD_ENDIAN_UNKNOWN)
+  if (target_byte_order_user == BFD_ENDIAN_UNKNOWN)
     if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
       fprintf_unfiltered (file, _("The target endianness is set automatically "
 				  "(currently big endian)\n"));


https://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=224128


2007-01-26  Jan Kratochvil <jan.kratochvil@redhat.com>

	* c-valprint.c (c_val_print): Require strings to be of no-signed CHARs.
	* NEWS: Describe CHAR array vs. string identifcation rules.

2007-01-26  Jan Kratochvil <jan.kratochvil@redhat.com>
	    Eli Zaretskii  <eliz@gnu.org>

	* gdb.texinfo: Describe CHAR array vs. string identifcation rules.

2007-01-25  Jan Kratochvil <jan.kratochvil@redhat.com>

	* gdb.base/charsign.exp, gdb.base/charsign.c: New files.
	* gdb.arch/i386-sse.exp: Check $xmm.v16_int8 printing as a number array.
	* gdb.base/printcmds.exp: Sign-provided CHARs now became arrays.
	* gdb.base/setvar.exp: Likewise.


--- ./gdb/NEWS	21 Jan 2007 17:48:53 -0000	1.211
+++ ./gdb/NEWS	26 Jan 2007 10:31:48 -0000
@@ -15,6 +15,9 @@ frequency signals (e.g. SIGALRM) via the
 target's overall architecture.  GDB can read a description from
 a local file or over the remote serial protocol.
 
+* Arrays of explicitly SIGNED or UNSIGNED CHARs are now printed as arrays
+  of numbers.
+
 * New commands
 
 set mem inaccessible-by-default
--- ./gdb/c-valprint.c	9 Jan 2007 17:58:50 -0000	1.41
+++ ./gdb/c-valprint.c	26 Jan 2007 10:31:48 -0000
@@ -96,7 +96,7 @@ c_val_print (struct type *type, const gd
 	    }
 	  /* For an array of chars, print with string syntax.  */
 	  if (eltlen == 1 &&
-	      ((TYPE_CODE (elttype) == TYPE_CODE_INT)
+	      ((TYPE_CODE (elttype) == TYPE_CODE_INT && TYPE_NOSIGN (elttype))
 	       || ((current_language->la_language == language_m2)
 		   && (TYPE_CODE (elttype) == TYPE_CODE_CHAR)))
 	      && (format == 0 || format == 's'))
--- ./gdb/doc/gdb.texinfo	26 Jan 2007 08:54:01 -0000	1.380
+++ ./gdb/doc/gdb.texinfo	26 Jan 2007 10:32:00 -0000
@@ -5632,6 +5632,26 @@ If you ask to print an object whose cont
 by the debug information, @value{GDBN} will say @samp{<incomplete
 type>}.  @xref{Symbols, incomplete type}, for more about this.
 
+Strings are identified as arrays of @code{char} values without specified
+signedness.  Arrays of either @code{signed char} or @code{unsigned char} get
+printed as arrays of 1 byte sized integers.  @code{-fsigned-char} or
+@code{-funsigned-char} @value{NGCC} options have no effect as @value{GDBN}
+defines literal string type @code{"char"} as @code{char} without a sign.
+For program code
+
+@smallexample
+char var0[] = "A";
+signed char var1[] = "A";
+@end smallexample
+
+You get during debugging
+@smallexample
+(gdb) print var0
+$1 = "A"
+(gdb) print var1
+$2 = @{65 'A', 0 '\0'@}
+@end smallexample
+
 @node Arrays
 @section Artificial arrays
 
--- ./gdb/testsuite/gdb.arch/i386-sse.exp	9 Jan 2007 17:59:09 -0000	1.5
+++ ./gdb/testsuite/gdb.arch/i386-sse.exp	26 Jan 2007 10:32:00 -0000
@@ -83,7 +83,10 @@ gdb_continue_to_breakpoint "continue to 
 foreach r {0 1 2 3 4 5 6 7} {
     gdb_test "print \$xmm$r.v4_float" \
         ".. = \\{$r, $r.25, $r.5, $r.75\\}.*" \
-        "check contents of %xmm$r"
+        "check float contents of %xmm$r"
+    gdb_test "print \$xmm$r.v16_int8" \
+        ".. = \\{(-?\[0-9\]+ '.*', ){15}-?\[0-9\]+ '.*'\\}.*" \
+        "check int8 contents of %xmm$r"
 }
 
 foreach r {0 1 2 3 4 5 6 7} {
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ ./gdb/testsuite/gdb.base/charsign.c	26 Jan 2007 10:32:00 -0000
@@ -0,0 +1,37 @@
+/* This testcase is part of GDB, the GNU debugger.
+
+   Copyright 2007 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+ 
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+
+   Please email any bugs, comments, and/or additions to this file to:
+   bug-gdb@prep.ai.mit.edu  */
+
+int main()
+{
+  return 0;
+}
+
+char n[]="A";
+signed char s[]="A";
+unsigned char u[]="A";
+
+typedef char char_n;
+typedef signed char char_s;
+typedef unsigned char char_u;
+
+char_n n_typed[]="A";
+char_s s_typed[]="A";
+char_u u_typed[]="A";
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ ./gdb/testsuite/gdb.base/charsign.exp	26 Jan 2007 10:32:00 -0000
@@ -0,0 +1,70 @@
+# Copyright 2007 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+# 
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+# 
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  
+
+if $tracelevel then {
+    strace $tracelevel
+}
+
+set prms_id 0
+set bug_id 0
+
+set testfile charsign
+set srcfile ${testfile}.c
+set binfile ${objdir}/${subdir}/${testfile}
+
+proc do_test { cflags } {
+    global srcdir
+    global binfile
+    global subdir
+    global srcfile
+    global gdb_prompt
+
+    if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable [list debug additional_flags=$cflags]] != "" } {
+	untested "Couldn't compile test program"
+	return -1
+    }
+
+    # Get things started.
+
+    gdb_exit
+    gdb_start
+    gdb_reinitialize_dir $srcdir/$subdir
+    gdb_load ${binfile}
+
+    # For C programs, "start" should stop in main().
+
+    gdb_test "p n" \
+	     "= \"A\""
+    gdb_test "p s" \
+	     "= \\{65 'A', 0 '\\\\0'\\}"
+    gdb_test "p u" \
+	     "= \\{65 'A', 0 '\\\\0'\\}"
+    gdb_test "p n_typed" \
+	     "= \"A\""
+    gdb_test "p s_typed" \
+	     "= \\{65 'A', 0 '\\\\0'\\}"
+    gdb_test "p u_typed" \
+	     "= \\{65 'A', 0 '\\\\0'\\}"
+}
+
+# The string identification works despite the compiler flags below due to
+# gdbtypes.c:
+#   if (name && strcmp (name, "char") == 0)
+#     TYPE_FLAGS (type) |= TYPE_FLAG_NOSIGN;
+
+do_test {}
+do_test {-fsigned-char}
+do_test {-funsigned-char}
--- ./gdb/testsuite/gdb.base/printcmds.exp	9 Jan 2007 17:59:11 -0000	1.14
+++ ./gdb/testsuite/gdb.base/printcmds.exp	26 Jan 2007 10:32:01 -0000
@@ -590,18 +590,18 @@ proc test_print_char_arrays {} {
     gdb_test "set print address on" ""
 
     gdb_test "p arrays" \
-	" = {array1 = \"abc\", array2 = \"d\", array3 = \"e\", array4 = \"fg\", array5 = \"hij\"}"
+	" = \\{array1 = \\{97 'a', 98 'b', 99 'c', 0 '\\\\0'\\}, array2 = \\{100 'd'\\}, array3 = \\{101 'e'\\}, array4 = \\{102 'f', 103 'g'\\}, array5 = \\{104 'h', 105 'i', 106 'j', 0 '\\\\0'\\}\\}"
 
     gdb_test "p parrays"		" = \\(struct some_arrays \\*\\) $hex"
-    gdb_test "p parrays->array1"	" = \"abc\""
+    gdb_test "p parrays->array1"	" = \\{97 'a', 98 'b', 99 'c', 0 '\\\\0'\\}"
     gdb_test "p &parrays->array1"	" = \\(unsigned char \\(\\*\\)\\\[4\\\]\\) $hex"
-    gdb_test "p parrays->array2"	" = \"d\""
+    gdb_test "p parrays->array2"	" = \\{100 'd'\\}"
     gdb_test "p &parrays->array2"	" = \\(unsigned char \\(\\*\\)\\\[1\\\]\\) $hex"
-    gdb_test "p parrays->array3"	" = \"e\""
+    gdb_test "p parrays->array3"	" = \\{101 'e'\\}"
     gdb_test "p &parrays->array3"	" = \\(unsigned char \\(\\*\\)\\\[1\\\]\\) $hex"
-    gdb_test "p parrays->array4"	" = \"fg\""
+    gdb_test "p parrays->array4"	" = \\{102 'f', 103 'g'\\}"
     gdb_test "p &parrays->array4"	" = \\(unsigned char \\(\\*\\)\\\[2\\\]\\) $hex"
-    gdb_test "p parrays->array5"	" = \"hij\""
+    gdb_test "p parrays->array5"	" = \\{104 'h', 105 'i', 106 'j', 0 '\\\\0'\\}"
     gdb_test "p &parrays->array5"	" = \\(unsigned char \\(\\*\\)\\\[4\\\]\\) $hex"
 
     gdb_test "set print address off" ""
--- ./gdb/testsuite/gdb.base/setvar.exp	9 Jan 2007 17:59:11 -0000	1.10
+++ ./gdb/testsuite/gdb.base/setvar.exp	26 Jan 2007 10:32:01 -0000
@@ -233,11 +233,11 @@ test_set "set variable v_char_array\[0\]
 #
 # test "set variable" for "signed char array[2]"
 #
-test_set "set variable v_signed_char_array\[0\]='h'" "set variable v_signed_char_array\[1\]='i'" "print v_signed_char_array" ".*.\[0-9\]* =.*\"hi\""        "set variable signed char array=\"hi\" (string)" 
+test_set "set variable v_signed_char_array\[0\]='h'" "set variable v_signed_char_array\[1\]='i'" "print v_signed_char_array" ".*.\[0-9\]* =.*\\{104 'h', 105 'i'\\}"        "set variable signed char array=\"hi\" (string)" 
 #
 # test "set variable" for "unsigned char array[2]"
 #
-test_set "set variable v_unsigned_char_array\[0\]='h'" "set variable v_unsigned_char_array\[1\]='i'" "print v_unsigned_char_array" ".*.\[0-9\]* =.*\"hi\""        "set variable unsigned char array=\"hi\" (string)" 
+test_set "set variable v_unsigned_char_array\[0\]='h'" "set variable v_unsigned_char_array\[1\]='i'" "print v_unsigned_char_array" ".*.\[0-9\]* =.*\\{104 'h', 105 'i'\\}"        "set variable unsigned char array=\"hi\" (string)" 
 #
 # test "set variable" for "short array[2]"
 #
@@ -289,11 +289,11 @@ test_set "set v_char_pointer=v_char_arra
 #
 # test "set variable" for type "signed char *"
 #
-test_set "set v_signed_char_pointer=v_signed_char_array" "set variable *(v_signed_char_pointer)='h'" "set variable *(v_signed_char_pointer+1)='i'" "print v_signed_char_array" ".*.\[0-9\]* =.*\"hi\""  "print *(v_signed_char_pointer+1)" ".*.\[0-9\]* = 105 \'i\'"     "set variable signed char pointer=\"hi\" (string)" 
+test_set "set v_signed_char_pointer=v_signed_char_array" "set variable *(v_signed_char_pointer)='h'" "set variable *(v_signed_char_pointer+1)='i'" "print v_signed_char_array" ".*.\[0-9\]* =.*\\{104 'h', 105 'i'\\}"  "print *(v_signed_char_pointer+1)" ".*.\[0-9\]* = 105 \'i\'"     "set variable signed char pointer=\"hi\" (string)" 
 #
 # test "set variable" for type "unsigned char *"
 #
-test_set "set v_unsigned_char_pointer=v_unsigned_char_array" "set variable *(v_unsigned_char_pointer)='h'" "set variable *(v_unsigned_char_pointer+1)='i'" "print v_unsigned_char_array" ".*.\[0-9\]* =.*\"hi\""  "print *(v_unsigned_char_pointer+1)" ".*.\[0-9\]* = 105 \'i\'"     "set variable unsigned char pointer=\"hi\" (string)" 
+test_set "set v_unsigned_char_pointer=v_unsigned_char_array" "set variable *(v_unsigned_char_pointer)='h'" "set variable *(v_unsigned_char_pointer+1)='i'" "print v_unsigned_char_array" ".*.\[0-9\]* =.*\\{104 'h', 105 'i'\\}"  "print *(v_unsigned_char_pointer+1)" ".*.\[0-9\]* = 105 \'i\'"     "set variable unsigned char pointer=\"hi\" (string)" 
 #
 # test "set variable" for type "short *"
 #


https://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=209445


[ backported ]
2006-12-31  Daniel Jacobowitz  <dan@codesourcery.com>

        * linux-nat.c (lin_lwp_attach_lwp): Return a status.  Do not
        add the LWP to our list until we are attached.  Warn instead
        of erroring if the attach fails.
        * linux-nat.h (lin_lwp_attach_lwp): New prototype.
        * linux-thread-db.c (attach_thread): Call lin_lwp_attach_lwp
        directly.  Do not add the thread to our list until we are
        successfully attached.
        * config/nm-linux.h (lin_lwp_attach_lwp, ATTACH_LWP): Delete.


--- ./gdb/linux-nat.c	20 Nov 2006 21:47:06 -0000	1.51
+++ ./gdb/linux-nat.c	31 Dec 2006 21:04:51 -0000	1.52
@@ -915,12 +915,13 @@ exit_lwp (struct lwp_info *lp)
 
 /* Attach to the LWP specified by PID.  If VERBOSE is non-zero, print
    a message telling the user that a new LWP has been added to the
-   process.  */
+   process.  Return 0 if successful or -1 if the new LWP could not
+   be attached.  */
 
-void
+int
 lin_lwp_attach_lwp (ptid_t ptid, int verbose)
 {
-  struct lwp_info *lp, *found_lp;
+  struct lwp_info *lp;
 
   gdb_assert (is_lwp (ptid));
 
@@ -932,12 +933,7 @@ lin_lwp_attach_lwp (ptid_t ptid, int ver
       sigprocmask (SIG_BLOCK, &blocked_mask, NULL);
     }
 
-  if (verbose)
-    printf_filtered (_("[New %s]\n"), target_pid_to_str (ptid));
-
-  found_lp = lp = find_lwp_pid (ptid);
-  if (lp == NULL)
-    lp = add_lwp (ptid);
+  lp = find_lwp_pid (ptid);
 
   /* We assume that we're already attached to any LWP that has an id
      equal to the overall process id, and to any LWP that is already
@@ -945,14 +941,25 @@ lin_lwp_attach_lwp (ptid_t ptid, int ver
      and we've had PID wraparound since we last tried to stop all threads,
      this assumption might be wrong; fortunately, this is very unlikely
      to happen.  */
-  if (GET_LWP (ptid) != GET_PID (ptid) && found_lp == NULL)
+  if (GET_LWP (ptid) != GET_PID (ptid) && lp == NULL)
     {
       pid_t pid;
       int status;
 
       if (ptrace (PTRACE_ATTACH, GET_LWP (ptid), 0, 0) < 0)
-	error (_("Can't attach %s: %s"), target_pid_to_str (ptid),
-	       safe_strerror (errno));
+	{
+	  /* If we fail to attach to the thread, issue a warning,
+	     but continue.  One way this can happen is if thread
+	     creation is interrupted; as of Linux 2.6.19, a kernel
+	     bug may place threads in the thread list and then fail
+	     to create them.  */
+	  warning (_("Can't attach %s: %s"), target_pid_to_str (ptid),
+		   safe_strerror (errno));
+	  return -1;
+	}
+
+      if (lp == NULL)
+	lp = add_lwp (ptid);
 
       if (debug_linux_nat)
 	fprintf_unfiltered (gdb_stdlog,
@@ -990,8 +997,15 @@ lin_lwp_attach_lwp (ptid_t ptid, int ver
          threads.  Note that this won't have already been done since
          the main thread will have, we assume, been stopped by an
          attach from a different layer.  */
+      if (lp == NULL)
+	lp = add_lwp (ptid);
       lp->stopped = 1;
     }
+
+  if (verbose)
+    printf_filtered (_("[New %s]\n"), target_pid_to_str (ptid));
+
+  return 0;
 }
 
 static void
--- ./gdb/linux-nat.h	20 Nov 2006 21:47:06 -0000	1.13
+++ ./gdb/linux-nat.h	31 Dec 2006 21:04:51 -0000	1.14
@@ -80,6 +80,8 @@ extern void linux_enable_event_reporting
 extern ptid_t linux_handle_extended_wait (int pid, int status,
 					  struct target_waitstatus *ourstatus);
 
+extern int lin_lwp_attach_lwp (ptid_t ptid, int verbose);
+
 /* Iterator function for lin-lwp's lwp list.  */
 struct lwp_info *iterate_over_lwps (int (*callback) (struct lwp_info *, 
 						     void *), 
--- ./gdb/config/nm-linux.h	28 Nov 2006 19:45:07 -0000	1.27
+++ ./gdb/config/nm-linux.h	31 Dec 2006 21:04:51 -0000	1.28
@@ -1,6 +1,6 @@
 /* Native support for GNU/Linux.
 
-   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005
+   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
    Free Software Foundation, Inc.
 
    This file is part of GDB.
@@ -25,9 +25,6 @@ struct target_ops;
 /* GNU/Linux is SVR4-ish but its /proc file system isn't.  */
 #undef USE_PROC_FS
 
-extern void lin_lwp_attach_lwp (ptid_t ptid, int verbose);
-#define ATTACH_LWP(ptid, verbose) lin_lwp_attach_lwp ((ptid), (verbose))
-
 extern void lin_thread_get_thread_signals (sigset_t *mask);
 #define GET_THREAD_SIGNALS(mask) lin_thread_get_thread_signals (mask)
 
--- gdb-6.6/gdb-orig/linux-thread-db.c	2007-01-30 14:10:38.000000000 -0500
+++ gdb-6.6/gdb/linux-thread-db.c	2007-01-30 14:16:22.000000000 -0500
@@ -678,6 +678,13 @@
 
   check_thread_signals ();
 
+  if (ti_p->ti_state == TD_THR_UNKNOWN || ti_p->ti_state == TD_THR_ZOMBIE)
+    return;			/* A zombie thread -- do not attach.  */
+
+  /* Under GNU/Linux, we have to attach to each and every thread.  */
+  if (lin_lwp_attach_lwp (BUILD_LWP (ti_p->ti_lid, GET_PID (ptid)), 0) < 0)
+    return;
+
   /* Add the thread to GDB's thread list.  */
   tp = add_thread (ptid);
   tp->private = xmalloc (sizeof (struct private_thread_info));
@@ -686,20 +693,10 @@
   if (verbose)
     printf_unfiltered (_("[New %s]\n"), target_pid_to_str (ptid));
 
-  if (ti_p->ti_state == TD_THR_UNKNOWN || ti_p->ti_state == TD_THR_ZOMBIE)
-    return;			/* A zombie thread -- do not attach.  */
-
-  new_ptid = BUILD_LWP (ti_p->ti_lid, GET_PID (ptid));
-
-  /* Under GNU/Linux, we have to attach to each and every thread.  */
-#ifdef ATTACH_LWP
-  ATTACH_LWP (new_ptid, 0);
-#endif
-
   /* Notify any observers of a new linux thread.  This
      would include any linux platforms that have to insert hardware
      watchpoints on every thread.  */
-  observer_notify_linux_new_thread (new_ptid);
+  observer_notify_linux_new_thread (BUILD_LWP (ti_p->ti_lid, GET_PID (ptid)));
 
   /* Enable thread event reporting for this thread.  */
   err = td_thr_event_enable_p (th_p, 1);


https://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=230000


2007-02-08  Thiago Jung Bauermann  <bauerman@br.ibm.com>

	* rs6000-tdep.c (gdb_print_insn_powerpc): Set
	info->disassembler_options to "any".


--- ./gdb/rs6000-tdep.c	8 Feb 2007 14:22:53 -0000	1.261
+++ ./gdb/rs6000-tdep.c	8 Feb 2007 18:05:23 -0000	1.262
@@ -2924,6 +2924,9 @@ find_variant_by_arch (enum bfd_architect
 static int
 gdb_print_insn_powerpc (bfd_vma memaddr, disassemble_info *info)
 {
+  if (!info->disassembler_options)
+    info->disassembler_options = "any";
+
   if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
     return print_insn_big_powerpc (memaddr, info);
   else


https://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=232353


2007-01-27  Daniel Jacobowitz  <dan@codesourcery.com>

	* dwarf2loc.h (struct dwarf2_locexpr_baton): Change size to a long.
	(struct dwarf2_loclist_baton): Likewise.


--- ./gdb/dwarf2loc.h	17 Dec 2005 22:33:59 -0000	1.6
+++ ./gdb/dwarf2loc.h	5 Jan 2007 15:31:17 -0000
@@ -39,7 +39,7 @@ struct dwarf2_locexpr_baton
   gdb_byte *data;
 
   /* Length of the location expression.  */
-  unsigned short size;
+  unsigned long size;
 
   /* The objfile containing the symbol whose location we're computing.  */
   struct objfile *objfile;
@@ -55,7 +55,7 @@ struct dwarf2_loclist_baton
   gdb_byte *data;
 
   /* Length of the location list.  */
-  unsigned short size;
+  unsigned long size;
 
   /* The objfile containing the symbol whose location we're computing.  */
   /* Used (only???) by thread local variables.  The objfile in which


https://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=230000


Fixes embarrassing errors in the ppc dfp instructions committed some
time ago.  IBM numbers bits in architecture manuals starting from zero
in the most signifigant bit.  Fields are marked by numbering their
most signifigant bit too.  This means some translating is required when
filling out new powerpc_operand entries.  You can't just plug IBM
numbers into the shift counts.  Also, Z_MASK is too big for
instructions that take RMC operands.

	* ppc-opc.c (DCM, DGM, TE, RMC, R, SP, S): Correct shift.
	(Z2_MASK): Define.
	(powerpc_opcodes): Use Z2_MASK in all insns taking RMC operand.

--- ./opcodes/ppc-opc.c	19 Apr 2007 01:39:31 -0000	1.91
+++ ./opcodes/ppc-opc.c	20 Apr 2007 09:52:09 -0000
@@ -530,8 +530,9 @@ const struct powerpc_operand powerpc_ope
 #define SIMM VD + 1
   { 5, 16, NULL, NULL, PPC_OPERAND_SIGNED},
 
-  /* The UIMM field in a VX form instruction.  */
+  /* The UIMM field in a VX form instruction, and TE in Z form.  */
 #define UIMM SIMM + 1
+#define TE UIMM
   { 5, 16, NULL, NULL, 0 },
 
   /* The SHB field in a VA form instruction.  */
@@ -564,31 +565,23 @@ const struct powerpc_operand powerpc_ope
 #define A_L MTMSRD_L
   { 1, 16, NULL, NULL, PPC_OPERAND_OPTIONAL },
 
-  /* The DCM field in a Z form instruction.  */
-#define DCM MTMSRD_L + 1
-  { 6, 16, NULL, NULL, 0 },
-
-  /* Likewise, the DGM field in a Z form instruction.  */
-#define DGM DCM + 1
-  { 6, 16, NULL, NULL, 0 },
-
-#define TE DGM + 1
-  { 5, 11, NULL, NULL, 0 },
-
-#define RMC TE + 1
-  { 2, 21, NULL, NULL, 0 },
+#define RMC A_L + 1
+  { 2, 9, NULL, NULL, 0 },
 
 #define R RMC + 1
-  { 1, 15, NULL, NULL, 0 },
+  { 1, 16, NULL, NULL, 0 },
 
 #define SP R + 1
-  { 2, 11, NULL, NULL, 0 },
+  { 2, 19, NULL, NULL, 0 },
 
 #define S SP + 1
-  { 1, 11, NULL, NULL, 0 },
+  { 1, 20, NULL, NULL, 0 },
 
   /* SH field starting at bit position 16.  */
 #define SH16 S + 1
+  /* The DCM and DGM fields in a Z form instruction.  */
+#define DCM SH16
+#define DGM DCM
   { 6, 10, NULL, NULL, 0 },
 
   /* The L field in an X form with the RT field fixed instruction.  */
@@ -1683,6 +1676,7 @@ extract_tbr (unsigned long insn,
 
 /* The mask for a Z form instruction.  */
 #define Z_MASK ZRC (0x3f, 0x1ff, 1)
+#define Z2_MASK ZRC (0x3f, 0xff, 1)
 
 /* An X_MASK with the RA field fixed.  */
 #define XRA_MASK (X_MASK | RA_MASK)
@@ -4639,8 +4633,8 @@ const struct powerpc_opcode powerpc_opco
 { "dadd",    XRC(59,2,0), X_MASK,	POWER6,		{ FRT, FRA, FRB } },
 { "dadd.",   XRC(59,2,1), X_MASK,	POWER6,		{ FRT, FRA, FRB } },
 
-{ "dqua",    ZRC(59,3,0), Z_MASK,	POWER6,		{ FRT, FRA, FRB, RMC } },
-{ "dqua.",   ZRC(59,3,1), Z_MASK,	POWER6,		{ FRT, FRA, FRB, RMC } },
+{ "dqua",    ZRC(59,3,0), Z2_MASK,	POWER6,		{ FRT, FRA, FRB, RMC } },
+{ "dqua.",   ZRC(59,3,1), Z2_MASK,	POWER6,		{ FRT, FRA, FRB, RMC } },
 
 { "fdivs",   A(59,18,0), AFRC_MASK,	PPC,		{ FRT, FRA, FRB } },
 { "fdivs.",  A(59,18,1), AFRC_MASK,	PPC,		{ FRT, FRA, FRB } },
@@ -4678,20 +4672,20 @@ const struct powerpc_opcode powerpc_opco
 { "dmul",    XRC(59,34,0), X_MASK,	POWER6,		{ FRT, FRA, FRB } },
 { "dmul.",   XRC(59,34,1), X_MASK,	POWER6,		{ FRT, FRA, FRB } },
 
-{ "drrnd",   ZRC(59,35,0), Z_MASK,	POWER6,		{ FRT, FRA, FRB, RMC } },
-{ "drrnd.",  ZRC(59,35,1), Z_MASK,	POWER6,		{ FRT, FRA, FRB, RMC } },
+{ "drrnd",   ZRC(59,35,0), Z2_MASK,	POWER6,		{ FRT, FRA, FRB, RMC } },
+{ "drrnd.",  ZRC(59,35,1), Z2_MASK,	POWER6,		{ FRT, FRA, FRB, RMC } },
 
 { "dscli",   ZRC(59,66,0), Z_MASK,	POWER6,		{ FRT, FRA, SH16 } },
 { "dscli.",  ZRC(59,66,1), Z_MASK,	POWER6,		{ FRT, FRA, SH16 } },
 
-{ "dquai",   ZRC(59,67,0), Z_MASK,	POWER6,		{ TE,  FRT, FRB, RMC } },
-{ "dquai.",  ZRC(59,67,1), Z_MASK,	POWER6,		{ TE,  FRT, FRB, RMC } },
+{ "dquai",   ZRC(59,67,0), Z2_MASK,	POWER6,		{ TE,  FRT, FRB, RMC } },
+{ "dquai.",  ZRC(59,67,1), Z2_MASK,	POWER6,		{ TE,  FRT, FRB, RMC } },
 
 { "dscri",   ZRC(59,98,0), Z_MASK,	POWER6,		{ FRT, FRA, SH16 } },
 { "dscri.",  ZRC(59,98,1), Z_MASK,	POWER6,		{ FRT, FRA, SH16 } },
 
-{ "drintx",  ZRC(59,99,0), Z_MASK,	POWER6,		{ R, FRT, FRB, RMC } },
-{ "drintx.", ZRC(59,99,1), Z_MASK,	POWER6,		{ R, FRT, FRB, RMC } },
+{ "drintx",  ZRC(59,99,0), Z2_MASK,	POWER6,		{ R, FRT, FRB, RMC } },
+{ "drintx.", ZRC(59,99,1), Z2_MASK,	POWER6,		{ R, FRT, FRB, RMC } },
 
 { "dcmpo",   X(59,130),	   X_MASK,	POWER6,		{ BF,  FRA, FRB } },
 
@@ -4699,8 +4693,8 @@ const struct powerpc_opcode powerpc_opco
 { "dtstdc",  Z(59,194),	   Z_MASK,	POWER6,		{ BF,  FRA, DCM } },
 { "dtstdg",  Z(59,226),	   Z_MASK,	POWER6,		{ BF,  FRA, DGM } },
 
-{ "drintn",  ZRC(59,227,0), Z_MASK,	POWER6,		{ R, FRT, FRB, RMC } },
-{ "drintn.", ZRC(59,227,1), Z_MASK,	POWER6,		{ R, FRT, FRB, RMC } },
+{ "drintn",  ZRC(59,227,0), Z2_MASK,	POWER6,		{ R, FRT, FRB, RMC } },
+{ "drintn.", ZRC(59,227,1), Z2_MASK,	POWER6,		{ R, FRT, FRB, RMC } },
 
 { "dctdp",   XRC(59,258,0), X_MASK,	POWER6,		{ FRT, FRB } },
 { "dctdp.",  XRC(59,258,1), X_MASK,	POWER6,		{ FRT, FRB } },
@@ -4766,8 +4760,8 @@ const struct powerpc_opcode powerpc_opco
 { "daddq",   XRC(63,2,0), X_MASK,	POWER6,		{ FRT, FRA, FRB } },
 { "daddq.",  XRC(63,2,1), X_MASK,	POWER6,		{ FRT, FRA, FRB } },
 
-{ "dquaq",   ZRC(63,3,0), Z_MASK,	POWER6,		{ FRT, FRA, FRB, RMC } },
-{ "dquaq.",  ZRC(63,3,1), Z_MASK,	POWER6,		{ FRT, FRA, FRB, RMC } },
+{ "dquaq",   ZRC(63,3,0), Z2_MASK,	POWER6,		{ FRT, FRA, FRB, RMC } },
+{ "dquaq.",  ZRC(63,3,1), Z2_MASK,	POWER6,		{ FRT, FRA, FRB, RMC } },
 
 { "fcpsgn",  XRC(63,8,0), X_MASK,	POWER6,		{ FRT, FRA, FRB } },
 { "fcpsgn.", XRC(63,8,1), X_MASK,	POWER6,		{ FRT, FRA, FRB } },
@@ -4842,8 +4836,8 @@ const struct powerpc_opcode powerpc_opco
 { "dmulq",   XRC(63,34,0), X_MASK,	POWER6,		{ FRT, FRA, FRB } },
 { "dmulq.",  XRC(63,34,1), X_MASK,	POWER6,		{ FRT, FRA, FRB } },
 
-{ "drrndq",  ZRC(63,35,0), Z_MASK,	POWER6,		{ FRT, FRA, FRB, RMC } },
-{ "drrndq.", ZRC(63,35,1), Z_MASK,	POWER6,		{ FRT, FRA, FRB, RMC } },
+{ "drrndq",  ZRC(63,35,0), Z2_MASK,	POWER6,		{ FRT, FRA, FRB, RMC } },
+{ "drrndq.", ZRC(63,35,1), Z2_MASK,	POWER6,		{ FRT, FRA, FRB, RMC } },
 
 { "mtfsb1",  XRC(63,38,0), XRARB_MASK,	COM,		{ BT } },
 { "mtfsb1.", XRC(63,38,1), XRARB_MASK,	COM,		{ BT } },
@@ -4856,8 +4850,8 @@ const struct powerpc_opcode powerpc_opco
 { "dscliq",  ZRC(63,66,0), Z_MASK,	POWER6,		{ FRT, FRA, SH16 } },
 { "dscliq.", ZRC(63,66,1), Z_MASK,	POWER6,		{ FRT, FRA, SH16 } },
 
-{ "dquaiq",  ZRC(63,67,0), Z_MASK,	POWER6,		{ TE,  FRT, FRB, RMC } },
-{ "dquaiq.", ZRC(63,67,1), Z_MASK,	POWER6,		{ FRT, FRA, FRB, RMC } },
+{ "dquaiq",  ZRC(63,67,0), Z2_MASK,	POWER6,		{ TE,  FRT, FRB, RMC } },
+{ "dquaiq.", ZRC(63,67,1), Z2_MASK,	POWER6,		{ FRT, FRA, FRB, RMC } },
 
 { "mtfsb0",  XRC(63,70,0), XRARB_MASK,	COM,		{ BT } },
 { "mtfsb0.", XRC(63,70,1), XRARB_MASK,	COM,		{ BT } },
@@ -4868,8 +4862,8 @@ const struct powerpc_opcode powerpc_opco
 { "dscriq",  ZRC(63,98,0), Z_MASK,	POWER6,		{ FRT, FRA, SH16 } },
 { "dscriq.", ZRC(63,98,1), Z_MASK,	POWER6,		{ FRT, FRA, SH16 } },
 
-{ "drintxq", ZRC(63,99,0), Z_MASK,	POWER6,		{ R, FRT, FRB, RMC } },
-{ "drintxq.",ZRC(63,99,1), Z_MASK,	POWER6,		{ R, FRT, FRB, RMC } },
+{ "drintxq", ZRC(63,99,0), Z2_MASK,	POWER6,		{ R, FRT, FRB, RMC } },
+{ "drintxq.",ZRC(63,99,1), Z2_MASK,	POWER6,		{ R, FRT, FRB, RMC } },
 
 { "dcmpoq",  X(63,130),	   X_MASK,	POWER6,		{ BF,  FRA, FRB } },
 
@@ -4883,8 +4877,8 @@ const struct powerpc_opcode powerpc_opco
 { "dtstdcq", Z(63,194),	    Z_MASK,	POWER6,		{ BF,  FRA, DCM } },
 { "dtstdgq", Z(63,226),	    Z_MASK,	POWER6,		{ BF,  FRA, DGM } },
 
-{ "drintnq", ZRC(63,227,0), Z_MASK,	POWER6,		{ R, FRT, FRB, RMC } },
-{ "drintnq.",ZRC(63,227,1), Z_MASK,	POWER6,		{ R, FRT, FRB, RMC } },
+{ "drintnq", ZRC(63,227,0), Z2_MASK,	POWER6,		{ R, FRT, FRB, RMC } },
+{ "drintnq.",ZRC(63,227,1), Z2_MASK,	POWER6,		{ R, FRT, FRB, RMC } },
 
 { "dctqpq",  XRC(63,258,0), X_MASK,	POWER6,		{ FRT, FRB } },
 { "dctqpq.", XRC(63,258,1), X_MASK,	POWER6,		{ FRT, FRB } },

-- 
Alan Modra
IBM OzLabs - Linux Technology Centre
