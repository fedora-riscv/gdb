https://bugzilla.redhat.com/bugzilla/show_bug.cgi?id=181390


2006-09-28  Jan Kratochvil  <jan.kratochvil@redhat.com>

	* gdb/utils.c (paddress): Disable cutting of the printed addresses
	to the target's address bit size; user wants to see everything.
	* gdb/value.c (value_as_address_core): Original `value_as_address'.
	(value_as_address): New `value_as_address' wrapper - cut memory address
	to the target's address bit size, bugreport by John Reiser.


Index: gdb-6.5/gdb/utils.c
===================================================================
RCS file: /cvs/src/src/gdb/utils.c,v
retrieving revision 1.169
diff -u -p -r1.169 utils.c
--- gdb-6.5.orig/gdb/utils.c	21 Sep 2006 13:50:51 -0000	1.169
+++ gdb-6.5/gdb/utils.c	28 Sep 2006 17:06:03 -0000
@@ -2596,6 +2596,14 @@ paddr_nz (CORE_ADDR addr)
 const char *
 paddress (CORE_ADDR addr)
 {
+  /* Do not cut the address as the user should see all the information
+     available.  Otherwise 64-bit gdb debugging 32-bit inferior would
+     report for `x/x 0xffffffffffffce70' error
+     `Cannot access memory at 0xffffce70' while the error occured just
+     because of the higher order bits 0xffffffff00000000 there.
+     This specific error no longer occurs as the address is now cut
+     during execution by `value_as_address'.  */
+#if 0
   /* Truncate address to the size of a target address, avoiding shifts
      larger or equal than the width of a CORE_ADDR.  The local
      variable ADDR_BIT stops the compiler reporting a shift overflow
@@ -2609,6 +2617,8 @@ paddress (CORE_ADDR addr)
 
   if (addr_bit < (sizeof (CORE_ADDR) * HOST_CHAR_BIT))
     addr &= ((CORE_ADDR) 1 << addr_bit) - 1;
+#endif
+
   return hex_string (addr);
 }
 
Index: gdb-6.5/gdb/value.c
===================================================================
RCS file: /cvs/src/src/gdb/value.c,v
retrieving revision 1.36
diff -u -p -r1.36 value.c
--- gdb-6.5.orig/gdb/value.c	31 Mar 2006 10:36:18 -0000	1.36
+++ gdb-6.5/gdb/value.c	28 Sep 2006 17:06:03 -0000
@@ -950,11 +950,10 @@ value_as_double (struct value *val)
     error (_("Invalid floating value found in program."));
   return foo;
 }
-/* Extract a value as a C pointer. Does not deallocate the value.  
-   Note that val's type may not actually be a pointer; value_as_long
-   handles all the cases.  */
-CORE_ADDR
-value_as_address (struct value *val)
+
+/* See `value_as_address' below - core of value to C pointer extraction.  */
+static CORE_ADDR
+value_as_address_core (struct value *val)
 {
   /* Assume a CORE_ADDR can fit in a LONGEST (for now).  Not sure
      whether we want this to be true eventually.  */
@@ -1054,6 +1053,33 @@ value_as_address (struct value *val)
   return unpack_long (value_type (val), value_contents (val));
 #endif
 }
+
+/* Extract a value as a C pointer. Does not deallocate the value.  
+   Note that val's type may not actually be a pointer; value_as_long
+   handles all the cases.  */
+CORE_ADDR
+value_as_address (struct value *val)
+{
+  CORE_ADDR addr;
+
+  addr = value_as_address_core (val);
+
+  /* Truncate address to the size of a target address, avoiding shifts
+     larger or equal than the width of a CORE_ADDR.  The local
+     variable ADDR_BIT stops the compiler reporting a shift overflow
+     when it won't occur. */
+  /* NOTE: This assumes that the significant address information is
+     kept in the least significant bits of ADDR - the upper bits were
+     either zero or sign extended.  Should ADDRESS_TO_POINTER() or
+     some ADDRESS_TO_PRINTABLE() be used to do the conversion?  */
+
+  int addr_bit = TARGET_ADDR_BIT;
+
+  if (addr_bit < (sizeof (CORE_ADDR) * HOST_CHAR_BIT))
+    addr &= ((CORE_ADDR) 1 << addr_bit) - 1;
+
+  return addr;
+}
 
 /* Unpack raw data (copied from debugee, target byte order) at VALADDR
    as a long, or as a double, assuming the raw data is described
