Fix i386-on-x86_64 debugging giving the warning:
	warning: Lowest section in system-supplied DSO at 0xffffe000 is .hash at ffffe0b4

[ Backport for RH GDB-6.6. ]

--- gdb-6.6/gdb/symfile.c	2007-10-08 19:52:06.000000000 +0200
+++ gdb-6.6/gdb/symfile.c	2007-10-08 19:49:27.000000000 +0200
@@ -597,6 +597,37 @@ default_symfile_offsets (struct objfile 
   init_objfile_sect_indices (objfile);
 }
 
+/* Find lowest loadable section to be used as starting point for continguous
+   sections. FIXME!! won't work without call to find .text first, but this
+   assumes text is lowest section.  vDSO was seen for i386-on-amd64 processes
+   to have no `.text' as it has `.text.vsyscall', `.text.sigreturn' etc.
+   instead.  Execution of this function has been delayed till it is really
+   needed as it is broken for vDSOs, fortunately it is never needed on
+   GNU/Linux.  */
+
+static CORE_ADDR
+find_lower_offset (struct objfile *objfile)
+{
+  asection *lower_sect;
+
+  lower_sect = bfd_get_section_by_name (objfile->obfd, ".text");
+  if (lower_sect == NULL)
+    bfd_map_over_sections (objfile->obfd, find_lowest_section,
+			   &lower_sect);
+  if (lower_sect == NULL)
+    warning (_("no loadable sections found in added symbol-file %s"),
+	     objfile->name);
+  else
+    if ((bfd_get_section_flags (objfile->obfd, lower_sect) & SEC_CODE) == 0)
+      warning (_("Lowest section in %s is %s at %s"),
+	       objfile->name,
+	       bfd_section_name (objfile->obfd, lower_sect),
+	       paddr (bfd_section_vma (objfile->obfd, lower_sect)));
+  if (lower_sect != NULL)
+    return bfd_section_vma (objfile->obfd, lower_sect);
+  else
+    return 0;
+}
 
 /* Process a symbol file, as either the main file or as a dynamically
    loaded file.
@@ -696,32 +727,11 @@ syms_from_objfile (struct objfile *objfi
      happens for the PA64 port.  */
   if (/*!mainline &&*/ addrs && addrs->other[0].name)
     {
-      asection *lower_sect;
       asection *sect;
-      CORE_ADDR lower_offset;
+      CORE_ADDR lower_offset = 0;	/* Shut up the GCC warning.  */
+      int lower_offset_set = 0;
       int i;
 
-      /* Find lowest loadable section to be used as starting point for
-         continguous sections. FIXME!! won't work without call to find
-	 .text first, but this assumes text is lowest section. */
-      lower_sect = bfd_get_section_by_name (objfile->obfd, ".text");
-      if (lower_sect == NULL)
-	bfd_map_over_sections (objfile->obfd, find_lowest_section,
-			       &lower_sect);
-      if (lower_sect == NULL)
-	warning (_("no loadable sections found in added symbol-file %s"),
-		 objfile->name);
-      else
-	if ((bfd_get_section_flags (objfile->obfd, lower_sect) & SEC_CODE) == 0)
-	  warning (_("Lowest section in %s is %s at %s"),
-		   objfile->name,
-		   bfd_section_name (objfile->obfd, lower_sect),
-		   paddr (bfd_section_vma (objfile->obfd, lower_sect)));
-      if (lower_sect != NULL)
- 	lower_offset = bfd_section_vma (objfile->obfd, lower_sect);
-      else
- 	lower_offset = 0;
-
       /* Calculate offsets for the loadable sections.
  	 FIXME! Sections must be in order of increasing loadable section
  	 so that contiguous sections can use the lower-offset!!!
@@ -743,6 +753,7 @@ syms_from_objfile (struct objfile *objfi
                     addrs->other[i].addr
                       -= bfd_section_vma (objfile->obfd, sect);
                     lower_offset = addrs->other[i].addr;
+		    lower_offset_set = 1;
                     /* This is the index used by BFD. */
                     addrs->other[i].sectindex = sect->index ;
                   }
@@ -755,7 +766,17 @@ syms_from_objfile (struct objfile *objfi
                   }
               }
             else
-              addrs->other[i].addr = lower_offset;
+	      {
+		/* Delay finding LOWER_OFFSET only if it is needed.  Otherwise
+		   we would print a warning to detect a values never used.  */
+		if (!lower_offset_set)
+		  {
+		    lower_offset = find_lower_offset (objfile);
+		    lower_offset_set = 1;
+		  }
+
+		addrs->other[i].addr = lower_offset;
+	      }
           }
     }
 
