http://sourceware.org/ml/gdb-cvs/2012-07/msg00182.html

### src/gdb/ChangeLog	2012/07/23 15:25:11	1.14514
### src/gdb/ChangeLog	2012/07/23 18:08:27	1.14515
## -1,3 +1,9 @@
+2012-07-23  Siddhesh Poyarekar  <siddhesh@redhat.com>
+
+	* p-valprint.c (pascal_object_print_value): Replace potentially
+	unsafe alloca with xmalloc/xfree.
+	* valops.c (search_struct_method): Likewise.
+
 2012-07-23  Tom Tromey  <tromey@redhat.com>
 
 	* solib-svr4.c (enable_break): Update.
--- src/gdb/p-valprint.c	2012/05/18 21:02:49	1.100
+++ src/gdb/p-valprint.c	2012/07/23 18:08:29	1.101
@@ -797,8 +797,11 @@
 
 	  if (boffset < 0 || boffset >= TYPE_LENGTH (type))
 	    {
-	      /* FIXME (alloc): not safe is baseclass is really really big. */
-	      gdb_byte *buf = alloca (TYPE_LENGTH (baseclass));
+	      gdb_byte *buf;
+	      struct cleanup *back_to;
+
+	      buf = xmalloc (TYPE_LENGTH (baseclass));
+	      back_to = make_cleanup (xfree, buf);
 
 	      base_valaddr = buf;
 	      if (target_read_memory (address + boffset, buf,
@@ -807,6 +810,7 @@
 	      address = address + boffset;
 	      thisoffset = 0;
 	      boffset = 0;
+	      do_cleanups (back_to);
 	    }
 	  else
 	    base_valaddr = valaddr;
--- src/gdb/valops.c	2012/06/24 07:28:10	1.297
+++ src/gdb/valops.c	2012/07/23 18:08:29	1.298
@@ -2281,8 +2281,13 @@
 
 	  if (offset < 0 || offset >= TYPE_LENGTH (type))
 	    {
-	      gdb_byte *tmp = alloca (TYPE_LENGTH (baseclass));
-	      CORE_ADDR address = value_address (*arg1p);
+	      gdb_byte *tmp;
+	      struct cleanup *back_to;
+	      CORE_ADDR address;
+
+	      tmp = xmalloc (TYPE_LENGTH (baseclass));
+	      back_to = make_cleanup (xfree, tmp);
+	      address = value_address (*arg1p);
 
 	      if (target_read_memory (address + offset,
 				      tmp, TYPE_LENGTH (baseclass)) != 0)
@@ -2293,6 +2298,7 @@
 							  address + offset);
 	      base_valaddr = value_contents_for_printing (base_val);
 	      this_offset = 0;
+	      do_cleanups (back_to);
 	    }
 	  else
 	    {
