http://sourceware.org/ml/gdb-cvs/2012-09/msg00142.html

### src/gdb/ChangeLog	2012/09/25 12:38:55	1.14696
### src/gdb/ChangeLog	2012/09/25 12:48:52	1.14697
## -1,3 +1,36 @@
+2012-09-25  Siddhesh Poyarekar  <siddhesh@redhat.com>
+
+	* ada-valprint.c (ada_val_print_1): Eliminate single-use
+	variable LEN.
+	* alpha-tdep.c (alpha_extract_return_value): Use TYPE_LENGTH
+	directly.
+	(alpha_store_return_value): Likewise.
+	* amd64-tdep.c (amd64_classify_aggregate): Likewise.
+	(amd64_push_arguments): Likewise.
+	* ax-gdb.c (gen_trace_static_fields): Likewise.
+	(gen_traced_pop): Likewise.
+	* bfin-tdep.c (bfin_push_dummy_call): Likewise.
+	* breakpoint.c (update_watchpoint): Likewise.
+	* findcmd.c (parse_find_args): Use local variable for type
+	instead of length.
+	* findvar.c (default_read_var_value): Use TYPE_LENGTH directly.
+	* h8300-tdep.c (h8300h_extract_return_value): Likewise.
+	(h8300_store_return_value): Likewise.
+	* i386-darwin-tdep.c (i386_darwin_push_dummy_call): Likewise.
+	Use i386_darwin_arg_type_alignment directly.
+	* infcall.c (call_function_by_hand): Use TYPE_LENGTH directly.
+	* lm32-tdep.c (lm32_push_dummy_call): Likewise.
+	* m68hc11-tdep.c (m68hc11_push_dummy_call): Likewise.
+	(m68hc11_extract_return_value): Likewise.
+	* mep-tdep.c (mep_push_dummy_call): Likewise.
+	* printcmd.c (float_type_from_length): Likewise.
+	* s390-tdep.c (s390_value_from_register): Likewise.
+	* stack.c (read_frame_arg): Likewise.
+	* tracepoint.c (encode_actions_1): Likewise.
+	* valops.c (value_fetch_lazy): Use local variable for type
+	instead of length.  Use TYPE_LENGTH directly.
+	* value.c (value_contents_equal): Use TYPE_LENGTH directly.
+
 2012-09-25  Joel Brobecker  <brobecker@adacore.com>
 
 	* symtab.c (skip_prologue_sal): Fix typo in comment.
Index: gdb-7.5.0.20120926/gdb/ada-valprint.c
===================================================================
--- gdb-7.5.0.20120926.orig/gdb/ada-valprint.c	2012-04-18 08:46:46.000000000 +0200
+++ gdb-7.5.0.20120926/gdb/ada-valprint.c	2012-11-07 22:03:57.600623522 +0100
@@ -730,9 +730,8 @@ ada_val_print_1 (struct type *type, cons
       if (ada_is_fixed_point_type (type))
 	{
 	  LONGEST v = unpack_long (type, valaddr + offset_aligned);
-	  int len = TYPE_LENGTH (type);
 
-	  fprintf_filtered (stream, len < 4 ? "%.11g" : "%.17g",
+	  fprintf_filtered (stream, TYPE_LENGTH (type) < 4 ? "%.11g" : "%.17g",
 			    (double) ada_fixed_to_float (type, v));
 	  return;
 	}
Index: gdb-7.5.0.20120926/gdb/alpha-tdep.c
===================================================================
--- gdb-7.5.0.20120926.orig/gdb/alpha-tdep.c	2012-05-16 16:35:02.000000000 +0200
+++ gdb-7.5.0.20120926/gdb/alpha-tdep.c	2012-11-07 22:03:57.602623520 +0100
@@ -475,14 +475,13 @@ alpha_extract_return_value (struct type
 {
   struct gdbarch *gdbarch = get_regcache_arch (regcache);
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
-  int length = TYPE_LENGTH (valtype);
   gdb_byte raw_buffer[ALPHA_REGISTER_SIZE];
   ULONGEST l;
 
   switch (TYPE_CODE (valtype))
     {
     case TYPE_CODE_FLT:
-      switch (length)
+      switch (TYPE_LENGTH (valtype))
 	{
 	case 4:
 	  regcache_cooked_read (regcache, ALPHA_FP0_REGNUM, raw_buffer);
@@ -505,7 +504,7 @@ alpha_extract_return_value (struct type
       break;
 
     case TYPE_CODE_COMPLEX:
-      switch (length)
+      switch (TYPE_LENGTH (valtype))
 	{
 	case 8:
 	  /* ??? This isn't correct wrt the ABI, but it's what GCC does.  */
@@ -531,7 +530,7 @@ alpha_extract_return_value (struct type
     default:
       /* Assume everything else degenerates to an integer.  */
       regcache_cooked_read_unsigned (regcache, ALPHA_V0_REGNUM, &l);
-      store_unsigned_integer (valbuf, length, byte_order, l);
+      store_unsigned_integer (valbuf, TYPE_LENGTH (valtype), byte_order, l);
       break;
     }
 }
@@ -544,14 +543,13 @@ alpha_store_return_value (struct type *v
 			  const gdb_byte *valbuf)
 {
   struct gdbarch *gdbarch = get_regcache_arch (regcache);
-  int length = TYPE_LENGTH (valtype);
   gdb_byte raw_buffer[ALPHA_REGISTER_SIZE];
   ULONGEST l;
 
   switch (TYPE_CODE (valtype))
     {
     case TYPE_CODE_FLT:
-      switch (length)
+      switch (TYPE_LENGTH (valtype))
 	{
 	case 4:
 	  alpha_lds (gdbarch, raw_buffer, valbuf);
@@ -575,7 +573,7 @@ alpha_store_return_value (struct type *v
       break;
 
     case TYPE_CODE_COMPLEX:
-      switch (length)
+      switch (TYPE_LENGTH (valtype))
 	{
 	case 8:
 	  /* ??? This isn't correct wrt the ABI, but it's what GCC does.  */
@@ -603,7 +601,7 @@ alpha_store_return_value (struct type *v
       /* Assume everything else degenerates to an integer.  */
       /* 32-bit values must be sign-extended to 64 bits
 	 even if the base data type is unsigned.  */
-      if (length == 4)
+      if (TYPE_LENGTH (valtype) == 4)
 	valtype = builtin_type (gdbarch)->builtin_int32;
       l = unpack_long (valtype, valbuf);
       regcache_cooked_write_unsigned (regcache, ALPHA_V0_REGNUM, l);
Index: gdb-7.5.0.20120926/gdb/amd64-tdep.c
===================================================================
--- gdb-7.5.0.20120926.orig/gdb/amd64-tdep.c	2012-11-07 22:00:42.000000000 +0100
+++ gdb-7.5.0.20120926/gdb/amd64-tdep.c	2012-11-07 22:03:57.623623489 +0100
@@ -446,12 +446,10 @@ amd64_non_pod_p (struct type *type)
 static void
 amd64_classify_aggregate (struct type *type, enum amd64_reg_class class[2])
 {
-  int len = TYPE_LENGTH (type);
-
   /* 1. If the size of an object is larger than two eightbytes, or in
         C++, is a non-POD structure or union type, or contains
         unaligned fields, it has class memory.  */
-  if (len > 16 || amd64_non_pod_p (type))
+  if (TYPE_LENGTH (type) > 16 || amd64_non_pod_p (type))
     {
       class[0] = class[1] = AMD64_MEMORY;
       return;
@@ -471,7 +469,7 @@ amd64_classify_aggregate (struct type *t
 
       /* All fields in an array have the same type.  */
       amd64_classify (subtype, class);
-      if (len > 8 && class[1] == AMD64_NO_CLASS)
+      if (TYPE_LENGTH (type) > 8 && class[1] == AMD64_NO_CLASS)
 	class[1] = class[0];
     }
   else
@@ -839,10 +837,9 @@ amd64_push_arguments (struct regcache *r
     {
       struct type *type = value_type (stack_args[i]);
       const gdb_byte *valbuf = value_contents (stack_args[i]);
-      int len = TYPE_LENGTH (type);
       CORE_ADDR arg_addr = sp + element * 8;
 
-      write_memory (arg_addr, valbuf, len);
+      write_memory (arg_addr, valbuf, TYPE_LENGTH (type));
       if (arg_addr_regno[i] >= 0)
         {
           /* We also need to store the address of that argument in
@@ -853,7 +850,7 @@ amd64_push_arguments (struct regcache *r
           store_unsigned_integer (buf, 8, byte_order, arg_addr);
           regcache_cooked_write (regcache, arg_addr_regno[i], buf);
         }
-      element += ((len + 7) / 8);
+      element += ((TYPE_LENGTH (type) + 7) / 8);
     }
 
   /* The psABI says that "For calls that may call functions that use
Index: gdb-7.5.0.20120926/gdb/ax-gdb.c
===================================================================
--- gdb-7.5.0.20120926.orig/gdb/ax-gdb.c	2012-07-05 03:03:01.000000000 +0200
+++ gdb-7.5.0.20120926/gdb/ax-gdb.c	2012-11-07 22:03:57.626623484 +0100
@@ -367,9 +367,9 @@ gen_trace_static_fields (struct gdbarch
 	    {
 	    case axs_lvalue_memory:
 	      {
-		int length = TYPE_LENGTH (check_typedef (value.type));
-
-		ax_const_l (ax, length);
+	        /* Initialize the TYPE_LENGTH if it is a typedef.  */
+	        check_typedef (value.type);
+		ax_const_l (ax, TYPE_LENGTH (value.type));
 		ax_simple (ax, aop_trace);
 	      }
 	      break;
@@ -425,17 +425,18 @@ gen_traced_pop (struct gdbarch *gdbarch,
 
       case axs_lvalue_memory:
 	{
-	  int length = TYPE_LENGTH (check_typedef (value->type));
-
 	  if (string_trace)
 	    ax_simple (ax, aop_dup);
 
+	  /* Initialize the TYPE_LENGTH if it is a typedef.  */
+	  check_typedef (value->type);
+
 	  /* There's no point in trying to use a trace_quick bytecode
 	     here, since "trace_quick SIZE pop" is three bytes, whereas
 	     "const8 SIZE trace" is also three bytes, does the same
 	     thing, and the simplest code which generates that will also
 	     work correctly for objects with large sizes.  */
-	  ax_const_l (ax, length);
+	  ax_const_l (ax, TYPE_LENGTH (value->type));
 	  ax_simple (ax, aop_trace);
 
 	  if (string_trace)
Index: gdb-7.5.0.20120926/gdb/bfin-tdep.c
===================================================================
--- gdb-7.5.0.20120926.orig/gdb/bfin-tdep.c	2012-05-16 16:35:03.000000000 +0200
+++ gdb-7.5.0.20120926/gdb/bfin-tdep.c	2012-11-07 22:03:57.643623460 +0100
@@ -513,9 +513,8 @@ bfin_push_dummy_call (struct gdbarch *gd
   for (i = nargs - 1; i >= 0; i--)
     {
       struct type *value_type = value_enclosing_type (args[i]);
-      int len = TYPE_LENGTH (value_type);
 
-      total_len += (len + 3) & ~3;
+      total_len += (TYPE_LENGTH (value_type) + 3) & ~3;
     }
 
   /* At least twelve bytes of stack space must be allocated for the function's
@@ -531,8 +530,7 @@ bfin_push_dummy_call (struct gdbarch *gd
     {
       struct type *value_type = value_enclosing_type (args[i]);
       struct type *arg_type = check_typedef (value_type);
-      int len = TYPE_LENGTH (value_type);
-      int container_len = (len + 3) & ~3;
+      int container_len = (TYPE_LENGTH (value_type) + 3) & ~3;
 
       sp -= container_len;
       write_memory (sp, value_contents_writeable (args[i]), container_len);
Index: gdb-7.5.0.20120926/gdb/breakpoint.c
===================================================================
--- gdb-7.5.0.20120926.orig/gdb/breakpoint.c	2012-11-07 22:00:43.000000000 +0100
+++ gdb-7.5.0.20120926/gdb/breakpoint.c	2012-11-07 22:03:57.660623434 +0100
@@ -1844,11 +1844,10 @@ update_watchpoint (struct watchpoint *b,
 		      && TYPE_CODE (vtype) != TYPE_CODE_ARRAY))
 		{
 		  CORE_ADDR addr;
-		  int len, type;
+		  int type;
 		  struct bp_location *loc, **tmp;
 
 		  addr = value_address (v);
-		  len = TYPE_LENGTH (value_type (v));
 		  type = hw_write;
 		  if (b->base.type == bp_read_watchpoint)
 		    type = hw_read;
@@ -1863,7 +1862,7 @@ update_watchpoint (struct watchpoint *b,
 
 		  loc->pspace = frame_pspace;
 		  loc->address = addr;
-		  loc->length = len;
+		  loc->length = TYPE_LENGTH (value_type (v));
 		  loc->watchpoint_type = type;
 		}
 	    }
Index: gdb-7.5.0.20120926/gdb/findcmd.c
===================================================================
--- gdb-7.5.0.20120926.orig/gdb/findcmd.c	2012-07-06 17:51:39.000000000 +0200
+++ gdb-7.5.0.20120926/gdb/findcmd.c	2012-11-07 22:03:57.676623411 +0100
@@ -169,19 +169,19 @@ parse_find_args (char *args, ULONGEST *m
   while (*s != '\0')
     {
       LONGEST x;
-      int val_bytes;
+      struct type *t;
       ULONGEST pattern_buf_size_need;
 
       while (isspace (*s))
 	++s;
 
       v = parse_to_comma_and_eval (&s);
-      val_bytes = TYPE_LENGTH (value_type (v));
+      t = value_type (v);
 
       /* Keep it simple and assume size == 'g' when watching for when we
 	 need to grow the pattern buf.  */
       pattern_buf_size_need = (pattern_buf_end - pattern_buf
-			       + max (val_bytes, sizeof (int64_t)));
+			       + max (TYPE_LENGTH (t), sizeof (int64_t)));
       if (pattern_buf_size_need > pattern_buf_size)
 	{
 	  size_t current_offset = pattern_buf_end - pattern_buf;
@@ -215,8 +215,8 @@ parse_find_args (char *args, ULONGEST *m
 	}
       else
 	{
-	  memcpy (pattern_buf_end, value_contents (v), val_bytes);
-	  pattern_buf_end += val_bytes;
+	  memcpy (pattern_buf_end, value_contents (v), TYPE_LENGTH (t));
+	  pattern_buf_end += TYPE_LENGTH (t);
 	}
 
       if (*s == ',')
Index: gdb-7.5.0.20120926/gdb/h8300-tdep.c
===================================================================
--- gdb-7.5.0.20120926.orig/gdb/h8300-tdep.c	2012-11-07 22:00:44.000000000 +0100
+++ gdb-7.5.0.20120926/gdb/h8300-tdep.c	2012-11-07 22:03:57.679623409 +0100
@@ -785,16 +785,15 @@ h8300h_extract_return_value (struct type
 {
   struct gdbarch *gdbarch = get_regcache_arch (regcache);
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
-  int len = TYPE_LENGTH (type);
   ULONGEST c;
 
-  switch (len)
+  switch (TYPE_LENGTH (type))
     {
     case 1:
     case 2:
     case 4:
       regcache_cooked_read_unsigned (regcache, E_RET0_REGNUM, &c);
-      store_unsigned_integer (valbuf, len, byte_order, c);
+      store_unsigned_integer (valbuf, TYPE_LENGTH (type), byte_order, c);
       break;
     case 8:			/* long long is now 8 bytes.  */
       if (TYPE_CODE (type) == TYPE_CODE_INT)
@@ -852,18 +851,17 @@ h8300_store_return_value (struct type *t
 {
   struct gdbarch *gdbarch = get_regcache_arch (regcache);
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
-  int len = TYPE_LENGTH (type);
   ULONGEST val;
 
-  switch (len)
+  switch (TYPE_LENGTH (type))
     {
     case 1:
     case 2:			/* short...  */
-      val = extract_unsigned_integer (valbuf, len, byte_order);
+      val = extract_unsigned_integer (valbuf, TYPE_LENGTH (type), byte_order);
       regcache_cooked_write_unsigned (regcache, E_RET0_REGNUM, val);
       break;
     case 4:			/* long, float */
-      val = extract_unsigned_integer (valbuf, len, byte_order);
+      val = extract_unsigned_integer (valbuf, TYPE_LENGTH (type), byte_order);
       regcache_cooked_write_unsigned (regcache, E_RET0_REGNUM,
 				      (val >> 16) & 0xffff);
       regcache_cooked_write_unsigned (regcache, E_RET1_REGNUM, val & 0xffff);
@@ -882,19 +880,18 @@ h8300h_store_return_value (struct type *
 {
   struct gdbarch *gdbarch = get_regcache_arch (regcache);
   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
-  int len = TYPE_LENGTH (type);
   ULONGEST val;
 
-  switch (len)
+  switch (TYPE_LENGTH (type))
     {
     case 1:
     case 2:
     case 4:			/* long, float */
-      val = extract_unsigned_integer (valbuf, len, byte_order);
+      val = extract_unsigned_integer (valbuf, TYPE_LENGTH (type), byte_order);
       regcache_cooked_write_unsigned (regcache, E_RET0_REGNUM, val);
       break;
     case 8:
-      val = extract_unsigned_integer (valbuf, len, byte_order);
+      val = extract_unsigned_integer (valbuf, TYPE_LENGTH (type), byte_order);
       regcache_cooked_write_unsigned (regcache, E_RET0_REGNUM,
 				      (val >> 32) & 0xffffffff);
       regcache_cooked_write_unsigned (regcache, E_RET1_REGNUM,
Index: gdb-7.5.0.20120926/gdb/i386-darwin-tdep.c
===================================================================
--- gdb-7.5.0.20120926.orig/gdb/i386-darwin-tdep.c	2012-04-02 15:15:48.000000000 +0200
+++ gdb-7.5.0.20120926/gdb/i386-darwin-tdep.c	2012-11-07 22:03:57.680623407 +0100
@@ -196,13 +196,12 @@ i386_darwin_push_dummy_call (struct gdba
             }
           else
             {
-              int len = TYPE_LENGTH (arg_type);
-              int align = i386_darwin_arg_type_alignment (arg_type);
-
-              args_space = align_up (args_space, align);
+              args_space = align_up (args_space,
+				     i386_darwin_arg_type_alignment (arg_type));
               if (write_pass)
                 write_memory (sp + args_space,
-                              value_contents_all (args[i]), len);
+                              value_contents_all (args[i]),
+			      TYPE_LENGTH (arg_type));
 
               /* The System V ABI says that:
                  
@@ -211,7 +210,7 @@ i386_darwin_push_dummy_call (struct gdba
                  depending on the size of the argument."
                  
                  This makes sure the stack stays word-aligned.  */
-              args_space += align_up (len, 4);
+              args_space += align_up (TYPE_LENGTH (arg_type), 4);
             }
         }
 
Index: gdb-7.5.0.20120926/gdb/infcall.c
===================================================================
--- gdb-7.5.0.20120926.orig/gdb/infcall.c	2012-07-31 09:34:39.000000000 +0200
+++ gdb-7.5.0.20120926/gdb/infcall.c	2012-11-07 22:03:57.694623385 +0100
@@ -709,13 +709,11 @@ call_function_by_hand (struct value *fun
 
   if (struct_return || hidden_first_param_p)
     {
-      int len = TYPE_LENGTH (values_type);
-
       if (gdbarch_inner_than (gdbarch, 1, 2))
 	{
 	  /* Stack grows downward.  Align STRUCT_ADDR and SP after
              making space for the return value.  */
-	  sp -= len;
+	  sp -= TYPE_LENGTH (values_type);
 	  if (gdbarch_frame_align_p (gdbarch))
 	    sp = gdbarch_frame_align (gdbarch, sp);
 	  struct_addr = sp;
@@ -727,7 +725,7 @@ call_function_by_hand (struct value *fun
 	  if (gdbarch_frame_align_p (gdbarch))
 	    sp = gdbarch_frame_align (gdbarch, sp);
 	  struct_addr = sp;
-	  sp += len;
+	  sp += TYPE_LENGTH (values_type);
 	  if (gdbarch_frame_align_p (gdbarch))
 	    sp = gdbarch_frame_align (gdbarch, sp);
 	}
Index: gdb-7.5.0.20120926/gdb/lm32-tdep.c
===================================================================
--- gdb-7.5.0.20120926.orig/gdb/lm32-tdep.c	2012-05-18 23:02:48.000000000 +0200
+++ gdb-7.5.0.20120926/gdb/lm32-tdep.c	2012-11-07 22:03:57.695623384 +0100
@@ -261,7 +261,6 @@ lm32_push_dummy_call (struct gdbarch *gd
       struct value *arg = args[i];
       struct type *arg_type = check_typedef (value_type (arg));
       gdb_byte *contents;
-      int len;
       ULONGEST val;
 
       /* Promote small integer types to int.  */
@@ -283,8 +282,8 @@ lm32_push_dummy_call (struct gdbarch *gd
       /* FIXME: Handle structures.  */
 
       contents = (gdb_byte *) value_contents (arg);
-      len = TYPE_LENGTH (arg_type);
-      val = extract_unsigned_integer (contents, len, byte_order);
+      val = extract_unsigned_integer (contents, TYPE_LENGTH (arg_type),
+				      byte_order);
 
       /* First num_arg_regs parameters are passed by registers, 
          and the rest are passed on the stack.  */
@@ -292,7 +291,7 @@ lm32_push_dummy_call (struct gdbarch *gd
 	regcache_cooked_write_unsigned (regcache, first_arg_reg + i, val);
       else
 	{
-	  write_memory (sp, (void *) &val, len);
+	  write_memory (sp, (void *) &val, TYPE_LENGTH (arg_type));
 	  sp -= 4;
 	}
     }
Index: gdb-7.5.0.20120926/gdb/m68hc11-tdep.c
===================================================================
--- gdb-7.5.0.20120926.orig/gdb/m68hc11-tdep.c	2012-05-16 16:35:06.000000000 +0200
+++ gdb-7.5.0.20120926/gdb/m68hc11-tdep.c	2012-11-07 22:03:57.724623347 +0100
@@ -1174,7 +1174,6 @@ m68hc11_push_dummy_call (struct gdbarch
   int first_stack_argnum;
   struct type *type;
   char *val;
-  int len;
   char buf[2];
   
   first_stack_argnum = 0;
@@ -1185,19 +1184,18 @@ m68hc11_push_dummy_call (struct gdbarch
   else if (nargs > 0)
     {
       type = value_type (args[0]);
-      len = TYPE_LENGTH (type);
 
       /* First argument is passed in D and X registers.  */
-      if (len <= 4)
+      if (TYPE_LENGTH (type) <= 4)
         {
           ULONGEST v;
 
           v = extract_unsigned_integer (value_contents (args[0]),
-					len, byte_order);
+					TYPE_LENGTH (type), byte_order);
           first_stack_argnum = 1;
 
           regcache_cooked_write_unsigned (regcache, HARD_D_REGNUM, v);
-          if (len > 2)
+          if (TYPE_LENGTH (type) > 2)
             {
               v >>= 16;
               regcache_cooked_write_unsigned (regcache, HARD_X_REGNUM, v);
@@ -1208,9 +1206,8 @@ m68hc11_push_dummy_call (struct gdbarch
   for (argnum = nargs - 1; argnum >= first_stack_argnum; argnum--)
     {
       type = value_type (args[argnum]);
-      len = TYPE_LENGTH (type);
 
-      if (len & 1)
+      if (TYPE_LENGTH (type) & 1)
         {
           static char zero = 0;
 
@@ -1218,8 +1215,8 @@ m68hc11_push_dummy_call (struct gdbarch
           write_memory (sp, &zero, 1);
         }
       val = (char*) value_contents (args[argnum]);
-      sp -= len;
-      write_memory (sp, val, len);
+      sp -= TYPE_LENGTH (type);
+      write_memory (sp, val, TYPE_LENGTH (type));
     }
 
   /* Store return address.  */
@@ -1291,11 +1288,10 @@ static void
 m68hc11_extract_return_value (struct type *type, struct regcache *regcache,
                               void *valbuf)
 {
-  int len = TYPE_LENGTH (type);
   char buf[M68HC11_REG_SIZE];
 
   regcache_raw_read (regcache, HARD_D_REGNUM, buf);
-  switch (len)
+  switch (TYPE_LENGTH (type))
     {
     case 1:
       memcpy (valbuf, buf + 1, 1);
Index: gdb-7.5.0.20120926/gdb/mep-tdep.c
===================================================================
--- gdb-7.5.0.20120926.orig/gdb/mep-tdep.c	2012-05-16 16:35:06.000000000 +0200
+++ gdb-7.5.0.20120926/gdb/mep-tdep.c	2012-11-07 22:03:57.727623334 +0100
@@ -2337,11 +2337,10 @@ mep_push_dummy_call (struct gdbarch *gdb
 
   for (i = 0; i < argc; i++)
     {
-      unsigned arg_size = TYPE_LENGTH (value_type (argv[i]));
       ULONGEST value;
 
       /* Arguments that fit in a GPR get expanded to fill the GPR.  */
-      if (arg_size <= MEP_GPR_SIZE)
+      if (TYPE_LENGTH (value_type (argv[i])) <= MEP_GPR_SIZE)
         value = extract_unsigned_integer (value_contents (argv[i]),
                                           TYPE_LENGTH (value_type (argv[i])),
 					  byte_order);
Index: gdb-7.5.0.20120926/gdb/printcmd.c
===================================================================
--- gdb-7.5.0.20120926.orig/gdb/printcmd.c	2012-11-07 22:00:44.000000000 +0100
+++ gdb-7.5.0.20120926/gdb/printcmd.c	2012-11-07 22:03:57.730623334 +0100
@@ -347,13 +347,12 @@ float_type_from_length (struct type *typ
 {
   struct gdbarch *gdbarch = get_type_arch (type);
   const struct builtin_type *builtin = builtin_type (gdbarch);
-  unsigned int len = TYPE_LENGTH (type);
 
-  if (len == TYPE_LENGTH (builtin->builtin_float))
+  if (TYPE_LENGTH (type) == TYPE_LENGTH (builtin->builtin_float))
     type = builtin->builtin_float;
-  else if (len == TYPE_LENGTH (builtin->builtin_double))
+  else if (TYPE_LENGTH (type) == TYPE_LENGTH (builtin->builtin_double))
     type = builtin->builtin_double;
-  else if (len == TYPE_LENGTH (builtin->builtin_long_double))
+  else if (TYPE_LENGTH (type) == TYPE_LENGTH (builtin->builtin_long_double))
     type = builtin->builtin_long_double;
 
   return type;
Index: gdb-7.5.0.20120926/gdb/s390-tdep.c
===================================================================
--- gdb-7.5.0.20120926.orig/gdb/s390-tdep.c	2012-11-07 22:02:30.000000000 +0100
+++ gdb-7.5.0.20120926/gdb/s390-tdep.c	2012-11-07 22:03:57.733623329 +0100
@@ -376,9 +376,11 @@ s390_value_from_register (struct type *t
 			  struct frame_info *frame)
 {
   struct value *value = default_value_from_register (type, regnum, frame);
-  int len = TYPE_LENGTH (check_typedef (type));
 
-  if (regnum >= S390_F0_REGNUM && regnum <= S390_F15_REGNUM && len < 8)
+  check_typedef (type);
+
+  if (regnum >= S390_F0_REGNUM && regnum <= S390_F15_REGNUM
+      && TYPE_LENGTH (type) < 8)
     set_value_offset (value, 0);
 
   return value;
Index: gdb-7.5.0.20120926/gdb/stack.c
===================================================================
--- gdb-7.5.0.20120926.orig/gdb/stack.c	2012-11-07 22:00:43.000000000 +0100
+++ gdb-7.5.0.20120926/gdb/stack.c	2012-11-07 22:03:57.737623322 +0100
@@ -354,14 +354,15 @@ read_frame_arg (struct symbol *sym, stru
 
 	  if (val && entryval && !ui_out_is_mi_like_p (current_uiout))
 	    {
-	      unsigned len = TYPE_LENGTH (value_type (val));
+	      struct type *type = value_type (val);
 
 	      if (!value_optimized_out (val) && value_lazy (val))
 		value_fetch_lazy (val);
 	      if (!value_optimized_out (val) && value_lazy (entryval))
 		value_fetch_lazy (entryval);
 	      if (!value_optimized_out (val)
-		  && value_available_contents_eq (val, 0, entryval, 0, len))
+		  && value_available_contents_eq (val, 0, entryval, 0,
+						  TYPE_LENGTH (type)))
 		{
 		  /* Initialize it just to avoid a GCC false warning.  */
 		  struct value *val_deref = NULL, *entryval_deref;
@@ -373,12 +374,12 @@ read_frame_arg (struct symbol *sym, stru
 
 		  TRY_CATCH (except, RETURN_MASK_ERROR)
 		    {
-		      unsigned len_deref;
+		      struct type *type_deref;
 
 		      val_deref = coerce_ref (val);
 		      if (value_lazy (val_deref))
 			value_fetch_lazy (val_deref);
-		      len_deref = TYPE_LENGTH (value_type (val_deref));
+		      type_deref = value_type (val_deref);
 
 		      entryval_deref = coerce_ref (entryval);
 		      if (value_lazy (entryval_deref))
@@ -389,7 +390,7 @@ read_frame_arg (struct symbol *sym, stru
 		      if (val != val_deref
 			  && value_available_contents_eq (val_deref, 0,
 							  entryval_deref, 0,
-							  len_deref))
+						      TYPE_LENGTH (type_deref)))
 			val_equal = 1;
 		    }
 
Index: gdb-7.5.0.20120926/gdb/tracepoint.c
===================================================================
--- gdb-7.5.0.20120926.orig/gdb/tracepoint.c	2012-06-30 00:46:46.000000000 +0200
+++ gdb-7.5.0.20120926/gdb/tracepoint.c	2012-11-07 22:03:57.741623318 +0100
@@ -1450,7 +1450,7 @@ encode_actions_1 (struct command_line *a
 		}
 	      else
 		{
-		  unsigned long addr, len;
+		  unsigned long addr;
 		  struct cleanup *old_chain = NULL;
 		  struct cleanup *old_chain1 = NULL;
 
@@ -1480,8 +1480,10 @@ encode_actions_1 (struct command_line *a
 		      /* Safe because we know it's a simple expression.  */
 		      tempval = evaluate_expression (exp);
 		      addr = value_address (tempval);
-		      len = TYPE_LENGTH (check_typedef (exp->elts[1].type));
-		      add_memrange (collect, memrange_absolute, addr, len);
+		      /* Initialize the TYPE_LENGTH if it is a typedef.  */
+		      check_typedef (exp->elts[1].type);
+		      add_memrange (collect, memrange_absolute, addr,
+				    TYPE_LENGTH (exp->elts[1].type));
 		      break;
 
 		    case OP_VAR_VALUE:
Index: gdb-7.5.0.20120926/gdb/valops.c
===================================================================
--- gdb-7.5.0.20120926.orig/gdb/valops.c	2012-11-07 22:00:44.000000000 +0100
+++ gdb-7.5.0.20120926/gdb/valops.c	2012-11-07 22:06:35.899393539 +0100
@@ -1055,7 +1055,6 @@ value_fetch_lazy (struct value *val)
       struct value *parent = value_parent (val);
       LONGEST offset = value_offset (val);
       LONGEST num;
-      int length = TYPE_LENGTH (type);
 
       if (!value_bits_valid (val,
 			     TARGET_CHAR_BIT * offset + value_bitpos (val),
@@ -1069,9 +1068,9 @@ value_fetch_lazy (struct value *val)
 				      value_bitsize (val), parent, &num))
 	mark_value_bytes_unavailable (val,
 				      value_embedded_offset (val),
-				      length);
+				      TYPE_LENGTH (type));
       else
-	store_signed_integer (value_contents_raw (val), length,
+	store_signed_integer (value_contents_raw (val), TYPE_LENGTH (type),
 			      byte_order, num);
     }
   else if (VALUE_LVAL (val) == lval_memory)
@@ -1080,16 +1079,16 @@ value_fetch_lazy (struct value *val)
 
       if (object_address_get_data (value_type (val), &addr))
 	{
-	  struct type *type = value_enclosing_type (val);
-	  int length = TYPE_LENGTH (check_typedef (type));
+	  struct type *type = check_typedef (value_enclosing_type (val));
 
-	  if (length)
+	  if (TYPE_LENGTH (type))
 	    {
 	      /* Delay it after object_address_get_data above.  */
 	      allocate_value_contents (val);
 	      addr += value_offset (val);
 	      read_value_memory (val, 0, value_stack (val),
-				 addr, value_contents_all_raw (val), length);
+				 addr, value_contents_all_raw (val),
+				 TYPE_LENGTH (type));
 	    }
 	}
       /* Just to be sure it has been called.  */
Index: gdb-7.5.0.20120926/gdb/value.c
===================================================================
--- gdb-7.5.0.20120926.orig/gdb/value.c	2012-11-07 22:00:43.000000000 +0100
+++ gdb-7.5.0.20120926/gdb/value.c	2012-11-07 22:03:57.751623303 +0100
@@ -1034,15 +1034,14 @@ value_contents_equal (struct value *val1
 {
   struct type *type1;
   struct type *type2;
-  int len;
 
   type1 = check_typedef (value_type (val1));
   type2 = check_typedef (value_type (val2));
-  len = TYPE_LENGTH (type1);
-  if (len != TYPE_LENGTH (type2))
+  if (TYPE_LENGTH (type1) != TYPE_LENGTH (type2))
     return 0;
 
-  return (memcmp (value_contents (val1), value_contents (val2), len) == 0);
+  return (memcmp (value_contents (val1), value_contents (val2),
+		  TYPE_LENGTH (type1)) == 0);
 }
 
 int
