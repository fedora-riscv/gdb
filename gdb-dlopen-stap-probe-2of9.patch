http://sourceware.org/ml/gdb-cvs/2013-06/msg00013.html

### src/gdb/ChangeLog	2013/06/04 12:50:20	1.15681
### src/gdb/ChangeLog	2013/06/04 12:53:33	1.15682
## -1,5 +1,24 @@
 2013-06-04  Gary Benson  <gbenson@redhat.com>
 
+	* objfiles.h (inhibit_section_map_updates): New function
+	declaration.
+	(resume_section_map_updates): Likewise.
+	(resume_section_map_updates_cleanup): Likewise.
+	* objfiles.c (objfile_pspace_info): Removed field
+	"objfiles_changed_p".  New fields "new_objfiles_available",
+	"section_map_dirty" and "inhibit_updates".
+	(allocate_objfile): Set new_objfiles_available.
+	(free_objfile): Set section_map_dirty.
+	(objfile_relocate1): Likewise.
+	(in_plt_section): Likewise.
+	(find_pc_section): Update the conditions under which the
+	section map will be updated.
+	(inhibit_section_map_updates): New function.
+	(resume_section_map_updates): Likewise.
+	(resume_section_map_updates_cleanup): Likewise.
+
+2013-06-04  Gary Benson  <gbenson@redhat.com>
+
 	* probe.h (get_probe_argument_count): New declaration.
 	(evaluate_probe_argument): Likewise.
 	* probe.c (get_probe_argument_count): New function.
--- src/gdb/objfiles.c	2013/05/06 19:15:17	1.160
+++ src/gdb/objfiles.c	2013/06/04 12:53:34	1.161
@@ -67,9 +67,18 @@
 
 struct objfile_pspace_info
 {
-  int objfiles_changed_p;
   struct obj_section **sections;
   int num_sections;
+
+  /* Nonzero if object files have been added since the section map
+     was last updated.  */
+  int new_objfiles_available;
+
+  /* Nonzero if the section map MUST be updated before use.  */
+  int section_map_dirty;
+
+  /* Nonzero if section map updates should be inhibited if possible.  */
+  int inhibit_updates;
 };
 
 /* Per-program-space data key.  */
@@ -317,7 +326,7 @@
   objfile->flags |= flags;
 
   /* Rebuild section map next time we need it.  */
-  get_objfile_pspace_data (objfile->pspace)->objfiles_changed_p = 1;
+  get_objfile_pspace_data (objfile->pspace)->new_objfiles_available = 1;
 
   return objfile;
 }
@@ -646,7 +655,7 @@
   obstack_free (&objfile->objfile_obstack, 0);
 
   /* Rebuild section map next time we need it.  */
-  get_objfile_pspace_data (objfile->pspace)->objfiles_changed_p = 1;
+  get_objfile_pspace_data (objfile->pspace)->section_map_dirty = 1;
 
   xfree (objfile);
 }
@@ -826,7 +835,7 @@
   }
 
   /* Rebuild section map next time we need it.  */
-  get_objfile_pspace_data (objfile->pspace)->objfiles_changed_p = 1;
+  get_objfile_pspace_data (objfile->pspace)->section_map_dirty = 1;
 
   /* Update the table in exec_ops, used to read memory.  */
   ALL_OBJFILE_OSECTIONS (objfile, s)
@@ -1291,11 +1300,14 @@
 update_section_map (struct program_space *pspace,
 		    struct obj_section ***pmap, int *pmap_size)
 {
+  struct objfile_pspace_info *pspace_info;
   int alloc_size, map_size, i;
   struct obj_section *s, **map;
   struct objfile *objfile;
 
-  gdb_assert (get_objfile_pspace_data (pspace)->objfiles_changed_p != 0);
+  pspace_info = get_objfile_pspace_data (pspace);
+  gdb_assert (pspace_info->section_map_dirty != 0
+	      || pspace_info->new_objfiles_available != 0);
 
   map = *pmap;
   xfree (map);
@@ -1365,7 +1377,9 @@
     return s;
 
   pspace_info = get_objfile_pspace_data (current_program_space);
-  if (pspace_info->objfiles_changed_p != 0)
+  if (pspace_info->section_map_dirty
+      || (pspace_info->new_objfiles_available
+	  && !pspace_info->inhibit_updates))
     {
       update_section_map (current_program_space,
 			  &pspace_info->sections,
@@ -1373,7 +1387,8 @@
 
       /* Don't need updates to section map until objfiles are added,
          removed or relocated.  */
-      pspace_info->objfiles_changed_p = 0;
+      pspace_info->new_objfiles_available = 0;
+      pspace_info->section_map_dirty = 0;
     }
 
   /* The C standard (ISO/IEC 9899:TC2) requires the BASE argument to
@@ -1414,14 +1429,38 @@
 }
 
 
-/* Set objfiles_changed_p so section map will be rebuilt next time it
+/* Set section_map_dirty so section map will be rebuilt next time it
    is used.  Called by reread_symbols.  */
 
 void
 objfiles_changed (void)
 {
   /* Rebuild section map next time we need it.  */
-  get_objfile_pspace_data (current_program_space)->objfiles_changed_p = 1;
+  get_objfile_pspace_data (current_program_space)->section_map_dirty = 1;
+}
+
+/* See comments in objfiles.h.  */
+
+void
+inhibit_section_map_updates (struct program_space *pspace)
+{
+  get_objfile_pspace_data (pspace)->inhibit_updates = 1;
+}
+
+/* See comments in objfiles.h.  */
+
+void
+resume_section_map_updates (struct program_space *pspace)
+{
+  get_objfile_pspace_data (pspace)->inhibit_updates = 0;
+}
+
+/* See comments in objfiles.h.  */
+
+void
+resume_section_map_updates_cleanup (void *arg)
+{
+  resume_section_map_updates (arg);
 }
 
 /* The default implementation for the "iterate_over_objfiles_in_search_order"
--- src/gdb/objfiles.h	2013/05/06 19:15:17	1.106
+++ src/gdb/objfiles.h	2013/06/04 12:53:34	1.107
@@ -501,6 +501,22 @@
    modules.  */
 DECLARE_REGISTRY(objfile);
 
+/* In normal use, the section map will be rebuilt by find_pc_section
+   if objfiles have been added, removed or relocated since it was last
+   called.  Calling inhibit_section_map_updates will inhibit this
+   behavior until resume_section_map_updates is called.  If you call
+   inhibit_section_map_updates you must ensure that every call to
+   find_pc_section in the inhibited region relates to a section that
+   is already in the section map and has not since been removed or
+   relocated.  */
+extern void inhibit_section_map_updates (struct program_space *pspace);
+
+/* Resume automatically rebuilding the section map as required.  */
+extern void resume_section_map_updates (struct program_space *pspace);
+
+/* Version of the above suitable for use as a cleanup.  */
+extern void resume_section_map_updates_cleanup (void *arg);
+
 extern void default_iterate_over_objfiles_in_search_order
   (struct gdbarch *gdbarch,
    iterate_over_objfiles_in_search_order_cb_ftype *cb,
