http://sourceware.org/ml/gdb-cvs/2010-01/msg00183.html

REVERT

--- ./gdb/gdbserver/i387-fp.c	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/i387-fp.c	2010-01-21 20:33:15.000000000 +0100
@@ -73,7 +73,7 @@ struct i387_fxsave {
 };
 
 void
-i387_cache_to_fsave (struct regcache *regcache, void *buf)
+i387_cache_to_fsave (void *buf)
 {
   struct i387_fsave *fp = (struct i387_fsave *) buf;
   int i;
@@ -81,39 +81,38 @@ i387_cache_to_fsave (struct regcache *re
   unsigned long val, val2;
 
   for (i = 0; i < 8; i++)
-    collect_register (regcache, i + st0_regnum,
-		      ((char *) &fp->st_space[0]) + i * 10);
+    collect_register (i + st0_regnum, ((char *) &fp->st_space[0]) + i * 10);
 
-  collect_register_by_name (regcache, "fioff", &fp->fioff);
-  collect_register_by_name (regcache, "fooff", &fp->fooff);
+  collect_register_by_name ("fioff", &fp->fioff);
+  collect_register_by_name ("fooff", &fp->fooff);
   
   /* This one's 11 bits... */
-  collect_register_by_name (regcache, "fop", &val2);
+  collect_register_by_name ("fop", &val2);
   fp->fop = (val2 & 0x7FF) | (fp->fop & 0xF800);
 
   /* Some registers are 16-bit.  */
-  collect_register_by_name (regcache, "fctrl", &val);
+  collect_register_by_name ("fctrl", &val);
   fp->fctrl = val;
 
-  collect_register_by_name (regcache, "fstat", &val);
+  collect_register_by_name ("fstat", &val);
   val &= 0xFFFF;
   fp->fstat = val;
 
-  collect_register_by_name (regcache, "ftag", &val);
+  collect_register_by_name ("ftag", &val);
   val &= 0xFFFF;
   fp->ftag = val;
 
-  collect_register_by_name (regcache, "fiseg", &val);
+  collect_register_by_name ("fiseg", &val);
   val &= 0xFFFF;
   fp->fiseg = val;
 
-  collect_register_by_name (regcache, "foseg", &val);
+  collect_register_by_name ("foseg", &val);
   val &= 0xFFFF;
   fp->foseg = val;
 }
 
 void
-i387_fsave_to_cache (struct regcache *regcache, const void *buf)
+i387_fsave_to_cache (const void *buf)
 {
   struct i387_fsave *fp = (struct i387_fsave *) buf;
   int i;
@@ -121,35 +120,34 @@ i387_fsave_to_cache (struct regcache *re
   unsigned long val;
 
   for (i = 0; i < 8; i++)
-    supply_register (regcache, i + st0_regnum,
-		     ((char *) &fp->st_space[0]) + i * 10);
+    supply_register (i + st0_regnum, ((char *) &fp->st_space[0]) + i * 10);
 
-  supply_register_by_name (regcache, "fioff", &fp->fioff);
-  supply_register_by_name (regcache, "fooff", &fp->fooff);
+  supply_register_by_name ("fioff", &fp->fioff);
+  supply_register_by_name ("fooff", &fp->fooff);
 
   /* Some registers are 16-bit.  */
   val = fp->fctrl & 0xFFFF;
-  supply_register_by_name (regcache, "fctrl", &val);
+  supply_register_by_name ("fctrl", &val);
 
   val = fp->fstat & 0xFFFF;
-  supply_register_by_name (regcache, "fstat", &val);
+  supply_register_by_name ("fstat", &val);
 
   val = fp->ftag & 0xFFFF;
-  supply_register_by_name (regcache, "ftag", &val);
+  supply_register_by_name ("ftag", &val);
 
   val = fp->fiseg & 0xFFFF;
-  supply_register_by_name (regcache, "fiseg", &val);
+  supply_register_by_name ("fiseg", &val);
 
   val = fp->foseg & 0xFFFF;
-  supply_register_by_name (regcache, "foseg", &val);
+  supply_register_by_name ("foseg", &val);
 
   /* fop has only 11 valid bits.  */
   val = (fp->fop) & 0x7FF;
-  supply_register_by_name (regcache, "fop", &val);
+  supply_register_by_name ("fop", &val);
 }
 
 void
-i387_cache_to_fxsave (struct regcache *regcache, void *buf)
+i387_cache_to_fxsave (void *buf)
 {
   struct i387_fxsave *fp = (struct i387_fxsave *) buf;
   int i;
@@ -158,29 +156,27 @@ i387_cache_to_fxsave (struct regcache *r
   unsigned long val, val2;
 
   for (i = 0; i < 8; i++)
-    collect_register (regcache, i + st0_regnum,
-		      ((char *) &fp->st_space[0]) + i * 16);
+    collect_register (i + st0_regnum, ((char *) &fp->st_space[0]) + i * 16);
   for (i = 0; i < num_xmm_registers; i++)
-    collect_register (regcache, i + xmm0_regnum,
-		      ((char *) &fp->xmm_space[0]) + i * 16);
+    collect_register (i + xmm0_regnum, ((char *) &fp->xmm_space[0]) + i * 16);
 
-  collect_register_by_name (regcache, "fioff", &fp->fioff);
-  collect_register_by_name (regcache, "fooff", &fp->fooff);
-  collect_register_by_name (regcache, "mxcsr", &fp->mxcsr);
+  collect_register_by_name ("fioff", &fp->fioff);
+  collect_register_by_name ("fooff", &fp->fooff);
+  collect_register_by_name ("mxcsr", &fp->mxcsr);
 
   /* This one's 11 bits... */
-  collect_register_by_name (regcache, "fop", &val2);
+  collect_register_by_name ("fop", &val2);
   fp->fop = (val2 & 0x7FF) | (fp->fop & 0xF800);
 
   /* Some registers are 16-bit.  */
-  collect_register_by_name (regcache, "fctrl", &val);
+  collect_register_by_name ("fctrl", &val);
   fp->fctrl = val;
 
-  collect_register_by_name (regcache, "fstat", &val);
+  collect_register_by_name ("fstat", &val);
   fp->fstat = val;
 
   /* Convert to the simplifed tag form stored in fxsave data.  */
-  collect_register_by_name (regcache, "ftag", &val);
+  collect_register_by_name ("ftag", &val);
   val &= 0xFFFF;
   val2 = 0;
   for (i = 7; i >= 0; i--)
@@ -192,10 +188,10 @@ i387_cache_to_fxsave (struct regcache *r
     }
   fp->ftag = val2;
 
-  collect_register_by_name (regcache, "fiseg", &val);
+  collect_register_by_name ("fiseg", &val);
   fp->fiseg = val;
 
-  collect_register_by_name (regcache, "foseg", &val);
+  collect_register_by_name ("foseg", &val);
   fp->foseg = val;
 }
 
@@ -247,7 +243,7 @@ i387_ftag (struct i387_fxsave *fp, int r
 }
 
 void
-i387_fxsave_to_cache (struct regcache *regcache, const void *buf)
+i387_fxsave_to_cache (const void *buf)
 {
   struct i387_fxsave *fp = (struct i387_fxsave *) buf;
   int i, top;
@@ -256,22 +252,20 @@ i387_fxsave_to_cache (struct regcache *r
   unsigned long val;
 
   for (i = 0; i < 8; i++)
-    supply_register (regcache, i + st0_regnum,
-		     ((char *) &fp->st_space[0]) + i * 16);
+    supply_register (i + st0_regnum, ((char *) &fp->st_space[0]) + i * 16);
   for (i = 0; i < num_xmm_registers; i++)
-    supply_register (regcache, i + xmm0_regnum,
-		     ((char *) &fp->xmm_space[0]) + i * 16);
+    supply_register (i + xmm0_regnum, ((char *) &fp->xmm_space[0]) + i * 16);
 
-  supply_register_by_name (regcache, "fioff", &fp->fioff);
-  supply_register_by_name (regcache, "fooff", &fp->fooff);
-  supply_register_by_name (regcache, "mxcsr", &fp->mxcsr);
+  supply_register_by_name ("fioff", &fp->fioff);
+  supply_register_by_name ("fooff", &fp->fooff);
+  supply_register_by_name ("mxcsr", &fp->mxcsr);
 
   /* Some registers are 16-bit.  */
   val = fp->fctrl & 0xFFFF;
-  supply_register_by_name (regcache, "fctrl", &val);
+  supply_register_by_name ("fctrl", &val);
 
   val = fp->fstat & 0xFFFF;
-  supply_register_by_name (regcache, "fstat", &val);
+  supply_register_by_name ("fstat", &val);
 
   /* Generate the form of ftag data that GDB expects.  */
   top = (fp->fstat >> 11) & 0x7;
@@ -285,14 +279,14 @@ i387_fxsave_to_cache (struct regcache *r
 	tag = 3;
       val |= tag << (2 * i);
     }
-  supply_register_by_name (regcache, "ftag", &val);
+  supply_register_by_name ("ftag", &val);
 
   val = fp->fiseg & 0xFFFF;
-  supply_register_by_name (regcache, "fiseg", &val);
+  supply_register_by_name ("fiseg", &val);
 
   val = fp->foseg & 0xFFFF;
-  supply_register_by_name (regcache, "foseg", &val);
+  supply_register_by_name ("foseg", &val);
 
   val = (fp->fop) & 0x7FF;
-  supply_register_by_name (regcache, "fop", &val);
+  supply_register_by_name ("fop", &val);
 }
--- ./gdb/gdbserver/i387-fp.h	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/i387-fp.h	2010-01-21 20:33:15.000000000 +0100
@@ -20,11 +20,11 @@
 #ifndef I387_FP_H
 #define I387_FP_H
 
-void i387_cache_to_fsave (struct regcache *regcache, void *buf);
-void i387_fsave_to_cache (struct regcache *regcache, const void *buf);
+void i387_cache_to_fsave (void *buf);
+void i387_fsave_to_cache (const void *buf);
 
-void i387_cache_to_fxsave (struct regcache *regcache, void *buf);
-void i387_fxsave_to_cache (struct regcache *regcache, const void *buf);
+void i387_cache_to_fxsave (void *buf);
+void i387_fxsave_to_cache (const void *buf);
 
 extern int num_xmm_registers;
 
--- ./gdb/gdbserver/linux-arm-low.c	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/linux-arm-low.c	2010-01-21 20:33:15.000000000 +0100
@@ -81,17 +81,17 @@ arm_cannot_fetch_register (int regno)
 }
 
 static void
-arm_fill_gregset (struct regcache *regcache, void *buf)
+arm_fill_gregset (void *buf)
 {
   int i;
 
   for (i = 0; i < arm_num_regs; i++)
     if (arm_regmap[i] != -1)
-      collect_register (regcache, i, ((char *) buf) + arm_regmap[i]);
+      collect_register (i, ((char *) buf) + arm_regmap[i]);
 }
 
 static void
-arm_store_gregset (struct regcache *regcache, const void *buf)
+arm_store_gregset (const void *buf)
 {
   int i;
   char zerobuf[8];
@@ -99,13 +99,13 @@ arm_store_gregset (struct regcache *regc
   memset (zerobuf, 0, 8);
   for (i = 0; i < arm_num_regs; i++)
     if (arm_regmap[i] != -1)
-      supply_register (regcache, i, ((char *) buf) + arm_regmap[i]);
+      supply_register (i, ((char *) buf) + arm_regmap[i]);
     else
-      supply_register (regcache, i, zerobuf);
+      supply_register (i, zerobuf);
 }
 
 static void
-arm_fill_wmmxregset (struct regcache *regcache, void *buf)
+arm_fill_wmmxregset (void *buf)
 {
   int i;
 
@@ -113,16 +113,15 @@ arm_fill_wmmxregset (struct regcache *re
     return;
 
   for (i = 0; i < 16; i++)
-    collect_register (regcache, arm_num_regs + i, (char *) buf + i * 8);
+    collect_register (arm_num_regs + i, (char *) buf + i * 8);
 
   /* We only have access to wcssf, wcasf, and wcgr0-wcgr3.  */
   for (i = 0; i < 6; i++)
-    collect_register (regcache, arm_num_regs + i + 16,
-		      (char *) buf + 16 * 8 + i * 4);
+    collect_register (arm_num_regs + i + 16, (char *) buf + 16 * 8 + i * 4);
 }
 
 static void
-arm_store_wmmxregset (struct regcache *regcache, const void *buf)
+arm_store_wmmxregset (const void *buf)
 {
   int i;
 
@@ -130,16 +129,15 @@ arm_store_wmmxregset (struct regcache *r
     return;
 
   for (i = 0; i < 16; i++)
-    supply_register (regcache, arm_num_regs + i, (char *) buf + i * 8);
+    supply_register (arm_num_regs + i, (char *) buf + i * 8);
 
   /* We only have access to wcssf, wcasf, and wcgr0-wcgr3.  */
   for (i = 0; i < 6; i++)
-    supply_register (regcache, arm_num_regs + i + 16,
-		     (char *) buf + 16 * 8 + i * 4);
+    supply_register (arm_num_regs + i + 16, (char *) buf + 16 * 8 + i * 4);
 }
 
 static void
-arm_fill_vfpregset (struct regcache *regcache, void *buf)
+arm_fill_vfpregset (void *buf)
 {
   int i, num, base;
 
@@ -153,13 +151,13 @@ arm_fill_vfpregset (struct regcache *reg
 
   base = find_regno ("d0");
   for (i = 0; i < num; i++)
-    collect_register (regcache, base + i, (char *) buf + i * 8);
+    collect_register (base + i, (char *) buf + i * 8);
 
-  collect_register_by_name (regcache, "fpscr", (char *) buf + 32 * 8);
+  collect_register_by_name ("fpscr", (char *) buf + 32 * 8);
 }
 
 static void
-arm_store_vfpregset (struct regcache *regcache, const void *buf)
+arm_store_vfpregset (const void *buf)
 {
   int i, num, base;
 
@@ -173,28 +171,28 @@ arm_store_vfpregset (struct regcache *re
 
   base = find_regno ("d0");
   for (i = 0; i < num; i++)
-    supply_register (regcache, base + i, (char *) buf + i * 8);
+    supply_register (base + i, (char *) buf + i * 8);
 
-  supply_register_by_name (regcache, "fpscr", (char *) buf + 32 * 8);
+  supply_register_by_name ("fpscr", (char *) buf + 32 * 8);
 }
 
 extern int debug_threads;
 
 static CORE_ADDR
-arm_get_pc (struct regcache *regcache)
+arm_get_pc ()
 {
   unsigned long pc;
-  collect_register_by_name (regcache, "pc", &pc);
+  collect_register_by_name ("pc", &pc);
   if (debug_threads)
     fprintf (stderr, "stop pc is %08lx\n", pc);
   return pc;
 }
 
 static void
-arm_set_pc (struct regcache *regcache, CORE_ADDR pc)
+arm_set_pc (CORE_ADDR pc)
 {
   unsigned long newpc = pc;
-  supply_register_by_name (regcache, "pc", &newpc);
+  supply_register_by_name ("pc", &newpc);
 }
 
 /* Correct in either endianness.  */
@@ -212,10 +210,9 @@ static const unsigned long arm_eabi_brea
 static int
 arm_breakpoint_at (CORE_ADDR where)
 {
-  struct regcache *regcache = get_thread_regcache (current_inferior, 1);
   unsigned long cpsr;
 
-  collect_register_by_name (regcache, "cpsr", &cpsr);
+  collect_register_by_name ("cpsr", &cpsr);
 
   if (cpsr & 0x20)
     {
@@ -246,11 +243,10 @@ arm_breakpoint_at (CORE_ADDR where)
    is outside of the function.  So rather than importing software single-step,
    we can just run until exit.  */
 static CORE_ADDR
-arm_reinsert_addr (void)
+arm_reinsert_addr ()
 {
-  struct regcache *regcache = get_thread_regcache (current_inferior, 1);
   unsigned long pc;
-  collect_register_by_name (regcache, "lr", &pc);
+  collect_register_by_name ("lr", &pc);
   return pc;
 }
 
--- ./gdb/gdbserver/linux-cris-low.c	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/linux-cris-low.c	2010-01-21 20:33:15.000000000 +0100
@@ -62,20 +62,20 @@ cris_cannot_fetch_register (int regno)
 extern int debug_threads;
 
 static CORE_ADDR
-cris_get_pc (struct regcache *regcache, void)
+cris_get_pc (void)
 {
   unsigned long pc;
-  collect_register_by_name (regcache, "pc", &pc);
+  collect_register_by_name ("pc", &pc);
   if (debug_threads)
     fprintf (stderr, "stop pc is %08lx\n", pc);
   return pc;
 }
 
 static void
-cris_set_pc (struct regcache *regcache, CORE_ADDR pc)
+cris_set_pc (CORE_ADDR pc)
 {
   unsigned long newpc = pc;
-  supply_register_by_name (regcache, "pc", &newpc);
+  supply_register_by_name ("pc", &newpc);
 }
 
 static const unsigned short cris_breakpoint = 0xe938;
@@ -102,9 +102,8 @@ cris_breakpoint_at (CORE_ADDR where)
 static CORE_ADDR
 cris_reinsert_addr (void)
 {
-  struct regcache *regcache = get_thread_regcache (current_inferior, 1);
   unsigned long pc;
-  collect_register_by_name (regcache, "srp", &pc);
+  collect_register_by_name ("srp", &pc);
   return pc;
 }
 
--- ./gdb/gdbserver/linux-crisv32-low.c	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/linux-crisv32-low.c	2010-01-21 20:33:15.000000000 +0100
@@ -54,20 +54,20 @@ static int cris_regmap[] = {
 extern int debug_threads;
 
 static CORE_ADDR
-cris_get_pc (struct regcache *regcache)
+cris_get_pc (void)
 {
   unsigned long pc;
-  collect_register_by_name (regcache, "pc", &pc);
+  collect_register_by_name ("pc", &pc);
   if (debug_threads)
     fprintf (stderr, "stop pc is %08lx\n", pc);
   return pc;
 }
 
 static void
-cris_set_pc (struct regcache *regcache, CORE_ADDR pc)
+cris_set_pc (CORE_ADDR pc)
 {
   unsigned long newpc = pc;
-  supply_register_by_name (regcache, "pc", &newpc);
+  supply_register_by_name ("pc", &newpc);
 }
 
 static const unsigned short cris_breakpoint = 0xe938;
@@ -99,41 +99,39 @@ cris_breakpoint_at (CORE_ADDR where)
 static CORE_ADDR
 cris_reinsert_addr (void)
 {
-  struct regcache *regcache = get_thread_regcache (current_inferior, 1);
   unsigned long pc;
-  collect_register_by_name (regcache, "srp", &pc);
+  collect_register_by_name ("srp", &pc);
   return pc;
 }
 
 static void
-cris_write_data_breakpoint (struct regcache *regcache,
-			    int bp, unsigned long start, unsigned long end)
+cris_write_data_breakpoint (int bp, unsigned long start, unsigned long end)
 {
   switch (bp)
     {
     case 0:
-      supply_register_by_name (regcache, "s3", &start);
-      supply_register_by_name (regcache, "s4", &end);
+      supply_register_by_name ("s3", &start);
+      supply_register_by_name ("s4", &end);
       break;
     case 1:
-      supply_register_by_name (regcache, "s5", &start);
-      supply_register_by_name (regcache, "s6", &end);
+      supply_register_by_name ("s5", &start);
+      supply_register_by_name ("s6", &end);
       break;
     case 2:
-      supply_register_by_name (regcache, "s7", &start);
-      supply_register_by_name (regcache, "s8", &end);
+      supply_register_by_name ("s7", &start);
+      supply_register_by_name ("s8", &end);
       break;
     case 3:
-      supply_register_by_name (regcache, "s9", &start);
-      supply_register_by_name (regcache, "s10", &end);
+      supply_register_by_name ("s9", &start);
+      supply_register_by_name ("s10", &end);
       break;
     case 4:
-      supply_register_by_name (regcache, "s11", &start);
-      supply_register_by_name (regcache, "s12", &end);
+      supply_register_by_name ("s11", &start);
+      supply_register_by_name ("s12", &end);
       break;
     case 5:
-      supply_register_by_name (regcache, "s13", &start);
-      supply_register_by_name (regcache, "s14", &end);
+      supply_register_by_name ("s13", &start);
+      supply_register_by_name ("s14", &end);
       break;
     }
 }
@@ -145,7 +143,6 @@ cris_insert_point (char type, CORE_ADDR 
   unsigned long bp_ctrl;
   unsigned long start, end;
   unsigned long ccs;
-  struct regcache *regcache;
 
   /* Breakpoint/watchpoint types (GDB terminology):
      0 = memory breakpoint for instructions
@@ -161,15 +158,13 @@ cris_insert_point (char type, CORE_ADDR 
       return 1;
     }
 
-  regcache = get_thread_regcache (current_inferior, 1);
-
   /* Read watchpoints are set as access watchpoints, because of GDB's
      inability to deal with pure read watchpoints.  */
   if (type == '3')
     type = '4';
 
   /* Get the configuration register.  */
-  collect_register_by_name (regcache, "s0", &bp_ctrl);
+  collect_register_by_name ("s0", &bp_ctrl);
 
   /* The watchpoint allocation scheme is the simplest possible.
      For example, if a region is watched for read and
@@ -207,19 +202,19 @@ cris_insert_point (char type, CORE_ADDR 
     }
 
   /* Setup the configuration register.  */
-  supply_register_by_name (regcache, "s0", &bp_ctrl);
+  supply_register_by_name ("s0", &bp_ctrl);
 
   /* Setup the range.  */
   start = addr;
   end = addr + len - 1;
 
   /* Configure the watchpoint register.  */
-  cris_write_data_breakpoint (regcache, bp, start, end);
+  cris_write_data_breakpoint (bp, start, end);
 
-  collect_register_by_name (regcache, "ccs", &ccs);
+  collect_register_by_name ("ccs", &ccs);
   /* Set the S1 flag to enable watchpoints.  */
   ccs |= (1 << 19);
-  supply_register_by_name (regcache, "ccs", &ccs);
+  supply_register_by_name ("ccs", &ccs);
 
   return 0;
 }
@@ -230,7 +225,6 @@ cris_remove_point (char type, CORE_ADDR 
   int bp;
   unsigned long bp_ctrl;
   unsigned long start, end;
-  struct regcache *regcache;
 
   /* Breakpoint/watchpoint types:
      0 = memory breakpoint for instructions
@@ -242,15 +236,13 @@ cris_remove_point (char type, CORE_ADDR 
   if (type < '2' || type > '4')
     return -1;
 
-  regcache = get_thread_regcache (current_inferior, 1);
-
   /* Read watchpoints are set as access watchpoints, because of GDB's
      inability to deal with pure read watchpoints.  */
   if (type == '3')
     type = '4';
 
   /* Get the configuration register.  */
-  collect_register_by_name (regcache, "s0", &bp_ctrl);
+  collect_register_by_name ("s0", &bp_ctrl);
 
   /* Try to find a watchpoint that is configured for the
      specified range, then check that read/write also matches.  */
@@ -262,18 +254,18 @@ cris_remove_point (char type, CORE_ADDR 
   unsigned long bp_d_regs[12];
 
   /* Get all range registers to simplify search.  */
-  collect_register_by_name (regcache, "s3", &bp_d_regs[0]);
-  collect_register_by_name (regcache, "s4", &bp_d_regs[1]);
-  collect_register_by_name (regcache, "s5", &bp_d_regs[2]);
-  collect_register_by_name (regcache, "s6", &bp_d_regs[3]);
-  collect_register_by_name (regcache, "s7", &bp_d_regs[4]);
-  collect_register_by_name (regcache, "s8", &bp_d_regs[5]);
-  collect_register_by_name (regcache, "s9", &bp_d_regs[6]);
-  collect_register_by_name (regcache, "s10", &bp_d_regs[7]);
-  collect_register_by_name (regcache, "s11", &bp_d_regs[8]);
-  collect_register_by_name (regcache, "s12", &bp_d_regs[9]);
-  collect_register_by_name (regcache, "s13", &bp_d_regs[10]);
-  collect_register_by_name (regcache, "s14", &bp_d_regs[11]);
+  collect_register_by_name ("s3", &bp_d_regs[0]);
+  collect_register_by_name ("s4", &bp_d_regs[1]);
+  collect_register_by_name ("s5", &bp_d_regs[2]);
+  collect_register_by_name ("s6", &bp_d_regs[3]);
+  collect_register_by_name ("s7", &bp_d_regs[4]);
+  collect_register_by_name ("s8", &bp_d_regs[5]);
+  collect_register_by_name ("s9", &bp_d_regs[6]);
+  collect_register_by_name ("s10", &bp_d_regs[7]);
+  collect_register_by_name ("s11", &bp_d_regs[8]);
+  collect_register_by_name ("s12", &bp_d_regs[9]);
+  collect_register_by_name ("s13", &bp_d_regs[10]);
+  collect_register_by_name ("s14", &bp_d_regs[11]);
 
   for (bp = 0; bp < 6; bp++)
     {
@@ -307,11 +299,11 @@ cris_remove_point (char type, CORE_ADDR 
      start/end addresses.  */
   bp_ctrl &= ~(3 << (2 + (bp * 4)));
   /* Setup the configuration register.  */
-  supply_register_by_name (regcache, "s0", &bp_ctrl);
+  supply_register_by_name ("s0", &bp_ctrl);
 
   start = end = 0;
   /* Configure the watchpoint register.  */
-  cris_write_data_breakpoint (regcache, bp, start, end);
+  cris_write_data_breakpoint (bp, start, end);
 
   /* Note that we don't clear the S1 flag here.  It's done when continuing.  */
   return 0;
--- ./gdb/gdbserver/linux-low.c	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/linux-low.c	2010-01-21 20:33:15.000000000 +0100
@@ -451,8 +451,7 @@ handle_extended_wait (struct lwp_info *e
 static CORE_ADDR
 get_stop_pc (void)
 {
-  struct regcache *regcache = get_thread_regcache (current_inferior, 1);
-  CORE_ADDR stop_pc = (*the_low_target.get_pc) (regcache);
+  CORE_ADDR stop_pc = (*the_low_target.get_pc) ();
 
   if (! get_thread_lwp (current_inferior)->stepping)
     stop_pc -= the_low_target.decr_pc_after_break;
@@ -885,7 +884,6 @@ check_removed_breakpoint (struct lwp_inf
 {
   CORE_ADDR stop_pc;
   struct thread_info *saved_inferior;
-  struct regcache *regcache;
 
   if (event_child->pending_is_breakpoint == 0)
     return 0;
@@ -896,7 +894,7 @@ check_removed_breakpoint (struct lwp_inf
 
   saved_inferior = current_inferior;
   current_inferior = get_lwp_thread (event_child);
-  regcache = get_thread_regcache (current_inferior, 1);
+
   stop_pc = get_stop_pc ();
 
   /* If the PC has changed since we stopped, then we shouldn't do
@@ -932,7 +930,7 @@ check_removed_breakpoint (struct lwp_inf
     {
       if (debug_threads)
 	fprintf (stderr, "Set pc to 0x%lx\n", (long) stop_pc);
-      (*the_low_target.set_pc) (regcache, stop_pc);
+      (*the_low_target.set_pc) (stop_pc);
     }
 
   /* We consumed the pending SIGTRAP.  */
@@ -1065,12 +1063,11 @@ retry:
       && the_low_target.get_pc != NULL)
     {
       struct thread_info *saved_inferior = current_inferior;
-      struct regcache *regcache = get_thread_regcache (current_inferior, 1);
       CORE_ADDR pc;
 
       current_inferior = (struct thread_info *)
 	find_inferior_id (&all_threads, child->head.id);
-      pc = (*the_low_target.get_pc) (regcache);
+      pc = (*the_low_target.get_pc) ();
       fprintf (stderr, "linux_wait_for_lwp: pc is 0x%lx\n", (long) pc);
       current_inferior = saved_inferior;
     }
@@ -1835,8 +1832,7 @@ linux_resume_one_lwp (struct lwp_info *l
 
   if (debug_threads && the_low_target.get_pc != NULL)
     {
-      struct regcache *regcache = get_thread_regcache (current_inferior, 1);
-      CORE_ADDR pc = (*the_low_target.get_pc) (regcache);
+      CORE_ADDR pc = (*the_low_target.get_pc) ();
       fprintf (stderr, "  resuming from pc 0x%lx\n", (long) pc);
     }
 
@@ -2125,7 +2121,7 @@ register_addr (int regnum)
 
 /* Fetch one register.  */
 static void
-fetch_register (struct regcache *regcache, int regno)
+fetch_register (int regno)
 {
   CORE_ADDR regaddr;
   int i, size;
@@ -2164,29 +2160,29 @@ fetch_register (struct regcache *regcach
     }
 
   if (the_low_target.supply_ptrace_register)
-    the_low_target.supply_ptrace_register (regcache, regno, buf);
+    the_low_target.supply_ptrace_register (regno, buf);
   else
-    supply_register (regcache, regno, buf);
+    supply_register (regno, buf);
 
 error_exit:;
 }
 
 /* Fetch all registers, or just one, from the child process.  */
 static void
-usr_fetch_inferior_registers (struct regcache *regcache, int regno)
+usr_fetch_inferior_registers (int regno)
 {
   if (regno == -1)
     for (regno = 0; regno < the_low_target.num_regs; regno++)
-      fetch_register (regcache, regno);
+      fetch_register (regno);
   else
-    fetch_register (regcache, regno);
+    fetch_register (regno);
 }
 
 /* Store our register values back into the inferior.
    If REGNO is -1, do this for all registers.
    Otherwise, REGNO specifies which register (so we can save time).  */
 static void
-usr_store_inferior_registers (struct regcache *regcache, int regno)
+usr_store_inferior_registers (int regno)
 {
   CORE_ADDR regaddr;
   int i, size;
@@ -2211,9 +2207,9 @@ usr_store_inferior_registers (struct reg
       memset (buf, 0, size);
 
       if (the_low_target.collect_ptrace_register)
-	the_low_target.collect_ptrace_register (regcache, regno, buf);
+	the_low_target.collect_ptrace_register (regno, buf);
       else
-	collect_register (regcache, regno, buf);
+	collect_register (regno, buf);
 
       pid = lwpid_of (get_thread_lwp (current_inferior));
       for (i = 0; i < size; i += sizeof (PTRACE_XFER_TYPE))
@@ -2245,7 +2241,7 @@ usr_store_inferior_registers (struct reg
     }
   else
     for (regno = 0; regno < the_low_target.num_regs; regno++)
-      usr_store_inferior_registers (regcache, regno);
+      usr_store_inferior_registers (regno);
 }
 #endif /* HAVE_LINUX_USRREGS */
 
@@ -2254,7 +2250,7 @@ usr_store_inferior_registers (struct reg
 #ifdef HAVE_LINUX_REGSETS
 
 static int
-regsets_fetch_inferior_registers (struct regcache *regcache)
+regsets_fetch_inferior_registers ()
 {
   struct regset_info *regset;
   int saw_general_regs = 0;
@@ -2300,7 +2296,7 @@ regsets_fetch_inferior_registers (struct
 	}
       else if (regset->type == GENERAL_REGS)
 	saw_general_regs = 1;
-      regset->store_function (regcache, buf);
+      regset->store_function (buf);
       regset ++;
       free (buf);
     }
@@ -2311,7 +2307,7 @@ regsets_fetch_inferior_registers (struct
 }
 
 static int
-regsets_store_inferior_registers (struct regcache *regcache)
+regsets_store_inferior_registers ()
 {
   struct regset_info *regset;
   int saw_general_regs = 0;
@@ -2345,7 +2341,7 @@ regsets_store_inferior_registers (struct
       if (res == 0)
 	{
 	  /* Then overlay our cached registers on that.  */
-	  regset->fill_function (regcache, buf);
+	  regset->fill_function (buf);
 
 	  /* Only now do we write the register set.  */
 #ifndef __sparc__
@@ -2395,26 +2391,26 @@ regsets_store_inferior_registers (struct
 
 
 void
-linux_fetch_registers (struct regcache *regcache, int regno)
+linux_fetch_registers (int regno)
 {
 #ifdef HAVE_LINUX_REGSETS
-  if (regsets_fetch_inferior_registers (regcache) == 0)
+  if (regsets_fetch_inferior_registers () == 0)
     return;
 #endif
 #ifdef HAVE_LINUX_USRREGS
-  usr_fetch_inferior_registers (regcache, regno);
+  usr_fetch_inferior_registers (regno);
 #endif
 }
 
 void
-linux_store_registers (struct regcache *regcache, int regno)
+linux_store_registers (int regno)
 {
 #ifdef HAVE_LINUX_REGSETS
-  if (regsets_store_inferior_registers (regcache) == 0)
+  if (regsets_store_inferior_registers () == 0)
     return;
 #endif
 #ifdef HAVE_LINUX_USRREGS
-  usr_store_inferior_registers (regcache, regno);
+  usr_store_inferior_registers (regno);
 #endif
 }
 
--- ./gdb/gdbserver/linux-low.h	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/linux-low.h	2010-01-21 20:33:15.000000000 +0100
@@ -24,8 +24,8 @@
 #include "gdb_proc_service.h"
 
 #ifdef HAVE_LINUX_REGSETS
-typedef void (*regset_fill_func) (struct regcache *, void *);
-typedef void (*regset_store_func) (struct regcache *, const void *);
+typedef void (*regset_fill_func) (void *);
+typedef void (*regset_store_func) (const void *);
 enum regset_type {
   GENERAL_REGS,
   FP_REGS,
@@ -70,8 +70,8 @@ struct linux_target_ops
      store the register, and 2 if failure to store the register
      is acceptable.  */
   int (*cannot_store_register) (int);
-  CORE_ADDR (*get_pc) (struct regcache *regcache);
-  void (*set_pc) (struct regcache *regcache, CORE_ADDR newpc);
+  CORE_ADDR (*get_pc) (void);
+  void (*set_pc) (CORE_ADDR newpc);
   const unsigned char *breakpoint;
   int breakpoint_len;
   CORE_ADDR (*breakpoint_reinsert_addr) (void);
@@ -88,10 +88,8 @@ struct linux_target_ops
 
   /* Hooks to reformat register data for PEEKUSR/POKEUSR (in particular
      for registers smaller than an xfer unit).  */
-  void (*collect_ptrace_register) (struct regcache *regcache,
-				   int regno, char *buf);
-  void (*supply_ptrace_register) (struct regcache *regcache,
-				  int regno, const char *buf);
+  void (*collect_ptrace_register) (int regno, char *buf);
+  void (*supply_ptrace_register) (int regno, const char *buf);
 
   /* Hook to convert from target format to ptrace format and back.
      Returns true if any conversion was done; false otherwise.
--- ./gdb/gdbserver/linux-m32r-low.c	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/linux-m32r-low.c	2010-01-21 20:33:15.000000000 +0100
@@ -53,20 +53,18 @@ m32r_cannot_fetch_register (int regno)
 }
 
 static CORE_ADDR
-m32r_get_pc (struct regcache *regcache)
+m32r_get_pc ()
 {
   unsigned long pc;
-  collect_register_by_name (regcache, "pc", &pc);
-  if (debug_threads)
-    fprintf (stderr, "stop pc is %08lx\n", pc);
+  collect_register_by_name ("pc", &pc);
   return pc;
 }
 
 static void
-m32r_set_pc (struct regcache *regcache, CORE_ADDR pc)
+m32r_set_pc (CORE_ADDR pc)
 {
   unsigned long newpc = pc;
-  supply_register_by_name (regcache, "pc", &newpc);
+  supply_register_by_name ("pc", &newpc);
 }
 
 static const unsigned short m32r_breakpoint = 0x10f1;
--- ./gdb/gdbserver/linux-m68k-low.c	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/linux-m68k-low.c	2010-01-21 20:33:15.000000000 +0100
@@ -71,40 +71,40 @@ m68k_cannot_fetch_register (int regno)
 #include <sys/ptrace.h>
 
 static void
-m68k_fill_gregset (struct regcache *regcache, void *buf)
+m68k_fill_gregset (void *buf)
 {
   int i;
 
   for (i = 0; i < m68k_num_gregs; i++)
-    collect_register (regcache, i, (char *) buf + m68k_regmap[i]);
+    collect_register (i, (char *) buf + m68k_regmap[i]);
 }
 
 static void
-m68k_store_gregset (struct regcache *regcache, const void *buf)
+m68k_store_gregset (const void *buf)
 {
   int i;
 
   for (i = 0; i < m68k_num_gregs; i++)
-    supply_register (regcache, i, (const char *) buf + m68k_regmap[i]);
+    supply_register (i, (const char *) buf + m68k_regmap[i]);
 }
 
 static void
-m68k_fill_fpregset (struct regcache *regcache, void *buf)
+m68k_fill_fpregset (void *buf)
 {
   int i;
 
   for (i = m68k_num_gregs; i < m68k_num_regs; i++)
-    collect_register (regcache, i, ((char *) buf
-			 + (m68k_regmap[i] - m68k_regmap[m68k_num_gregs])));
+    collect_register (i, ((char *) buf
+			  + (m68k_regmap[i] - m68k_regmap[m68k_num_gregs])));
 }
 
 static void
-m68k_store_fpregset (struct regcache *regcache, const void *buf)
+m68k_store_fpregset (const void *buf)
 {
   int i;
 
   for (i = m68k_num_gregs; i < m68k_num_regs; i++)
-    supply_register (regcache, i, ((const char *) buf
+    supply_register (i, ((const char *) buf
 			 + (m68k_regmap[i] - m68k_regmap[m68k_num_gregs])));
 }
 
@@ -126,20 +126,20 @@ static const unsigned char m68k_breakpoi
 #define m68k_breakpoint_len 2
 
 static CORE_ADDR
-m68k_get_pc (struct regcache *regcache)
+m68k_get_pc ()
 {
   unsigned long pc;
 
-  collect_register_by_name (regcache, "pc", &pc);
+  collect_register_by_name ("pc", &pc);
   return pc;
 }
 
 static void
-m68k_set_pc (struct regcache *regcache, CORE_ADDR value)
+m68k_set_pc (CORE_ADDR value)
 {
   unsigned long newpc = value;
 
-  supply_register_by_name (regcache, "pc", &newpc);
+  supply_register_by_name ("pc", &newpc);
 }
 
 static int
--- ./gdb/gdbserver/linux-mips-low.c	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/linux-mips-low.c	2010-01-21 20:33:15.000000000 +0100
@@ -115,15 +115,15 @@ mips_cannot_store_register (int regno)
 }
 
 static CORE_ADDR
-mips_get_pc (struct regcache *regcache)
+mips_get_pc ()
 {
   union mips_register pc;
-  collect_register_by_name (regcache, "pc", pc.buf);
+  collect_register_by_name ("pc", pc.buf);
   return register_size (0) == 4 ? pc.reg32 : pc.reg64;
 }
 
 static void
-mips_set_pc (struct regcache *regcache, CORE_ADDR pc)
+mips_set_pc (CORE_ADDR pc)
 {
   union mips_register newpc;
   if (register_size (0) == 4)
@@ -131,7 +131,7 @@ mips_set_pc (struct regcache *regcache, 
   else
     newpc.reg64 = pc;
 
-  supply_register_by_name (regcache, "pc", newpc.buf);
+  supply_register_by_name ("pc", newpc.buf);
 }
 
 /* Correct in either endianness.  */
@@ -142,11 +142,10 @@ static const unsigned int mips_breakpoin
    is outside of the function.  So rather than importing software single-step,
    we can just run until exit.  */
 static CORE_ADDR
-mips_reinsert_addr (void)
+mips_reinsert_addr ()
 {
-  struct regcache *regcache = get_thread_regcache (current_inferior, 1);
   union mips_register ra;
-  collect_register_by_name (regcache, "r31", ra.buf);
+  collect_register_by_name ("r31", ra.buf);
   return register_size (0) == 4 ? ra.reg32 : ra.reg64;
 }
 
@@ -184,26 +183,24 @@ ps_get_thread_area (const struct ps_proc
 #ifdef HAVE_PTRACE_GETREGS
 
 static void
-mips_collect_register (struct regcache *regcache,
-		       int use_64bit, int regno, union mips_register *reg)
+mips_collect_register (int use_64bit, int regno, union mips_register *reg)
 {
   union mips_register tmp_reg;
 
   if (use_64bit)
     {
-      collect_register (regcache, regno, &tmp_reg.reg64);
+      collect_register (regno, &tmp_reg.reg64);
       *reg = tmp_reg;
     }
   else
     {
-      collect_register (regcache, regno, &tmp_reg.reg32);
+      collect_register (regno, &tmp_reg.reg32);
       reg->reg64 = tmp_reg.reg32;
     }
 }
 
 static void
-mips_supply_register (struct regcache *regcache,
-		      int use_64bit, int regno, const union mips_register *reg)
+mips_supply_register (int use_64bit, int regno, const union mips_register *reg)
 {
   int offset = 0;
 
@@ -212,35 +209,33 @@ mips_supply_register (struct regcache *r
   if (__BYTE_ORDER == __BIG_ENDIAN && !use_64bit)
     offset = 4;
 
-  supply_register (regcache, regno, reg->buf + offset);
+  supply_register (regno, reg->buf + offset);
 }
 
 static void
-mips_collect_register_32bit (struct regcache *regcache,
-			     int use_64bit, int regno, unsigned char *buf)
+mips_collect_register_32bit (int use_64bit, int regno, unsigned char *buf)
 {
   union mips_register tmp_reg;
   int reg32;
 
-  mips_collect_register (regcache, use_64bit, regno, &tmp_reg);
+  mips_collect_register (use_64bit, regno, &tmp_reg);
   reg32 = tmp_reg.reg64;
   memcpy (buf, &reg32, 4);
 }
 
 static void
-mips_supply_register_32bit (struct regcache *regcache,
-			    int use_64bit, int regno, const unsigned char *buf)
+mips_supply_register_32bit (int use_64bit, int regno, const unsigned char *buf)
 {
   union mips_register tmp_reg;
   int reg32;
 
   memcpy (&reg32, buf, 4);
   tmp_reg.reg64 = reg32;
-  mips_supply_register (regcache, use_64bit, regno, &tmp_reg);
+  mips_supply_register (use_64bit, regno, &tmp_reg);
 }
 
 static void
-mips_fill_gregset (struct regcache *regcache, void *buf)
+mips_fill_gregset (void *buf)
 {
   union mips_register *regset = buf;
   int i, use_64bit;
@@ -248,27 +243,20 @@ mips_fill_gregset (struct regcache *regc
   use_64bit = (register_size (0) == 8);
 
   for (i = 1; i < 32; i++)
-    mips_collect_register (regcache, use_64bit, i, regset + i);
+    mips_collect_register (use_64bit, i, regset + i);
 
-  mips_collect_register (regcache, use_64bit,
-			 find_regno ("lo"), regset + 32);
-  mips_collect_register (regcache, use_64bit,
-			 find_regno ("hi"), regset + 33);
-  mips_collect_register (regcache, use_64bit,
-			 find_regno ("pc"), regset + 34);
-  mips_collect_register (regcache, use_64bit,
-			 find_regno ("badvaddr"), regset + 35);
-  mips_collect_register (regcache, use_64bit,
-			 find_regno ("status"), regset + 36);
-  mips_collect_register (regcache, use_64bit,
-			 find_regno ("cause"), regset + 37);
+  mips_collect_register (use_64bit, find_regno ("lo"), regset + 32);
+  mips_collect_register (use_64bit, find_regno ("hi"), regset + 33);
+  mips_collect_register (use_64bit, find_regno ("pc"), regset + 34);
+  mips_collect_register (use_64bit, find_regno ("badvaddr"), regset + 35);
+  mips_collect_register (use_64bit, find_regno ("status"), regset + 36);
+  mips_collect_register (use_64bit, find_regno ("cause"), regset + 37);
 
-  mips_collect_register (regcache, use_64bit,
-			 find_regno ("restart"), regset + 0);
+  mips_collect_register (use_64bit, find_regno ("restart"), regset + 0);
 }
 
 static void
-mips_store_gregset (struct regcache *regcache, const void *buf)
+mips_store_gregset (const void *buf)
 {
   const union mips_register *regset = buf;
   int i, use_64bit;
@@ -276,24 +264,20 @@ mips_store_gregset (struct regcache *reg
   use_64bit = (register_size (0) == 8);
 
   for (i = 0; i < 32; i++)
-    mips_supply_register (regcache, use_64bit, i, regset + i);
+    mips_supply_register (use_64bit, i, regset + i);
 
-  mips_supply_register (regcache, use_64bit, find_regno ("lo"), regset + 32);
-  mips_supply_register (regcache, use_64bit, find_regno ("hi"), regset + 33);
-  mips_supply_register (regcache, use_64bit, find_regno ("pc"), regset + 34);
-  mips_supply_register (regcache, use_64bit,
-			find_regno ("badvaddr"), regset + 35);
-  mips_supply_register (regcache, use_64bit,
-			find_regno ("status"), regset + 36);
-  mips_supply_register (regcache, use_64bit,
-			find_regno ("cause"), regset + 37);
+  mips_supply_register (use_64bit, find_regno ("lo"), regset + 32);
+  mips_supply_register (use_64bit, find_regno ("hi"), regset + 33);
+  mips_supply_register (use_64bit, find_regno ("pc"), regset + 34);
+  mips_supply_register (use_64bit, find_regno ("badvaddr"), regset + 35);
+  mips_supply_register (use_64bit, find_regno ("status"), regset + 36);
+  mips_supply_register (use_64bit, find_regno ("cause"), regset + 37);
 
-  mips_supply_register (regcache, use_64bit,
-			find_regno ("restart"), regset + 0);
+  mips_supply_register (use_64bit, find_regno ("restart"), regset + 0);
 }
 
 static void
-mips_fill_fpregset (struct regcache *regcache, void *buf)
+mips_fill_fpregset (void *buf)
 {
   union mips_register *regset = buf;
   int i, use_64bit, first_fp, big_endian;
@@ -305,19 +289,18 @@ mips_fill_fpregset (struct regcache *reg
   /* See GDB for a discussion of this peculiar layout.  */
   for (i = 0; i < 32; i++)
     if (use_64bit)
-      collect_register (regcache, first_fp + i, regset[i].buf);
+      collect_register (first_fp + i, regset[i].buf);
     else
-      collect_register (regcache, first_fp + i,
+      collect_register (first_fp + i,
 			regset[i & ~1].buf + 4 * (big_endian != (i & 1)));
 
-  mips_collect_register_32bit (regcache, use_64bit,
-			       find_regno ("fcsr"), regset[32].buf);
-  mips_collect_register_32bit (regcache, use_64bit, find_regno ("fir"),
+  mips_collect_register_32bit (use_64bit, find_regno ("fcsr"), regset[32].buf);
+  mips_collect_register_32bit (use_64bit, find_regno ("fir"),
 			       regset[32].buf + 4);
 }
 
 static void
-mips_store_fpregset (struct regcache *regcache, const void *buf)
+mips_store_fpregset (const void *buf)
 {
   const union mips_register *regset = buf;
   int i, use_64bit, first_fp, big_endian;
@@ -329,14 +312,13 @@ mips_store_fpregset (struct regcache *re
   /* See GDB for a discussion of this peculiar layout.  */
   for (i = 0; i < 32; i++)
     if (use_64bit)
-      supply_register (regcache, first_fp + i, regset[i].buf);
+      supply_register (first_fp + i, regset[i].buf);
     else
-      supply_register (regcache, first_fp + i,
+      supply_register (first_fp + i,
 		       regset[i & ~1].buf + 4 * (big_endian != (i & 1)));
 
-  mips_supply_register_32bit (regcache, use_64bit,
-			      find_regno ("fcsr"), regset[32].buf);
-  mips_supply_register_32bit (regcache, use_64bit, find_regno ("fir"),
+  mips_supply_register_32bit (use_64bit, find_regno ("fcsr"), regset[32].buf);
+  mips_supply_register_32bit (use_64bit, find_regno ("fir"),
 			      regset[32].buf + 4);
 }
 #endif /* HAVE_PTRACE_GETREGS */
--- ./gdb/gdbserver/linux-ppc-low.c	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/linux-ppc-low.c	2010-01-21 20:33:15.000000000 +0100
@@ -169,27 +169,26 @@ ppc_cannot_fetch_register (int regno)
 }
 
 static void
-ppc_collect_ptrace_register (struct regcache *regcache, int regno, char *buf)
+ppc_collect_ptrace_register (int regno, char *buf)
 {
   int size = register_size (regno);
 
   memset (buf, 0, sizeof (long));
 
   if (size < sizeof (long))
-    collect_register (regcache, regno, buf + sizeof (long) - size);
+    collect_register (regno, buf + sizeof (long) - size);
   else
-    collect_register (regcache, regno, buf);
+    collect_register (regno, buf);
 }
 
 static void
-ppc_supply_ptrace_register (struct regcache *regcache,
-			    int regno, const char *buf)
+ppc_supply_ptrace_register (int regno, const char *buf)
 {
   int size = register_size (regno);
   if (size < sizeof (long))
-    supply_register (regcache, regno, buf + sizeof (long) - size);
+    supply_register (regno, buf + sizeof (long) - size);
   else
-    supply_register (regcache, regno, buf);
+    supply_register (regno, buf);
 }
 
 
@@ -200,7 +199,7 @@ ppc_supply_ptrace_register (struct regca
    return to FD and ADDR the file handle and NPC parameter address
    used with the system call.  Return non-zero if successful.  */
 static int
-parse_spufs_run (struct regcache *regcache, int *fd, CORE_ADDR *addr)
+parse_spufs_run (int *fd, CORE_ADDR *addr)
 {
   CORE_ADDR curr_pc;
   int curr_insn;
@@ -209,10 +208,10 @@ parse_spufs_run (struct regcache *regcac
   if (register_size (0) == 4)
     {
       unsigned int pc, r0, r3, r4;
-      collect_register_by_name (regcache, "pc", &pc);
-      collect_register_by_name (regcache, "r0", &r0);
-      collect_register_by_name (regcache, "orig_r3", &r3);
-      collect_register_by_name (regcache, "r4", &r4);
+      collect_register_by_name ("pc", &pc);
+      collect_register_by_name ("r0", &r0);
+      collect_register_by_name ("orig_r3", &r3);
+      collect_register_by_name ("r4", &r4);
       curr_pc = (CORE_ADDR) pc;
       curr_r0 = (int) r0;
       *fd = (int) r3;
@@ -221,10 +220,10 @@ parse_spufs_run (struct regcache *regcac
   else
     {
       unsigned long pc, r0, r3, r4;
-      collect_register_by_name (regcache, "pc", &pc);
-      collect_register_by_name (regcache, "r0", &r0);
-      collect_register_by_name (regcache, "orig_r3", &r3);
-      collect_register_by_name (regcache, "r4", &r4);
+      collect_register_by_name ("pc", &pc);
+      collect_register_by_name ("r0", &r0);
+      collect_register_by_name ("orig_r3", &r3);
+      collect_register_by_name ("r4", &r4);
       curr_pc = (CORE_ADDR) pc;
       curr_r0 = (int) r0;
       *fd = (int) r3;
@@ -246,12 +245,12 @@ parse_spufs_run (struct regcache *regcac
 }
 
 static CORE_ADDR
-ppc_get_pc (struct regcache *regcache)
+ppc_get_pc (void)
 {
   CORE_ADDR addr;
   int fd;
 
-  if (parse_spufs_run (regcache, &fd, &addr))
+  if (parse_spufs_run (&fd, &addr))
     {
       unsigned int pc;
       (*the_target->read_memory) (addr, (unsigned char *) &pc, 4);
@@ -260,24 +259,24 @@ ppc_get_pc (struct regcache *regcache)
   else if (register_size (0) == 4)
     {
       unsigned int pc;
-      collect_register_by_name (regcache, "pc", &pc);
+      collect_register_by_name ("pc", &pc);
       return (CORE_ADDR) pc;
     }
   else
     {
       unsigned long pc;
-      collect_register_by_name (regcache, "pc", &pc);
+      collect_register_by_name ("pc", &pc);
       return (CORE_ADDR) pc;
     }
 }
 
 static void
-ppc_set_pc (struct regcache *regcache, CORE_ADDR pc)
+ppc_set_pc (CORE_ADDR pc)
 {
   CORE_ADDR addr;
   int fd;
 
-  if (parse_spufs_run (regcache, &fd, &addr))
+  if (parse_spufs_run (&fd, &addr))
     {
       unsigned int newpc = pc;
       (*the_target->write_memory) (addr, (unsigned char *) &newpc, 4);
@@ -285,12 +284,12 @@ ppc_set_pc (struct regcache *regcache, C
   else if (register_size (0) == 4)
     {
       unsigned int newpc = pc;
-      supply_register_by_name (regcache, "pc", &newpc);
+      supply_register_by_name ("pc", &newpc);
     }
   else
     {
       unsigned long newpc = pc;
-      supply_register_by_name (regcache, "pc", &newpc);
+      supply_register_by_name ("pc", &newpc);
     }
 }
 
@@ -450,18 +449,18 @@ ppc_breakpoint_at (CORE_ADDR where)
 /* Provide only a fill function for the general register set.  ps_lgetregs
    will use this for NPTL support.  */
 
-static void ppc_fill_gregset (struct regcache *regcache, void *buf)
+static void ppc_fill_gregset (void *buf)
 {
   int i;
 
   for (i = 0; i < 32; i++)
-    ppc_collect_ptrace_register (regcache, i, (char *) buf + ppc_regmap[i]);
+    ppc_collect_ptrace_register (i, (char *) buf + ppc_regmap[i]);
 
   for (i = 64; i < 70; i++)
-    ppc_collect_ptrace_register (regcache, i, (char *) buf + ppc_regmap[i]);
+    ppc_collect_ptrace_register (i, (char *) buf + ppc_regmap[i]);
 
   for (i = 71; i < 73; i++)
-    ppc_collect_ptrace_register (regcache, i, (char *) buf + ppc_regmap[i]);
+    ppc_collect_ptrace_register (i, (char *) buf + ppc_regmap[i]);
 }
 
 #ifndef PTRACE_GETVSXREGS
@@ -472,7 +471,7 @@ static void ppc_fill_gregset (struct reg
 #define SIZEOF_VSXREGS 32*8
 
 static void
-ppc_fill_vsxregset (struct regcache *regcache, void *buf)
+ppc_fill_vsxregset (void *buf)
 {
   int i, base;
   char *regset = buf;
@@ -482,11 +481,11 @@ ppc_fill_vsxregset (struct regcache *reg
 
   base = find_regno ("vs0h");
   for (i = 0; i < 32; i++)
-    collect_register (regcache, base + i, &regset[i * 8]);
+    collect_register (base + i, &regset[i * 8]);
 }
 
 static void
-ppc_store_vsxregset (struct regcache *regcache, const void *buf)
+ppc_store_vsxregset (const void *buf)
 {
   int i, base;
   const char *regset = buf;
@@ -496,7 +495,7 @@ ppc_store_vsxregset (struct regcache *re
 
   base = find_regno ("vs0h");
   for (i = 0; i < 32; i++)
-    supply_register (regcache, base + i, &regset[i * 8]);
+    supply_register (base + i, &regset[i * 8]);
 }
 
 #ifndef PTRACE_GETVRREGS
@@ -507,7 +506,7 @@ ppc_store_vsxregset (struct regcache *re
 #define SIZEOF_VRREGS 33*16+4
 
 static void
-ppc_fill_vrregset (struct regcache *regcache, void *buf)
+ppc_fill_vrregset (void *buf)
 {
   int i, base;
   char *regset = buf;
@@ -517,14 +516,14 @@ ppc_fill_vrregset (struct regcache *regc
 
   base = find_regno ("vr0");
   for (i = 0; i < 32; i++)
-    collect_register (regcache, base + i, &regset[i * 16]);
+    collect_register (base + i, &regset[i * 16]);
 
-  collect_register_by_name (regcache, "vscr", &regset[32 * 16 + 12]);
-  collect_register_by_name (regcache, "vrsave", &regset[33 * 16]);
+  collect_register_by_name ("vscr", &regset[32 * 16 + 12]);
+  collect_register_by_name ("vrsave", &regset[33 * 16]);
 }
 
 static void
-ppc_store_vrregset (struct regcache *regcache, const void *buf)
+ppc_store_vrregset (const void *buf)
 {
   int i, base;
   const char *regset = buf;
@@ -534,10 +533,10 @@ ppc_store_vrregset (struct regcache *reg
 
   base = find_regno ("vr0");
   for (i = 0; i < 32; i++)
-    supply_register (regcache, base + i, &regset[i * 16]);
+    supply_register (base + i, &regset[i * 16]);
 
-  supply_register_by_name (regcache, "vscr", &regset[32 * 16 + 12]);
-  supply_register_by_name (regcache, "vrsave", &regset[33 * 16]);
+  supply_register_by_name ("vscr", &regset[32 * 16 + 12]);
+  supply_register_by_name ("vrsave", &regset[33 * 16]);
 }
 
 #ifndef PTRACE_GETEVRREGS
@@ -553,7 +552,7 @@ struct gdb_evrregset_t
 };
 
 static void
-ppc_fill_evrregset (struct regcache *regcache, void *buf)
+ppc_fill_evrregset (void *buf)
 {
   int i, ev0;
   struct gdb_evrregset_t *regset = buf;
@@ -563,14 +562,14 @@ ppc_fill_evrregset (struct regcache *reg
 
   ev0 = find_regno ("ev0h");
   for (i = 0; i < 32; i++)
-    collect_register (regcache, ev0 + i, &regset->evr[i]);
+    collect_register (ev0 + i, &regset->evr[i]);
 
-  collect_register_by_name (regcache, "acc", &regset->acc);
-  collect_register_by_name (regcache, "spefscr", &regset->spefscr);
+  collect_register_by_name ("acc", &regset->acc);
+  collect_register_by_name ("spefscr", &regset->spefscr);
 }
 
 static void
-ppc_store_evrregset (struct regcache *regcache, const void *buf)
+ppc_store_evrregset (const void *buf)
 {
   int i, ev0;
   const struct gdb_evrregset_t *regset = buf;
@@ -580,10 +579,10 @@ ppc_store_evrregset (struct regcache *re
 
   ev0 = find_regno ("ev0h");
   for (i = 0; i < 32; i++)
-    supply_register (regcache, ev0 + i, &regset->evr[i]);
+    supply_register (ev0 + i, &regset->evr[i]);
 
-  supply_register_by_name (regcache, "acc", &regset->acc);
-  supply_register_by_name (regcache, "spefscr", &regset->spefscr);
+  supply_register_by_name ("acc", &regset->acc);
+  supply_register_by_name ("spefscr", &regset->spefscr);
 }
 
 struct regset_info target_regsets[] = {
--- ./gdb/gdbserver/linux-s390-low.c	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/linux-s390-low.c	2010-01-21 20:33:15.000000000 +0100
@@ -106,7 +106,7 @@ s390_cannot_store_register (int regno)
 }
 
 static void
-s390_collect_ptrace_register (struct regcache *regcache, int regno, char *buf)
+s390_collect_ptrace_register (int regno, char *buf)
 {
   int size = register_size (regno);
   if (size < sizeof (long))
@@ -123,9 +123,9 @@ s390_collect_ptrace_register (struct reg
 	}
       else if (regaddr == PT_PSWADDR
 	       || (regaddr >= PT_GPR0 && regaddr <= PT_GPR15))
-	collect_register (regcache, regno, buf + sizeof (long) - size);
+	collect_register (regno, buf + sizeof (long) - size);
       else
-	collect_register (regcache, regno, buf);
+	collect_register (regno, buf);
 
       /* When debugging a 32-bit inferior on a 64-bit host, make sure
 	 the 31-bit addressing mode bit is set in the PSW mask.  */
@@ -137,7 +137,7 @@ s390_collect_ptrace_register (struct reg
 }
 
 static void
-s390_supply_ptrace_register (struct regcache *regcache, int regno, const char *buf)
+s390_supply_ptrace_register (int regno, const char *buf)
 {
   int size = register_size (regno);
   if (size < sizeof (long))
@@ -152,18 +152,18 @@ s390_supply_ptrace_register (struct regc
 	}
       else if (regaddr == PT_PSWADDR
 	       || (regaddr >= PT_GPR0 && regaddr <= PT_GPR15))
-	supply_register (regcache, regno, buf + sizeof (long) - size);
+	supply_register (regno, buf + sizeof (long) - size);
       else
-	supply_register (regcache, regno, buf);
+	supply_register (regno, buf);
     }
   else
-    supply_register (regcache, regno, buf);
+    supply_register (regno, buf);
 }
 
 /* Provide only a fill function for the general register set.  ps_lgetregs
    will use this for NPTL support.  */
 
-static void s390_fill_gregset (struct regcache *regcache, void *buf)
+static void s390_fill_gregset (void *buf)
 {
   int i;
 
@@ -173,7 +173,7 @@ static void s390_fill_gregset (struct re
 	  || the_low_target.regmap[i] > PT_ACR15)
 	continue;
 
-      s390_collect_ptrace_register (regcache, i, (char *) buf
+      s390_collect_ptrace_register (i, (char *) buf
 				       + the_low_target.regmap[i]);
     }
 }
@@ -188,12 +188,12 @@ static const unsigned char s390_breakpoi
 #define s390_breakpoint_len 2
 
 static CORE_ADDR
-s390_get_pc (struct regcache *regcache)
+s390_get_pc ()
 {
   if (register_size (0) == 4)
     {
       unsigned int pc;
-      collect_register_by_name (regcache, "pswa", &pc);
+      collect_register_by_name ("pswa", &pc);
 #ifndef __s390x__
       pc &= 0x7fffffff;
 #endif
@@ -202,13 +202,13 @@ s390_get_pc (struct regcache *regcache)
   else
     {
       unsigned long pc;
-      collect_register_by_name (regcache, "pswa", &pc);
+      collect_register_by_name ("pswa", &pc);
       return pc;
     }
 }
 
 static void
-s390_set_pc (struct regcache *regcache, CORE_ADDR newpc)
+s390_set_pc (CORE_ADDR newpc)
 {
   if (register_size (0) == 4)
     {
@@ -216,12 +216,12 @@ s390_set_pc (struct regcache *regcache, 
 #ifndef __s390x__
       pc |= 0x80000000;
 #endif
-      supply_register_by_name (regcache, "pswa", &pc);
+      supply_register_by_name ("pswa", &pc);
     }
   else
     {
       unsigned long pc = newpc;
-      supply_register_by_name (regcache, "pswa", &pc);
+      supply_register_by_name ("pswa", &pc);
     }
 }
 
@@ -268,8 +268,7 @@ s390_arch_setup (void)
 #ifdef __s390x__
   {
     unsigned int pswm;
-    struct regcache *regcache = get_thread_regcache (current_inferior, 1);
-    collect_register_by_name (regcache, "pswm", &pswm);
+    collect_register_by_name ("pswm", &pswm);
     if (pswm & 1)
       init_registers_s390x_linux64 ();
 
--- ./gdb/gdbserver/linux-sh-low.c	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/linux-sh-low.c	2010-01-21 20:33:15.000000000 +0100
@@ -59,18 +59,18 @@ sh_cannot_fetch_register (int regno)
 }
 
 static CORE_ADDR
-sh_get_pc (struct regcache *regcache)
+sh_get_pc ()
 {
   unsigned long pc;
-  collect_register_by_name (regcache, "pc", &pc);
+  collect_register_by_name ("pc", &pc);
   return pc;
 }
 
 static void
-sh_set_pc (struct regcache *regcache, CORE_ADDR pc)
+sh_set_pc (CORE_ADDR pc)
 {
   unsigned long newpc = pc;
-  supply_register_by_name (regcache, "pc", &newpc);
+  supply_register_by_name ("pc", &newpc);
 }
 
 /* Correct in either endianness, obviously.  */
@@ -94,13 +94,13 @@ sh_breakpoint_at (CORE_ADDR where)
 /* Provide only a fill function for the general register set.  ps_lgetregs
    will use this for NPTL support.  */
 
-static void sh_fill_gregset (struct regcache *regcache, void *buf)
+static void sh_fill_gregset (void *buf)
 {
   int i;
 
   for (i = 0; i < 23; i++)
     if (sh_regmap[i] != -1)
-      collect_register (regcache, i, (char *) buf + sh_regmap[i]);
+      collect_register (i, (char *) buf + sh_regmap[i]);
 }
 
 struct regset_info target_regsets[] = {
--- ./gdb/gdbserver/linux-sparc-low.c	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/linux-sparc-low.c	2010-01-21 20:33:15.000000000 +0100
@@ -113,7 +113,7 @@ sparc_cannot_fetch_register (int regno)
 }
 
 static void
-sparc_fill_gregset_to_stack (struct regcache *regcache, const void *buf)
+sparc_fill_gregset_to_stack (const void *buf)
 {
   int i;
   CORE_ADDR addr = 0;
@@ -128,14 +128,14 @@ sparc_fill_gregset_to_stack (struct regc
 
   for (i = l0_regno; i <= i7_regno; i++)
     {
-      collect_register (regcache, i, tmp_reg_buf);
+      collect_register (i, tmp_reg_buf);
       (*the_target->write_memory) (addr, tmp_reg_buf, sizeof(tmp_reg_buf));
       addr += sizeof(tmp_reg_buf);
     }
 }
 
 static void
-sparc_fill_gregset (struct regcache *regcache, void *buf)
+sparc_fill_gregset (void *buf)
 {
   int i;
   int range;
@@ -143,25 +143,25 @@ sparc_fill_gregset (struct regcache *reg
   for (range = 0; range < N_GREGS_RANGES; range++)
     for (i = gregs_ranges[range].regno_start; i <= gregs_ranges[range].regno_end; i++)
       if (sparc_regmap[i] != -1)
-	collect_register (regcache, i, ((char *) buf) + sparc_regmap[i]);
+	collect_register (i, ((char *) buf) + sparc_regmap[i]);
 
-  sparc_fill_gregset_to_stack (regcache, buf);
+  sparc_fill_gregset_to_stack (buf);
 }
 
 static void
-sparc_fill_fpregset (struct regcache *regcache, void *buf)
+sparc_fill_fpregset (void *buf)
 {
   int i;
   int range;
 
   for (range = 0; range < N_FPREGS_RANGES; range++)
     for (i = fpregs_ranges[range].regno_start; i <= fpregs_ranges[range].regno_end; i++)
-      collect_register (regcache, i, ((char *) buf) + sparc_regmap[i]);
+      collect_register (i, ((char *) buf) + sparc_regmap[i]);
 
 }
 
 static void
-sparc_store_gregset_from_stack (struct regcache *regcache, const void *buf)
+sparc_store_gregset_from_stack (const void *buf)
 {
   int i;
   CORE_ADDR addr = 0;
@@ -177,13 +177,13 @@ sparc_store_gregset_from_stack (struct r
   for (i = l0_regno; i <= i7_regno; i++)
     {
       (*the_target->read_memory) (addr, tmp_reg_buf, sizeof(tmp_reg_buf));
-      supply_register (regcache, i, tmp_reg_buf);
+      supply_register (i, tmp_reg_buf);
       addr += sizeof(tmp_reg_buf);
     }
 }
 
 static void
-sparc_store_gregset (struct regcache *regcache, const void *buf)
+sparc_store_gregset (const void *buf)
 {
   int i;
   char zerobuf[8];
@@ -194,33 +194,31 @@ sparc_store_gregset (struct regcache *re
   for (range = 0; range < N_GREGS_RANGES; range++)
     for (i = gregs_ranges[range].regno_start; i <= gregs_ranges[range].regno_end; i++)
       if (sparc_regmap[i] != -1)
-	supply_register (regcache, i, ((char *) buf) + sparc_regmap[i]);
+	supply_register (i, ((char *) buf) + sparc_regmap[i]);
       else
-	supply_register (regcache, i, zerobuf);
+	supply_register (i, zerobuf);
 
-  sparc_store_gregset_from_stack (regcache, buf);
+  sparc_store_gregset_from_stack (buf);
 }
 
 static void
-sparc_store_fpregset (struct regcache *regcache, const void *buf)
+sparc_store_fpregset (const void *buf)
 {
   int i;
   int range;
 
   for (range = 0; range < N_FPREGS_RANGES; range++)
-    for (i = fpregs_ranges[range].regno_start;
-	 i <= fpregs_ranges[range].regno_end;
-	 i++)
-      supply_register (regcache, i, ((char *) buf) + sparc_regmap[i]);
+    for (i = fpregs_ranges[range].regno_start; i <= fpregs_ranges[range].regno_end; i++)
+      supply_register (i, ((char *) buf) + sparc_regmap[i]);
 }
 
 extern int debug_threads;
 
 static CORE_ADDR
-sparc_get_pc (struct regcache *regcache)
+sparc_get_pc ()
 {
-  unsigned long pc;
-  collect_register_by_name (regcache, "pc", &pc);
+  CORE_ADDR pc;
+  collect_register_by_name ("pc", &pc);
   if (debug_threads)
     fprintf (stderr, "stop pc is %08lx\n", pc);
   return pc;
@@ -249,12 +247,11 @@ sparc_breakpoint_at (CORE_ADDR where)
    is outside of the function.  So rather than importing software single-step,
    we can just run until exit.  */
 static CORE_ADDR
-sparc_reinsert_addr (void)
+sparc_reinsert_addr ()
 {
-  struct regcache *regcache = get_thread_regcache (current_inferior, 1);
   CORE_ADDR lr;
   /* O7 is the equivalent to the 'lr' of other archs.  */
-  collect_register_by_name (regcache, "o7", &lr);
+  collect_register_by_name ("o7", &lr);
   return lr;
 }
 
--- ./gdb/gdbserver/linux-x86-low.c	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/linux-x86-low.c	2010-01-21 20:33:15.000000000 +0100
@@ -173,7 +173,7 @@ i386_cannot_fetch_register (int regno)
 }
 
 static void
-x86_fill_gregset (struct regcache *regcache, void *buf)
+x86_fill_gregset (void *buf)
 {
   int i;
 
@@ -182,20 +182,19 @@ x86_fill_gregset (struct regcache *regca
     {
       for (i = 0; i < X86_64_NUM_REGS; i++)
 	if (x86_64_regmap[i] != -1)
-	  collect_register (regcache, i, ((char *) buf) + x86_64_regmap[i]);
+	  collect_register (i, ((char *) buf) + x86_64_regmap[i]);
       return;
     }
 #endif
 
   for (i = 0; i < I386_NUM_REGS; i++)
-    collect_register (regcache, i, ((char *) buf) + i386_regmap[i]);
+    collect_register (i, ((char *) buf) + i386_regmap[i]);
 
-  collect_register_by_name (regcache, "orig_eax",
-			    ((char *) buf) + ORIG_EAX * 4);
+  collect_register_by_name ("orig_eax", ((char *) buf) + ORIG_EAX * 4);
 }
 
 static void
-x86_store_gregset (struct regcache *regcache, const void *buf)
+x86_store_gregset (const void *buf)
 {
   int i;
 
@@ -204,50 +203,49 @@ x86_store_gregset (struct regcache *regc
     {
       for (i = 0; i < X86_64_NUM_REGS; i++)
 	if (x86_64_regmap[i] != -1)
-	  supply_register (regcache, i, ((char *) buf) + x86_64_regmap[i]);
+	  supply_register (i, ((char *) buf) + x86_64_regmap[i]);
       return;
     }
 #endif
 
   for (i = 0; i < I386_NUM_REGS; i++)
-    supply_register (regcache, i, ((char *) buf) + i386_regmap[i]);
+    supply_register (i, ((char *) buf) + i386_regmap[i]);
 
-  supply_register_by_name (regcache, "orig_eax",
-			   ((char *) buf) + ORIG_EAX * 4);
+  supply_register_by_name ("orig_eax", ((char *) buf) + ORIG_EAX * 4);
 }
 
 static void
-x86_fill_fpregset (struct regcache *regcache, void *buf)
+x86_fill_fpregset (void *buf)
 {
 #ifdef __x86_64__
-  i387_cache_to_fxsave (regcache, buf);
+  i387_cache_to_fxsave (buf);
 #else
-  i387_cache_to_fsave (regcache, buf);
+  i387_cache_to_fsave (buf);
 #endif
 }
 
 static void
-x86_store_fpregset (struct regcache *regcache, const void *buf)
+x86_store_fpregset (const void *buf)
 {
 #ifdef __x86_64__
-  i387_fxsave_to_cache (regcache, buf);
+  i387_fxsave_to_cache (buf);
 #else
-  i387_fsave_to_cache (regcache, buf);
+  i387_fsave_to_cache (buf);
 #endif
 }
 
 #ifndef __x86_64__
 
 static void
-x86_fill_fpxregset (struct regcache *regcache, void *buf)
+x86_fill_fpxregset (void *buf)
 {
-  i387_cache_to_fxsave (regcache, buf);
+  i387_cache_to_fxsave (buf);
 }
 
 static void
-x86_store_fpxregset (struct regcache *regcache, const void *buf)
+x86_store_fpxregset (const void *buf)
 {
-  i387_fxsave_to_cache (regcache, buf);
+  i387_fxsave_to_cache (buf);
 }
 
 #endif
@@ -282,38 +280,38 @@ struct regset_info target_regsets[] =
 };
 
 static CORE_ADDR
-x86_get_pc (struct regcache *regcache)
+x86_get_pc (void)
 {
   int use_64bit = register_size (0) == 8;
 
   if (use_64bit)
     {
       unsigned long pc;
-      collect_register_by_name (regcache, "rip", &pc);
+      collect_register_by_name ("rip", &pc);
       return (CORE_ADDR) pc;
     }
   else
     {
       unsigned int pc;
-      collect_register_by_name (regcache, "eip", &pc);
+      collect_register_by_name ("eip", &pc);
       return (CORE_ADDR) pc;
     }
 }
 
 static void
-x86_set_pc (struct regcache *regcache, CORE_ADDR pc)
+x86_set_pc (CORE_ADDR pc)
 {
   int use_64bit = register_size (0) == 8;
 
   if (use_64bit)
     {
       unsigned long newpc = pc;
-      supply_register_by_name (regcache, "rip", &newpc);
+      supply_register_by_name ("rip", &newpc);
     }
   else
     {
       unsigned int newpc = pc;
-      supply_register_by_name (regcache, "eip", &newpc);
+      supply_register_by_name ("eip", &newpc);
     }
 }
 
--- ./gdb/gdbserver/linux-xtensa-low.c	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/linux-xtensa-low.c	2010-01-21 20:33:15.000000000 +0100
@@ -37,7 +37,7 @@ enum regnum {
 };
 
 static void
-xtensa_fill_gregset (struct regcache *regcache, void *buf)
+xtensa_fill_gregset (void *buf)
 {
   elf_greg_t* rset = (elf_greg_t*)buf;
   int ar0_regnum;
@@ -51,27 +51,27 @@ xtensa_fill_gregset (struct regcache *re
 
   for (i = ar0_regnum; i < ar0_regnum + XCHAL_NUM_AREGS; i++)
     {
-      collect_register (regcache, i, ptr);
+      collect_register (i, ptr);
       ptr += register_size(i);
     }
 
   /* Loop registers, if hardware has it.  */
 
 #if XCHAL_HAVE_LOOP
-  collect_register_by_name (regcache, "lbeg", (char*)&rset[R_LBEG]);
-  collect_register_by_name (regcache, "lend", (char*)&rset[R_LEND]);
-  collect_register_by_name (regcache, "lcount", (char*)&rset[R_LCOUNT]);
+  collect_register_by_name ("lbeg", (char*)&rset[R_LBEG]);
+  collect_register_by_name ("lend", (char*)&rset[R_LEND]);
+  collect_register_by_name ("lcount", (char*)&rset[R_LCOUNT]);
 #endif
 
-  collect_register_by_name (regcache, "sar", (char*)&rset[R_SAR]);
-  collect_register_by_name (regcache, "pc", (char*)&rset[R_PC]);
-  collect_register_by_name (regcache, "ps", (char*)&rset[R_PS]);
-  collect_register_by_name (regcache, "windowbase", (char*)&rset[R_WB]);
-  collect_register_by_name (regcache, "windowstart", (char*)&rset[R_WS]);
+  collect_register_by_name ("sar", (char*)&rset[R_SAR]);
+  collect_register_by_name ("pc", (char*)&rset[R_PC]);
+  collect_register_by_name ("ps", (char*)&rset[R_PS]);
+  collect_register_by_name ("windowbase", (char*)&rset[R_WB]);
+  collect_register_by_name ("windowstart", (char*)&rset[R_WS]);
 }
 
 static void
-xtensa_store_gregset (struct regcache *regcache, const void *buf)
+xtensa_store_gregset (const void *buf)
 {
   const elf_greg_t* rset = (const elf_greg_t*)buf;
   int ar0_regnum;
@@ -85,47 +85,47 @@ xtensa_store_gregset (struct regcache *r
 
   for (i = ar0_regnum; i < ar0_regnum + XCHAL_NUM_AREGS; i++)
     {
-      supply_register (regcache, i, ptr);
+      supply_register (i, ptr);
       ptr += register_size(i);
     }
 
   /* Loop registers, if hardware has it.  */
 
 #if XCHAL_HAVE_LOOP
-  supply_register_by_name (regcache, "lbeg", (char*)&rset[R_LBEG]);
-  supply_register_by_name (regcache, "lend", (char*)&rset[R_LEND]);
-  supply_register_by_name (regcache, "lcount", (char*)&rset[R_LCOUNT]);
+  supply_register_by_name ("lbeg", (char*)&rset[R_LBEG]);
+  supply_register_by_name ("lend", (char*)&rset[R_LEND]);
+  supply_register_by_name ("lcount", (char*)&rset[R_LCOUNT]);
 #endif
 
-  supply_register_by_name (regcache, "sar", (char*)&rset[R_SAR]);
-  supply_register_by_name (regcache, "pc", (char*)&rset[R_PC]);
-  supply_register_by_name (regcache, "ps", (char*)&rset[R_PS]);
-  supply_register_by_name (regcache, "windowbase", (char*)&rset[R_WB]);
-  supply_register_by_name (regcache, "windowstart", (char*)&rset[R_WS]);
+  supply_register_by_name ("sar", (char*)&rset[R_SAR]);
+  supply_register_by_name ("pc", (char*)&rset[R_PC]);
+  supply_register_by_name ("ps", (char*)&rset[R_PS]);
+  supply_register_by_name ("windowbase", (char*)&rset[R_WB]);
+  supply_register_by_name ("windowstart", (char*)&rset[R_WS]);
 }
 
 /* Xtensa GNU/Linux PTRACE interface includes extended register set.  */
 
 static void
-xtensa_fill_xtregset (struct regcache *regcache, void *buf)
+xtensa_fill_xtregset (void *buf)
 {
   const xtensa_regtable_t *ptr;
 
   for (ptr = xtensa_regmap_table; ptr->name; ptr++)
     {
-      collect_register_by_name (regcache, ptr->name,
+      collect_register_by_name (ptr->name,
 				(char*)buf + ptr->ptrace_offset);
     }
 }
 
 static void
-xtensa_store_xtregset (struct regcache *regcache, const void *buf)
+xtensa_store_xtregset (const void *buf)
 {
   const xtensa_regtable_t *ptr;
 
   for (ptr = xtensa_regmap_table; ptr->name; ptr++)
     {
-      supply_register_by_name (regcache, ptr->name,
+      supply_register_by_name (ptr->name,
 				(char*)buf + ptr->ptrace_offset);
     }
 }
@@ -150,19 +150,19 @@ static const unsigned char xtensa_breakp
 #define xtensa_breakpoint_len 2
 
 static CORE_ADDR
-xtensa_get_pc (struct regcache *regcache)
+xtensa_get_pc (void)
 {
   unsigned long pc;
 
-  collect_register_by_name (regcache, "pc", &pc);
+  collect_register_by_name ("pc", &pc);
   return pc;
 }
 
 static void
-xtensa_set_pc (struct regcache *regcache, CORE_ADDR pc)
+xtensa_set_pc (CORE_ADDR pc)
 {
   unsigned long newpc = pc;
-  supply_register_by_name (regcache, "pc", &newpc);
+  supply_register_by_name ("pc", &newpc);
 }
 
 static int
--- ./gdb/gdbserver/nto-low.c	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/nto-low.c	2010-01-21 20:33:15.000000000 +0100
@@ -601,7 +601,7 @@ nto_wait (ptid_t ptid,
    If REGNO is -1, fetch all registers, or REGNO register only otherwise.  */
 
 static void
-nto_fetch_registers (struct regcache *regcache, int regno)
+nto_fetch_registers (int regno)
 {
   int regsize;
   procfs_greg greg;
@@ -629,7 +629,7 @@ nto_fetch_registers (struct regcache *re
 	    {
 	      const unsigned int registeroffset
 		= the_low_target.register_offset (regno);
-	      supply_register (regcache, regno, ((char *)&greg) + registeroffset);
+	      supply_register (regno, ((char *)&greg) + registeroffset);
 	    }
 	}
       else
@@ -638,7 +638,7 @@ nto_fetch_registers (struct regcache *re
 	    = the_low_target.register_offset (regno);
 	  if (registeroffset == -1)
 	    return;
-	  supply_register (regcache, regno, ((char *)&greg) + registeroffset);
+	  supply_register (regno, ((char *)&greg) + registeroffset);
 	}
     }
   else
@@ -649,7 +649,7 @@ nto_fetch_registers (struct regcache *re
    We always store all registers, regardless of REGNO.  */
 
 static void
-nto_store_registers (struct regcache *regcache, int regno)
+nto_store_registers (int regno)
 {
   procfs_greg greg;
   int err;
@@ -671,7 +671,7 @@ nto_store_registers (struct regcache *re
     {
       const unsigned int regoffset
 	= the_low_target.register_offset (regno);
-      collect_register (regcache, regno, ((char *)&greg) + regoffset);
+      collect_register (regno, ((char *)&greg) + regoffset);
     }
   err = devctl (nto_inferior.ctl_fd, DCMD_PROC_SETGREG, &greg, sizeof (greg),
 		0);
--- ./gdb/gdbserver/proc-service.c	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/proc-service.c	2010-01-21 20:33:15.000000000 +0100
@@ -101,7 +101,6 @@ ps_lgetregs (gdb_ps_prochandle_t ph, lwp
 #ifdef HAVE_REGSETS
   struct lwp_info *lwp;
   struct thread_info *reg_inferior, *save_inferior;
-  struct regcache *regcache;
 
   lwp = find_lwp_pid (pid_to_ptid (lwpid));
   if (lwp == NULL)
@@ -110,9 +109,9 @@ ps_lgetregs (gdb_ps_prochandle_t ph, lwp
   reg_inferior = get_lwp_thread (lwp);
   save_inferior = current_inferior;
   current_inferior = reg_inferior;
-  regcache = get_thread_regcache (current_inferior, 1);
-  the_target->fetch_registers (regcache, -1);
-  gregset_info ()->fill_function (regcache, gregset);
+
+  the_target->fetch_registers (-1);
+  gregset_info ()->fill_function (gregset);
 
   current_inferior = save_inferior;
   return PS_OK;
--- ./gdb/gdbserver/regcache.c	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/regcache.c	2010-01-21 20:33:15.000000000 +0100
@@ -23,6 +23,16 @@
 #include <stdlib.h>
 #include <string.h>
 
+/* The private data for the register cache.  Note that we have one
+   per inferior; this is primarily for simplicity, as the performance
+   benefit is minimal.  */
+
+struct inferior_regcache_data
+{
+  int registers_valid;
+  unsigned char *registers;
+};
+
 static int register_bytes;
 
 static struct reg *reg_defs;
@@ -30,23 +40,20 @@ static int num_registers;
 
 const char **gdbserver_expedite_regs;
 
-struct regcache *
-get_thread_regcache (struct thread_info *thread, int fetch)
+static struct inferior_regcache_data *
+get_regcache (struct thread_info *inf, int fetch)
 {
-  struct regcache *regcache;
+  struct inferior_regcache_data *regcache;
 
-  regcache = (struct regcache *) inferior_regcache_data (thread);
+  regcache = (struct inferior_regcache_data *) inferior_regcache_data (inf);
 
   if (regcache == NULL)
     fatal ("no register cache");
 
+  /* FIXME - fetch registers for INF */
   if (fetch && regcache->registers_valid == 0)
     {
-      struct thread_info *saved_inferior = current_inferior;
-
-      current_inferior = thread;
-      fetch_inferior_registers (regcache, -1);
-      current_inferior = saved_inferior;
+      fetch_inferior_registers (-1);
       regcache->registers_valid = 1;
     }
 
@@ -57,16 +64,16 @@ void
 regcache_invalidate_one (struct inferior_list_entry *entry)
 {
   struct thread_info *thread = (struct thread_info *) entry;
-  struct regcache *regcache;
+  struct inferior_regcache_data *regcache;
 
-  regcache = (struct regcache *) inferior_regcache_data (thread);
+  regcache = (struct inferior_regcache_data *) inferior_regcache_data (thread);
 
   if (regcache->registers_valid)
     {
       struct thread_info *saved_inferior = current_inferior;
 
       current_inferior = thread;
-      store_inferior_registers (regcache, -1);
+      store_inferior_registers (-1);
       current_inferior = saved_inferior;
     }
 
@@ -74,25 +81,24 @@ regcache_invalidate_one (struct inferior
 }
 
 void
-regcache_invalidate (void)
+regcache_invalidate ()
 {
   for_each_inferior (&all_threads, regcache_invalidate_one);
 }
 
-struct regcache *
+void *
 new_register_cache (void)
 {
-  struct regcache *regcache;
+  struct inferior_regcache_data *regcache;
 
   if (register_bytes == 0)
     return NULL; /* The architecture hasn't been initialized yet.  */
 
   regcache = xmalloc (sizeof (*regcache));
 
-  /* Make sure to zero-initialize the register cache when it is
-     created, in case there are registers the target never
-     fetches.  This way they'll read as zero instead of
-     garbage.  */
+  /* Make sure to zero-initialize the register cache when it is created,
+     in case there are registers the target never fetches.  This way they'll
+     read as zero instead of garbage.  */
   regcache->registers = xcalloc (1, register_bytes);
 
   regcache->registers_valid = 0;
@@ -101,8 +107,11 @@ new_register_cache (void)
 }
 
 void
-free_register_cache (struct regcache *regcache)
+free_register_cache (void *regcache_p)
 {
+  struct inferior_regcache_data *regcache
+    = (struct inferior_regcache_data *) regcache_p;
+
   if (regcache)
     {
       free (regcache->registers);
@@ -114,10 +123,8 @@ static void
 realloc_register_cache (struct inferior_list_entry *thread_p)
 {
   struct thread_info *thread = (struct thread_info *) thread_p;
-  struct regcache *regcache
-    = (struct regcache *) inferior_regcache_data (thread);
 
-  free_register_cache (regcache);
+  free_register_cache (inferior_regcache_data (thread));
   set_inferior_regcache_data (thread, new_register_cache ());
 }
 
@@ -147,18 +154,18 @@ set_register_cache (struct reg *regs, in
 }
 
 void
-registers_to_string (struct regcache *regcache, char *buf)
+registers_to_string (char *buf)
 {
-  unsigned char *registers = regcache->registers;
+  unsigned char *registers = get_regcache (current_inferior, 1)->registers;
 
   convert_int_to_ascii (registers, buf, register_bytes);
 }
 
 void
-registers_from_string (struct regcache *regcache, char *buf)
+registers_from_string (char *buf)
 {
   int len = strlen (buf);
-  unsigned char *registers = regcache->registers;
+  unsigned char *registers = get_regcache (current_inferior, 1)->registers;
 
   if (len != register_bytes * 2)
     {
@@ -207,40 +214,40 @@ register_size (int n)
 }
 
 static unsigned char *
-register_data (struct regcache *regcache, int n, int fetch)
+register_data (int n, int fetch)
 {
-  return regcache->registers + (reg_defs[n].offset / 8);
+  unsigned char *registers
+    = get_regcache (current_inferior, fetch)->registers;
+
+  return registers + (reg_defs[n].offset / 8);
 }
 
 void
-supply_register (struct regcache *regcache, int n, const void *buf)
+supply_register (int n, const void *buf)
 {
-  memcpy (register_data (regcache, n, 0), buf, register_size (n));
+  memcpy (register_data (n, 0), buf, register_size (n));
 }
 
 void
-supply_register_by_name (struct regcache *regcache,
-			 const char *name, const void *buf)
+supply_register_by_name (const char *name, const void *buf)
 {
-  supply_register (regcache, find_regno (name), buf);
+  supply_register (find_regno (name), buf);
 }
 
 void
-collect_register (struct regcache *regcache, int n, void *buf)
+collect_register (int n, void *buf)
 {
-  memcpy (buf, register_data (regcache, n, 1), register_size (n));
+  memcpy (buf, register_data (n, 1), register_size (n));
 }
 
 void
-collect_register_as_string (struct regcache *regcache, int n, char *buf)
+collect_register_as_string (int n, char *buf)
 {
-  convert_int_to_ascii (register_data (regcache, n, 1),
-			buf, register_size (n));
+  convert_int_to_ascii (register_data (n, 1), buf, register_size (n));
 }
 
 void
-collect_register_by_name (struct regcache *regcache,
-			  const char *name, void *buf)
+collect_register_by_name (const char *name, void *buf)
 {
-  collect_register (regcache, find_regno (name), buf);
+  collect_register (find_regno (name), buf);
 }
--- ./gdb/gdbserver/regcache.h	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/regcache.h	2010-01-21 20:33:15.000000000 +0100
@@ -21,27 +21,14 @@
 #define REGCACHE_H
 
 struct inferior_list_entry;
-struct thread_info;
-
-/* The data for the register cache.  Note that we have one per
-   inferior; this is primarily for simplicity, as the performance
-   benefit is minimal.  */
-
-struct regcache
-{
-  int registers_valid;
-  unsigned char *registers;
-};
 
 /* Create a new register cache for INFERIOR.  */
 
-struct regcache *new_register_cache (void);
-
-struct regcache *get_thread_regcache (struct thread_info *thread, int fetch);
+void *new_register_cache (void);
 
 /* Release all memory associated with the register cache for INFERIOR.  */
 
-void free_register_cache (struct regcache *regcache);
+void free_register_cache (void *regcache);
 
 /* Invalidate cached registers for one or all threads.  */
 
@@ -51,11 +38,11 @@ void regcache_invalidate (void);
 /* Convert all registers to a string in the currently specified remote
    format.  */
 
-void registers_to_string (struct regcache *regcache, char *buf);
+void registers_to_string (char *buf);
 
 /* Convert a string to register values and fill our register cache.  */
 
-void registers_from_string (struct regcache *regcache, char *buf);
+void registers_from_string (char *buf);
 
 /* Return a pointer to the description of register ``n''.  */
 
@@ -70,15 +57,14 @@ int find_regno (const char *name);
 extern const char **gdbserver_expedite_regs;
 extern const char *gdbserver_xmltarget;
 
-void supply_register (struct regcache *regcache, int n, const void *buf);
+void supply_register (int n, const void *buf);
 
-void supply_register_by_name (struct regcache *regcache,
-			      const char *name, const void *buf);
+void supply_register_by_name (const char *name, const void *buf);
 
-void collect_register (struct regcache *regcache, int n, void *buf);
+void collect_register (int n, void *buf);
 
-void collect_register_as_string (struct regcache *regcache, int n, char *buf);
+void collect_register_as_string (int n, char *buf);
 
-void collect_register_by_name (struct regcache *regcache, const char *name, void *buf);
+void collect_register_by_name (const char *name, void *buf);
 
 #endif /* REGCACHE_H */
--- ./gdb/gdbserver/remote-utils.c	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/remote-utils.c	2010-01-21 20:33:15.000000000 +0100
@@ -1053,7 +1053,7 @@ convert_ascii_to_int (char *from, unsign
 }
 
 static char *
-outreg (struct regcache *regcache, int regno, char *buf)
+outreg (int regno, char *buf)
 {
   if ((regno >> 12) != 0)
     *buf++ = tohex ((regno >> 12) & 0xf);
@@ -1062,7 +1062,7 @@ outreg (struct regcache *regcache, int r
   *buf++ = tohex ((regno >> 4) & 0xf);
   *buf++ = tohex (regno & 0xf);
   *buf++ = ':';
-  collect_register_as_string (regcache, regno, buf);
+  collect_register_as_string (regno, buf);
   buf += 2 * register_size (regno);
   *buf++ = ';';
 
@@ -1116,7 +1116,6 @@ prepare_resume_reply (char *buf, ptid_t 
       {
 	struct thread_info *saved_inferior;
 	const char **regp;
-	struct regcache *regcache;
 
 	sprintf (buf, "T%02x", status->value.sig);
 	buf += strlen (buf);
@@ -1127,8 +1126,6 @@ prepare_resume_reply (char *buf, ptid_t 
 
 	current_inferior = find_thread_ptid (ptid);
 
-	regcache = get_thread_regcache (current_inferior, 1);
-
 	if (the_target->stopped_by_watchpoint != NULL
 	    && (*the_target->stopped_by_watchpoint) ())
 	  {
@@ -1151,7 +1148,7 @@ prepare_resume_reply (char *buf, ptid_t 
 
 	while (*regp)
 	  {
-	    buf = outreg (regcache, find_regno (*regp), buf);
+	    buf = outreg (find_regno (*regp), buf);
 	    regp ++;
 	  }
 	*buf = '\0';
--- ./gdb/gdbserver/server.c	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/server.c	2010-01-21 20:33:15.000000000 +0100
@@ -2456,25 +2456,15 @@ process_serial_event (void)
 	}
       break;
     case 'g':
-      {
-	struct regcache *regcache;
-
-	require_running (own_buf);
-	set_desired_inferior (1);
-	regcache = get_thread_regcache (current_inferior, 1);
-	registers_to_string (regcache, own_buf);
-      }
+      require_running (own_buf);
+      set_desired_inferior (1);
+      registers_to_string (own_buf);
       break;
     case 'G':
- 	{
-	  struct regcache *regcache;
-
-	  require_running (own_buf);
-	  set_desired_inferior (1);
-	  regcache = get_thread_regcache (current_inferior, 1);
-	  registers_from_string (regcache, &own_buf[1]);
-	  write_ok (own_buf);
-	}
+      require_running (own_buf);
+      set_desired_inferior (1);
+      registers_from_string (&own_buf[1]);
+      write_ok (own_buf);
       break;
     case 'm':
       require_running (own_buf);
--- ./gdb/gdbserver/target.h	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/target.h	2010-01-21 20:33:15.000000000 +0100
@@ -166,13 +166,13 @@ struct target_ops
 
      If REGNO is -1, fetch all registers; otherwise, fetch at least REGNO.  */
 
-  void (*fetch_registers) (struct regcache *regcache, int regno);
+  void (*fetch_registers) (int regno);
 
   /* Store registers to the inferior process.
 
      If REGNO is -1, store all registers; otherwise, store at least REGNO.  */
 
-  void (*store_registers) (struct regcache *regcache, int regno);
+  void (*store_registers) (int regno);
 
   /* Read memory from the inferior process.  This should generally be
      called through read_inferior_memory, which handles breakpoint shadowing.
@@ -307,11 +307,11 @@ void set_target_ops (struct target_ops *
 #define mythread_alive(pid) \
   (*the_target->thread_alive) (pid)
 
-#define fetch_inferior_registers(regcache, regno)	\
-  (*the_target->fetch_registers) (regcache, regno)
+#define fetch_inferior_registers(regno) \
+  (*the_target->fetch_registers) (regno)
 
-#define store_inferior_registers(regcache, regno) \
-  (*the_target->store_registers) (regcache, regno)
+#define store_inferior_registers(regno) \
+  (*the_target->store_registers) (regno)
 
 #define join_inferior(pid) \
   (*the_target->join) (pid)
--- ./gdb/gdbserver/win32-arm-low.c	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/win32-arm-low.c	2010-01-21 20:33:15.000000000 +0100
@@ -93,19 +93,17 @@ regptr (CONTEXT* c, int r)
 
 /* Fetch register from gdbserver regcache data.  */
 static void
-arm_fetch_inferior_register (struct regcache *regcache,
-			     win32_thread_info *th, int r)
+arm_fetch_inferior_register (win32_thread_info *th, int r)
 {
   char *context_offset = regptr (&th->context, r);
-  supply_register (regcache, r, context_offset);
+  supply_register (r, context_offset);
 }
 
 /* Store a new register value into the thread context of TH.  */
 static void
-arm_store_inferior_register (struct regcache *regcache,
-			     win32_thread_info *th, int r)
+arm_store_inferior_register (win32_thread_info *th, int r)
 {
-  collect_register (regcache, r, regptr (&th->context, r));
+  collect_register (r, regptr (&th->context, r));
 }
 
 /* Correct in either endianness.  We do not support Thumb yet.  */
--- ./gdb/gdbserver/win32-i386-low.c	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/win32-i386-low.c	2010-01-21 20:33:15.000000000 +0100
@@ -271,8 +271,7 @@ static const int mappings[] = {
 
 /* Fetch register from gdbserver regcache data.  */
 static void
-i386_fetch_inferior_register (struct regcache *regcache,
-			      win32_thread_info *th, int r)
+i386_fetch_inferior_register (win32_thread_info *th, int r)
 {
   char *context_offset = (char *) &th->context + mappings[r];
 
@@ -280,24 +279,23 @@ i386_fetch_inferior_register (struct reg
   if (r == FCS_REGNUM)
     {
       l = *((long *) context_offset) & 0xffff;
-      supply_register (regcache, r, (char *) &l);
+      supply_register (r, (char *) &l);
     }
   else if (r == FOP_REGNUM)
     {
       l = (*((long *) context_offset) >> 16) & ((1 << 11) - 1);
-      supply_register (regcache, r, (char *) &l);
+      supply_register (r, (char *) &l);
     }
   else
-    supply_register (regcache, r, context_offset);
+    supply_register (r, context_offset);
 }
 
 /* Store a new register value into the thread context of TH.  */
 static void
-i386_store_inferior_register (struct regcache *regcache,
-			      win32_thread_info *th, int r)
+i386_store_inferior_register (win32_thread_info *th, int r)
 {
   char *context_offset = (char *) &th->context + mappings[r];
-  collect_register (regcache, r, context_offset);
+  collect_register (r, context_offset);
 }
 
 static const unsigned char i386_win32_breakpoint = 0xcc;
--- ./gdb/gdbserver/win32-low.c	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/win32-low.c	2010-01-21 20:33:15.000000000 +0100
@@ -372,29 +372,29 @@ child_continue (DWORD continue_status, i
 
 /* Fetch register(s) from the current thread context.  */
 static void
-child_fetch_inferior_registers (struct regcache *regcache, int r)
+child_fetch_inferior_registers (int r)
 {
   int regno;
   win32_thread_info *th = thread_rec (current_inferior_ptid (), TRUE);
   if (r == -1 || r > NUM_REGS)
-    child_fetch_inferior_registers (regcache, NUM_REGS);
+    child_fetch_inferior_registers (NUM_REGS);
   else
     for (regno = 0; regno < r; regno++)
-      (*the_low_target.fetch_inferior_register) (regcache, th, regno);
+      (*the_low_target.fetch_inferior_register) (th, regno);
 }
 
 /* Store a new register value into the current thread context.  We don't
    change the program's context until later, when we resume it.  */
 static void
-child_store_inferior_registers (struct regcache *regcache, int r)
+child_store_inferior_registers (int r)
 {
   int regno;
   win32_thread_info *th = thread_rec (current_inferior_ptid (), TRUE);
   if (r == -1 || r == 0 || r > NUM_REGS)
-    child_store_inferior_registers (regcache, NUM_REGS);
+    child_store_inferior_registers (NUM_REGS);
   else
     for (regno = 0; regno < r; regno++)
-      (*the_low_target.store_inferior_register) (regcache, th, regno);
+      (*the_low_target.store_inferior_register) (th, regno);
 }
 
 /* Map the Windows error number in ERROR to a locale-dependent error
@@ -1569,7 +1569,6 @@ static ptid_t
 win32_wait (ptid_t ptid, struct target_waitstatus *ourstatus, int options)
 {
   struct process_info *process;
-  struct regcache *regcache;
 
   while (1)
     {
@@ -1591,8 +1590,7 @@ win32_wait (ptid_t ptid, struct target_w
 	  OUTMSG2 (("Child Stopped with signal = %d \n",
 		    ourstatus->value.sig));
 
-	  regcache = get_thread_regcache (current_inferior, 1);
-	  child_fetch_inferior_registers (regcache, -1);
+	  child_fetch_inferior_registers (-1);
 
 	  if (ourstatus->kind == TARGET_WAITKIND_LOADED
 	      && !server_waiting)
@@ -1624,17 +1622,17 @@ win32_wait (ptid_t ptid, struct target_w
 /* Fetch registers from the inferior process.
    If REGNO is -1, fetch all registers; otherwise, fetch at least REGNO.  */
 static void
-win32_fetch_inferior_registers (struct regcache *regcache, int regno)
+win32_fetch_inferior_registers (int regno)
 {
-  child_fetch_inferior_registers (regcache, regno);
+  child_fetch_inferior_registers (regno);
 }
 
 /* Store registers to the inferior process.
    If REGNO is -1, store all registers; otherwise, store at least REGNO.  */
 static void
-win32_store_inferior_registers (struct regcache *regcache, int regno)
+win32_store_inferior_registers (int regno)
 {
-  child_store_inferior_registers (regcache, regno);
+  child_store_inferior_registers (regno);
 }
 
 /* Read memory from the inferior process.  This should generally be
--- ./gdb/gdbserver/win32-low.h	2010-01-20 23:55:38.000000000 +0100
+++ ./gdb/gdbserver/win32-low.h	2010-01-21 20:33:15.000000000 +0100
@@ -61,12 +61,10 @@ struct win32_target_ops
   void (*thread_added) (win32_thread_info *th);
 
   /* Fetch register from gdbserver regcache data.  */
-  void (*fetch_inferior_register) (struct regcache *regcache,
-				   win32_thread_info *th, int r);
+  void (*fetch_inferior_register) (win32_thread_info *th, int r);
 
   /* Store a new register value into the thread context of TH.  */
-  void (*store_inferior_register) (struct regcache *regcache,
-				   win32_thread_info *th, int r);
+  void (*store_inferior_register) (win32_thread_info *th, int r);
 
   void (*single_step) (win32_thread_info *th);
 
