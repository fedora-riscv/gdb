http://sourceware.org/ml/gdb-cvs/2013-06/msg00012.html

### src/gdb/ChangeLog	2013/06/04 02:44:34	1.15680
### src/gdb/ChangeLog	2013/06/04 12:50:20	1.15681
## -1,3 +1,11 @@
+2013-06-04  Gary Benson  <gbenson@redhat.com>
+
+	* probe.h (get_probe_argument_count): New declaration.
+	(evaluate_probe_argument): Likewise.
+	* probe.c (get_probe_argument_count): New function.
+	(evaluate_probe_argument): Likewise.
+	(probe_safe_evaluate_at_pc): Use the above new functions.
+
 2013-06-04  Alan Modra  <amodra@gmail.com>
 
 	* ppc-tdep.h (ppc_insns_match_pattern): Update prototype.
--- src/gdb/probe.c	2013/05/30 17:39:34	1.8
+++ src/gdb/probe.c	2013/06/04 12:50:20	1.9
@@ -611,28 +611,55 @@
 
 /* See comments in probe.h.  */
 
+unsigned
+get_probe_argument_count (struct probe *probe)
+{
+  const struct sym_probe_fns *probe_fns;
+
+  gdb_assert (probe->objfile != NULL);
+  gdb_assert (probe->objfile->sf != NULL);
+
+  probe_fns = probe->objfile->sf->sym_probe_fns;
+
+  gdb_assert (probe_fns != NULL);
+
+  return probe_fns->sym_get_probe_argument_count (probe);
+}
+
+/* See comments in probe.h.  */
+
+struct value *
+evaluate_probe_argument (struct probe *probe, unsigned n)
+{
+  const struct sym_probe_fns *probe_fns;
+
+  gdb_assert (probe->objfile != NULL);
+  gdb_assert (probe->objfile->sf != NULL);
+
+  probe_fns = probe->objfile->sf->sym_probe_fns;
+
+  gdb_assert (probe_fns != NULL);
+
+  return probe_fns->sym_evaluate_probe_argument (probe, n);
+}
+
+/* See comments in probe.h.  */
+
 struct value *
 probe_safe_evaluate_at_pc (struct frame_info *frame, unsigned n)
 {
   struct probe *probe;
-  const struct sym_probe_fns *probe_fns;
   unsigned n_args;
 
   probe = find_probe_by_pc (get_frame_pc (frame));
   if (!probe)
     return NULL;
 
-  gdb_assert (probe->objfile != NULL);
-  gdb_assert (probe->objfile->sf != NULL);
-  gdb_assert (probe->objfile->sf->sym_probe_fns != NULL);
-
-  probe_fns = probe->objfile->sf->sym_probe_fns;
-  n_args = probe_fns->sym_get_probe_argument_count (probe);
-
+  n_args = get_probe_argument_count (probe);
   if (n >= n_args)
     return NULL;
 
-  return probe_fns->sym_evaluate_probe_argument (probe, n);
+  return evaluate_probe_argument (probe, n);
 }
 
 /* See comment in probe.h.  */
--- src/gdb/probe.h	2013/01/01 06:32:49	1.4
+++ src/gdb/probe.h	2013/06/04 12:50:21	1.5
@@ -214,6 +214,16 @@
 
 extern struct cmd_list_element **info_probes_cmdlist_get (void);
 
+/* Return the argument count of the specified probe.  */
+
+extern unsigned get_probe_argument_count (struct probe *probe);
+
+/* Evaluate argument N of the specified probe.  N must be between 0
+   inclusive and get_probe_argument_count exclusive.  */
+
+extern struct value *evaluate_probe_argument (struct probe *probe,
+					      unsigned n);
+
 /* A convenience function that finds a probe at the PC in FRAME and
    evaluates argument N, with 0 <= N < number_of_args.  If there is no
    probe at that location, or if the probe does not have enough arguments,
