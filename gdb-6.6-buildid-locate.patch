[base]

2007-10-16  Jan Kratochvil  <jan.kratochvil@redhat.com>

	Port to GDB-6.7.

2008-01-22  Jan Kratochvil  <jan.kratochvil@redhat.com>
	option "build-id-core-loads": Fix it to be an "on"/"off" type.
	More intuitive build-id missing files messages.
	Lookup also the main executable from the rpm database.
	Suppress duplicite buil-id missing files warnings.

2008-01-26  Jan Kratochvil  <jan.kratochvil@redhat.com>
	Print the shared libraries names unconditionally.

2008-02-21  Jan Kratochvil  <jan.kratochvil@redhat.com>
	Rename `debug build-id' to `build-id-verbose'.
	Provide its level 0 to disable the build-id messages.
	New description of `build-id-verbose' in the documentation.
	Resolve the RH Bug 432164.

2008-02-24  Jan Kratochvil  <jan.kratochvil@redhat.com>

	Port to GDB-6.8pre.

2008-03-09  Jan Kratochvil  <jan.kratochvil@redhat.com>

	Implement the `debuginfo-install' rpm/yum integration.
	Resolve the RH Bug 435581.

2008-04-16  Robert Scheck  <redhat-bugzilla@linuxnetz.de>

	Fix -I for non-standard rpm includes in `$(includedir)/rpm'.

2008-04-19  Jan Kratochvil  <jan.kratochvil@redhat.com>

	Disable the warnings for the testsuite not expecting them.

2008-10-12  Jan Kratochvil  <jan.kratochvil@redhat.com>

	rpm compatibility patch by Panu Matilainen.

2008-08-21  Jan Kratochvil  <jan.kratochvil@redhat.com>

	Disable MI non-compliant message on the missing debuginfo printed on
	reloaded exec file.
	Fix found by Denys Vlasenko <dvlasenk@redhat.com>.
	Fixes Red Hat Bug 459414.

--- ./gdb/Makefile.in	2008-08-21 00:29:46.000000000 +0200
+++ ./gdb/Makefile.in	2008-08-21 00:28:43.000000000 +0200
@@ -340,7 +340,7 @@ CONFIG_UNINSTALL = @CONFIG_UNINSTALL@
 # your system doesn't have fcntl.h in /usr/include (which is where it
 # should be according to Posix).
 DEFS = @DEFS@
-GDB_CFLAGS = -I. -I$(srcdir) -I$(srcdir)/config -DLOCALEDIR="\"$(localedir)\"" $(DEFS)
+GDB_CFLAGS = -I. -I$(srcdir) -I$(srcdir)/config -I$(includedir)/rpm -DLOCALEDIR="\"$(localedir)\"" $(DEFS)
 
 # MH_CFLAGS, if defined, has host-dependent CFLAGS from the config directory.
 GLOBAL_CFLAGS = $(MH_CFLAGS)
@@ -392,7 +392,7 @@ INSTALLED_LIBS=-lbfd -lreadline -lopcode
 CLIBS = $(SIM) $(READLINE) $(OPCODES) $(BFD) $(INTL) $(LIBIBERTY) $(LIBDECNUMBER) \
 	$(XM_CLIBS) $(TM_CLIBS) $(NAT_CLIBS) $(GDBTKLIBS) @LIBS@ \
 	$(LIBICONV) $(LIBEXPAT) \
-	$(LIBIBERTY) $(WIN32LIBS)
+	$(LIBIBERTY) $(WIN32LIBS) -lrpm
 CDEPS = $(XM_CDEPS) $(TM_CDEPS) $(NAT_CDEPS) $(SIM) $(BFD) $(READLINE_DEPS) \
 	$(OPCODES) $(INTL_DEPS) $(LIBIBERTY) $(CONFIG_DEPS)
 
@@ -2029,7 +2029,8 @@ corelow.o: corelow.c $(defs_h) $(arch_ut
 	$(inferior_h) $(symtab_h) $(command_h) $(bfd_h) $(target_h) \
 	$(gdbcore_h) $(gdbthread_h) $(regcache_h) $(regset_h) $(symfile_h) \
 	$(exec_h) $(readline_h) $(gdb_assert_h) \
-	$(exceptions_h) $(solib_h) $(filenames_h)
+	$(exceptions_h) $(solib_h) $(filenames_h) $(auxv_h) $(elf_common_h) \
+	$(objfiles_h) $(gdbcmd_h)
 core-regset.o: core-regset.c $(defs_h) $(command_h) $(gdbcore_h) \
 	$(inferior_h) $(target_h) $(regcache_h) $(gdb_string_h) $(gregset_h)
 cp-abi.o: cp-abi.c $(defs_h) $(value_h) $(cp_abi_h) $(command_h) $(gdbcmd_h) \
@@ -2117,7 +2118,7 @@ event-loop.o: event-loop.c $(defs_h) $(e
 event-top.o: event-top.c $(defs_h) $(top_h) $(inferior_h) $(target_h) \
 	$(terminal_h) $(event_loop_h) $(event_top_h) $(interps_h) \
 	$(exceptions_h) $(cli_script_h) $(gdbcmd_h) $(readline_h) \
-	$(readline_history_h)
+	$(readline_history_h) $(symfile_h)
 exceptions.o: exceptions.c $(defs_h) $(exceptions_h) $(breakpoint_h) \
 	$(target_h) $(inferior_h) $(annotate_h) $(ui_out_h) $(gdb_assert_h) \
 	$(gdb_string_h) $(serial_h)
@@ -2884,7 +2885,8 @@ symfile.o: symfile.c $(defs_h) $(bfdlink
 	$(gdb_stabs_h) $(gdb_obstack_h) $(completer_h) $(bcache_h) \
 	$(hashtab_h) $(readline_h) $(gdb_assert_h) $(block_h) \
 	$(gdb_string_h) $(gdb_stat_h) $(observer_h) $(exec_h) \
-	$(parser_defs_h) $(varobj_h) $(elf_bfd_h) $(solib_h)
+	$(parser_defs_h) $(varobj_h) $(elf_bfd_h) $(solib_h) $(gdb_stdint_h) \
+	$(libbfd_h) $(elf_bfd_h) $(elf_external_h)
 symfile-mem.o: symfile-mem.c $(defs_h) $(symtab_h) $(gdbcore_h) \
 	$(objfiles_h) $(exceptions_h) $(gdbcmd_h) $(target_h) $(value_h) \
 	$(symfile_h) $(observer_h) $(auxv_h) $(elf_common_h)
@@ -3325,7 +3327,7 @@ tui-hooks.o: $(srcdir)/tui/tui-hooks.c $
 tui-interp.o: $(srcdir)/tui/tui-interp.c $(defs_h) $(interps_h) $(top_h) \
 	$(event_top_h) $(event_loop_h) $(ui_out_h) $(cli_out_h) \
 	$(tui_data_h) $(readline_h) $(tui_win_h) $(tui_h) $(tui_io_h) \
-	$(exceptions_h)
+	$(exceptions_h) $(symfile_h)
 	$(CC) -c $(INTERNAL_CFLAGS) $(srcdir)/tui/tui-interp.c
 tui-io.o: $(srcdir)/tui/tui-io.c $(defs_h) $(target_h) \
 	$(event_loop_h) $(event_top_h) $(command_h) $(top_h) $(tui_h) \
--- ./gdb/corelow.c	2008-02-09 14:45:33.000000000 +0100
+++ ./gdb/corelow.c	2008-08-21 00:28:43.000000000 +0200
@@ -45,6 +45,10 @@
 #include "exceptions.h"
 #include "solib.h"
 #include "filenames.h"
+#include "auxv.h"
+#include "elf/common.h"
+#include "objfiles.h"
+#include "gdbcmd.h"
 
 
 #ifndef O_LARGEFILE
@@ -248,6 +252,56 @@ add_to_thread_list (bfd *abfd, asection 
     inferior_ptid = pid_to_ptid (thread_id);	/* Yes, make it current */
 }
 
+static int build_id_core_loads = 1;
+
+static void
+build_id_locate_exec (int from_tty)
+{
+  CORE_ADDR at_entry;
+  struct build_id *build_id;
+  char *exec_filename, *debug_filename;
+  char *build_id_filename;
+
+  if (exec_bfd != NULL)
+    return;
+
+  if (target_auxv_search (&current_target, AT_ENTRY, &at_entry) <= 0)
+    return;
+
+  build_id = build_id_addr_get (at_entry);
+  if (build_id == NULL)
+    return;
+
+  exec_filename = build_id_to_filename (build_id, &build_id_filename, 0);
+  if (exec_filename != NULL)
+    exec_file_attach (exec_filename, from_tty);
+  else
+    debug_print_missing (_("the main executable file"), build_id_filename);
+  xfree (build_id_filename);
+
+  /* `.note.gnu.build-id' section exists even for files without a separate
+     debuginfo.  */
+  debug_filename = build_id_to_filename (build_id, &build_id_filename, 1);
+  if (debug_filename != NULL)
+    {
+      symbol_file_add_main (debug_filename, from_tty);
+      xfree (debug_filename);
+    }
+  else
+    {
+      if (exec_filename != NULL)
+	symbol_file_add_main (exec_filename, from_tty);
+      /* For EXEC_FILENAME NULL we were already complaining above.  */
+      if (symfile_objfile == NULL && exec_filename != NULL)
+	debug_print_missing (exec_filename, build_id_filename);
+    }
+  xfree (build_id_filename);
+
+  xfree (exec_filename);
+
+  /* No automatic SOLIB_ADD as the libraries would get read twice.  */
+}
+
 /* This routine opens and sets up the core file bfd.  */
 
 static void
@@ -344,6 +398,15 @@ core_open (char *filename, int from_tty)
   ontop = !push_target (&core_ops);
   discard_cleanups (old_chain);
 
+  if (ontop)
+    {
+      /* Find the build_id identifiers.  If it gets executed after
+         POST_CREATE_INFERIOR we would clash with asking to discard the already
+         loaded VDSO symbols.  */
+      if (build_id_core_loads != 0)
+        build_id_locate_exec (from_tty);
+    }
+
   /* This is done first, before anything has a chance to query the
      inferior for information such as symbols.  */
   post_create_inferior (&core_ops, from_tty);
@@ -692,4 +755,11 @@ _initialize_corelow (void)
 
   if (!coreops_suppress_target)
     add_target (&core_ops);
+
+  add_setshow_boolean_cmd ("build-id-core-loads", class_files,
+			   &build_id_core_loads, _("\
+Set whether CORE-FILE loads the build-id associated files automatically."), _("\
+Show whether CORE-FILE loads the build-id associated files automatically.."),
+			   NULL, NULL, NULL,
+			   &setlist, &showlist);
 }
--- ./gdb/doc/gdb.texinfo	2008-08-21 00:29:46.000000000 +0200
+++ ./gdb/doc/gdb.texinfo	2008-08-21 00:28:43.000000000 +0200
@@ -12195,6 +12195,27 @@ information files.
 
 @end table
 
+You can also adjust the current verbosity of the @dfn{build id} locating.
+
+@table @code
+
+@kindex set build-id-verbose
+@item set build-id-verbose 0
+No additional messages are printed.
+
+@item set build-id-verbose 1
+Missing separate debug filenames are printed.
+
+@item set build-id-verbose 2
+Missing separate debug filenames are printed and also all the parsing of the
+binaries to find their @dfn{build id} content is printed.
+
+@kindex show build-id-verbose
+@item show build-id-verbose
+Show the current verbosity value for the @dfn{build id} content locating.
+
+@end table
+
 @cindex @code{.gnu_debuglink} sections
 @cindex debug link sections
 A debug link is a special section of the executable file named
--- ./gdb/event-top.c	2008-01-01 23:53:09.000000000 +0100
+++ ./gdb/event-top.c	2008-08-21 00:28:43.000000000 +0200
@@ -31,6 +31,7 @@
 #include <signal.h>
 #include "exceptions.h"
 #include "cli/cli-script.h"     /* for reset_command_nest_depth */
+#include "symfile.h"
 
 /* For dont_repeat() */
 #include "gdbcmd.h"
@@ -192,6 +193,8 @@ cli_command_loop (void)
       char *a_prompt;
       char *gdb_prompt = get_prompt ();
 
+      debug_flush_missing ();
+
       /* Tell readline what the prompt to display is and what function it
          will need to call after a whole line is read. This also displays
          the first prompt. */
@@ -263,6 +266,8 @@ display_gdb_prompt (char *new_prompt)
   /* Reset the nesting depth used when trace-commands is set.  */
   reset_command_nest_depth ();
 
+  debug_flush_missing ();
+
   /* Each interpreter has its own rules on displaying the command
      prompt.  */
   if (!current_interp_display_prompt_p ())
--- ./gdb/solib-svr4.c	2008-08-21 00:29:46.000000000 +0200
+++ ./gdb/solib-svr4.c	2008-08-21 00:28:43.000000000 +0200
@@ -764,9 +764,33 @@ svr4_current_sos (void)
 		     safe_strerror (errcode));
 	  else
 	    {
-	      strncpy (new->so_name, buffer, SO_NAME_MAX_PATH_SIZE - 1);
-	      new->so_name[SO_NAME_MAX_PATH_SIZE - 1] = '\0';
-	      strcpy (new->so_original_name, new->so_name);
+	      struct build_id *build_id;
+
+	      strncpy (new->so_original_name, buffer, SO_NAME_MAX_PATH_SIZE - 1);
+	      new->so_original_name[SO_NAME_MAX_PATH_SIZE - 1] = '\0';
+	      /* May get overwritten below.  */
+	      strcpy (new->so_name, new->so_original_name);
+
+	      build_id = build_id_addr_get (LM_DYNAMIC_FROM_LINK_MAP (new));
+	      if (build_id != NULL)
+		{
+		  char *name, *build_id_filename;
+
+		  /* Missing the build-id matching separate debug info file
+		     would be handled while SO_NAME gets loaded.  */
+		  name = build_id_to_filename (build_id, &build_id_filename, 0);
+		  if (name != NULL)
+		    {
+		      strncpy (new->so_name, name, SO_NAME_MAX_PATH_SIZE - 1);
+		      new->so_name[SO_NAME_MAX_PATH_SIZE - 1] = '\0';
+		      xfree (name);
+		    }
+		  else
+		    debug_print_missing (new->so_name, build_id_filename);
+
+		  xfree (build_id_filename);
+		  xfree (build_id);
+		}
 	    }
 	  xfree (buffer);
 
--- ./gdb/symfile.c	2008-08-21 00:29:46.000000000 +0200
+++ ./gdb/symfile.c	2008-08-21 00:29:18.000000000 +0200
@@ -53,6 +53,9 @@
 #include "varobj.h"
 #include "elf-bfd.h"
 #include "solib.h"
+#include "gdb_stdint.h"
+#include "libbfd.h"
+#include "elf/external.h"
 
 #include <sys/types.h>
 #include <fcntl.h>
@@ -61,6 +64,7 @@
 #include <ctype.h>
 #include <time.h>
 #include <sys/time.h>
+#include <sys/param.h>
 
 
 int (*deprecated_ui_load_progress_hook) (const char *section, unsigned long num);
@@ -1226,16 +1230,65 @@ symbol_file_clear (int from_tty)
       printf_unfiltered (_("No symbol file now.\n"));
 }
 
+/* Locate NT_GNU_BUILD_ID and return its matching debug filename.
+   FIXME: NOTE decoding should be unified with the BFD core notes decoding.  */
+
+#define BUILD_ID_VERBOSE_NONE 0
+#define BUILD_ID_VERBOSE_FILENAMES 1
+#define BUILD_ID_VERBOSE_BINARY_PARSE 2
+static int build_id_verbose = BUILD_ID_VERBOSE_FILENAMES;
+static void
+show_build_id_verbose (struct ui_file *file, int from_tty,
+		       struct cmd_list_element *c, const char *value)
+{
+  fprintf_filtered (file, _("Verbosity level of the build-id locator is %s.\n"),
+		    value);
+}
+
 struct build_id
   {
     size_t size;
     gdb_byte data[1];
   };
 
-/* Locate NT_GNU_BUILD_ID from ABFD and return its content.  */
+struct build_id *
+build_id_buf_get (bfd *templ, gdb_byte *buf, bfd_size_type size)
+{
+  bfd_byte *p;
+
+  p = buf;
+  while (p < buf + size)
+    {
+      /* FIXME: bad alignment assumption.  */
+      Elf_External_Note *xnp = (Elf_External_Note *) p;
+      size_t namesz = H_GET_32 (templ, xnp->namesz);
+      size_t descsz = H_GET_32 (templ, xnp->descsz);
+      bfd_byte *descdata = xnp->name + BFD_ALIGN (namesz, 4);
+
+      if (H_GET_32 (templ, xnp->type) == NT_GNU_BUILD_ID
+	  && namesz == sizeof "GNU"
+	  && memcmp (xnp->name, "GNU", sizeof "GNU") == 0)
+	{
+	  size_t size = descsz;
+	  gdb_byte *data = (void *) descdata;
+	  struct build_id *retval;
+
+	  retval = xmalloc (sizeof *retval - 1 + size);
+	  retval->size = size;
+	  memcpy (retval->data, data, size);
+
+	  return retval;
+	}
+      p = descdata + BFD_ALIGN (descsz, 4);
+    }
+  return NULL;
+}
+
+/* Separate debuginfo files have corrupted PHDR but SHDR is correct there.
+   Locate NT_GNU_BUILD_ID from ABFD and return its content.  */
 
 static struct build_id *
-build_id_bfd_get (bfd *abfd)
+build_id_bfd_shdr_get (bfd *abfd)
 {
   struct build_id *retval;
 
@@ -1251,6 +1304,348 @@ build_id_bfd_get (bfd *abfd)
   return retval;
 }
 
+/* Core files may have missing (corrupt) SHDR but PDHR is correct there.
+   bfd_elf_bfd_from_remote_memory () has too much overhead by
+   allocating/reading all the available ELF PT_LOADs.  */
+
+static struct build_id *
+build_id_phdr_get (bfd *templ, bfd_vma loadbase, unsigned e_phnum,
+		   Elf_Internal_Phdr *i_phdr)
+{
+  int i;
+  struct build_id *retval = NULL;
+
+  for (i = 0; i < e_phnum; i++)
+    if (i_phdr[i].p_type == PT_NOTE && i_phdr[i].p_filesz > 0)
+      {
+	Elf_Internal_Phdr *hdr = &i_phdr[i];
+	gdb_byte *buf;
+	int err;
+
+	buf = xmalloc (hdr->p_filesz);
+	err = target_read_memory (loadbase + i_phdr[i].p_vaddr, buf,
+				  hdr->p_filesz);
+	if (err == 0)
+	  retval = build_id_buf_get (templ, buf, hdr->p_filesz);
+	else
+	  retval = NULL;
+	xfree (buf);
+	if (retval != NULL)
+	  break;
+      }
+  return retval;
+}
+
+/* First we validate the file by reading in the ELF header and checking
+   the magic number.  */
+
+static inline bfd_boolean
+elf_file_p (Elf64_External_Ehdr *x_ehdrp64)
+{
+  gdb_assert (sizeof (Elf64_External_Ehdr) >= sizeof (Elf32_External_Ehdr));
+  gdb_assert (offsetof (Elf64_External_Ehdr, e_ident)
+	      == offsetof (Elf32_External_Ehdr, e_ident));
+  gdb_assert (sizeof (((Elf64_External_Ehdr *) 0)->e_ident)
+	      == sizeof (((Elf32_External_Ehdr *) 0)->e_ident));
+
+  return ((x_ehdrp64->e_ident[EI_MAG0] == ELFMAG0)
+	  && (x_ehdrp64->e_ident[EI_MAG1] == ELFMAG1)
+	  && (x_ehdrp64->e_ident[EI_MAG2] == ELFMAG2)
+	  && (x_ehdrp64->e_ident[EI_MAG3] == ELFMAG3));
+}
+
+/* Translate an ELF file header in external format into an ELF file header in
+   internal format.  */
+
+#define H_GET_WORD(bfd, ptr) (is64 ? H_GET_64 (bfd, (ptr))		\
+				   : H_GET_32 (bfd, (ptr)))
+#define H_GET_SIGNED_WORD(bfd, ptr) (is64 ? H_GET_S64 (bfd, (ptr))	\
+					  : H_GET_S32 (bfd, (ptr)))
+
+static void
+elf_swap_ehdr_in (bfd *abfd,
+		  const Elf64_External_Ehdr *src64,
+		  Elf_Internal_Ehdr *dst)
+{
+  int is64 = bfd_get_arch_size (abfd) == 64;
+#define SRC(field) (is64 ? src64->field \
+			 : ((const Elf32_External_Ehdr *) src64)->field)
+
+  int signed_vma = get_elf_backend_data (abfd)->sign_extend_vma;
+  memcpy (dst->e_ident, SRC (e_ident), EI_NIDENT);
+  dst->e_type = H_GET_16 (abfd, SRC (e_type));
+  dst->e_machine = H_GET_16 (abfd, SRC (e_machine));
+  dst->e_version = H_GET_32 (abfd, SRC (e_version));
+  if (signed_vma)
+    dst->e_entry = H_GET_SIGNED_WORD (abfd, SRC (e_entry));
+  else
+    dst->e_entry = H_GET_WORD (abfd, SRC (e_entry));
+  dst->e_phoff = H_GET_WORD (abfd, SRC (e_phoff));
+  dst->e_shoff = H_GET_WORD (abfd, SRC (e_shoff));
+  dst->e_flags = H_GET_32 (abfd, SRC (e_flags));
+  dst->e_ehsize = H_GET_16 (abfd, SRC (e_ehsize));
+  dst->e_phentsize = H_GET_16 (abfd, SRC (e_phentsize));
+  dst->e_phnum = H_GET_16 (abfd, SRC (e_phnum));
+  dst->e_shentsize = H_GET_16 (abfd, SRC (e_shentsize));
+  dst->e_shnum = H_GET_16 (abfd, SRC (e_shnum));
+  dst->e_shstrndx = H_GET_16 (abfd, SRC (e_shstrndx));
+
+#undef SRC
+}
+
+/* Translate an ELF program header table entry in external format into an
+   ELF program header table entry in internal format.  */
+
+void
+elf_swap_phdr_in (bfd *abfd,
+		  const Elf64_External_Phdr *src64,
+		  Elf_Internal_Phdr *dst)
+{
+  int is64 = bfd_get_arch_size (abfd) == 64;
+#define SRC(field) (is64 ? src64->field					\
+			 : ((const Elf32_External_Phdr *) src64)->field)
+
+  int signed_vma = get_elf_backend_data (abfd)->sign_extend_vma;
+
+  dst->p_type = H_GET_32 (abfd, SRC (p_type));
+  dst->p_flags = H_GET_32 (abfd, SRC (p_flags));
+  dst->p_offset = H_GET_WORD (abfd, SRC (p_offset));
+  if (signed_vma)
+    {
+      dst->p_vaddr = H_GET_SIGNED_WORD (abfd, SRC (p_vaddr));
+      dst->p_paddr = H_GET_SIGNED_WORD (abfd, SRC (p_paddr));
+    }
+  else
+    {
+      dst->p_vaddr = H_GET_WORD (abfd, SRC (p_vaddr));
+      dst->p_paddr = H_GET_WORD (abfd, SRC (p_paddr));
+    }
+  dst->p_filesz = H_GET_WORD (abfd, SRC (p_filesz));
+  dst->p_memsz = H_GET_WORD (abfd, SRC (p_memsz));
+  dst->p_align = H_GET_WORD (abfd, SRC (p_align));
+
+#undef SRC
+}
+
+#undef H_GET_SIGNED_WORD
+#undef H_GET_WORD
+
+static Elf_Internal_Phdr *
+elf_get_phdr (bfd *templ, bfd_vma ehdr_vma, unsigned *e_phnum_pointer,
+              bfd_vma *loadbase_pointer)
+{
+  /* sizeof (Elf64_External_Ehdr) >= sizeof (Elf32_External_Ehdr)  */
+  Elf64_External_Ehdr x_ehdr64;	/* Elf file header, external form */
+  Elf_Internal_Ehdr i_ehdr;	/* Elf file header, internal form */
+  bfd_size_type x_phdrs_size;
+  gdb_byte *x_phdrs_ptr;
+  Elf_Internal_Phdr *i_phdrs;
+  int err;
+  unsigned int i;
+  bfd_vma loadbase;
+  int loadbase_set;
+
+  gdb_assert (templ != NULL);
+  gdb_assert (sizeof (Elf64_External_Ehdr) >= sizeof (Elf32_External_Ehdr));
+
+  /* Read in the ELF header in external format.  */
+  err = target_read_memory (ehdr_vma, (bfd_byte *) &x_ehdr64, sizeof x_ehdr64);
+  if (err)
+    {
+      if (build_id_verbose >= BUILD_ID_VERBOSE_BINARY_PARSE)
+        warning (_("build-id: Error reading ELF header at address 0x%lx"),
+		 (unsigned long) ehdr_vma);
+      return NULL;
+    }
+
+  /* Now check to see if we have a valid ELF file, and one that BFD can
+     make use of.  The magic number must match, the address size ('class')
+     and byte-swapping must match our XVEC entry.  */
+
+  if (! elf_file_p (&x_ehdr64)
+      || x_ehdr64.e_ident[EI_VERSION] != EV_CURRENT
+      || !((bfd_get_arch_size (templ) == 64
+            && x_ehdr64.e_ident[EI_CLASS] == ELFCLASS64)
+           || (bfd_get_arch_size (templ) == 32
+	       && x_ehdr64.e_ident[EI_CLASS] == ELFCLASS32)))
+    {
+      if (build_id_verbose >= BUILD_ID_VERBOSE_BINARY_PARSE)
+        warning (_("build-id: Unrecognized ELF header at address 0x%lx"),
+		 (unsigned long) ehdr_vma);
+      return NULL;
+    }
+
+  /* Check that file's byte order matches xvec's */
+  switch (x_ehdr64.e_ident[EI_DATA])
+    {
+    case ELFDATA2MSB:		/* Big-endian */
+      if (! bfd_header_big_endian (templ))
+	{
+	  if (build_id_verbose >= BUILD_ID_VERBOSE_BINARY_PARSE)
+	    warning (_("build-id: Unrecognized "
+		       "big-endian ELF header at address 0x%lx"),
+		     (unsigned long) ehdr_vma);
+	  return NULL;
+	}
+      break;
+    case ELFDATA2LSB:		/* Little-endian */
+      if (! bfd_header_little_endian (templ))
+	{
+	  if (build_id_verbose >= BUILD_ID_VERBOSE_BINARY_PARSE)
+	    warning (_("build-id: Unrecognized "
+		       "little-endian ELF header at address 0x%lx"),
+		     (unsigned long) ehdr_vma);
+	  return NULL;
+	}
+      break;
+    case ELFDATANONE:		/* No data encoding specified */
+    default:			/* Unknown data encoding specified */
+      if (build_id_verbose >= BUILD_ID_VERBOSE_BINARY_PARSE)
+	warning (_("build-id: Unrecognized "
+		   "ELF header endianity at address 0x%lx"),
+		 (unsigned long) ehdr_vma);
+      return NULL;
+    }
+
+  elf_swap_ehdr_in (templ, &x_ehdr64, &i_ehdr);
+
+  /* The file header tells where to find the program headers.
+     These are what we use to actually choose what to read.  */
+
+  if (i_ehdr.e_phentsize != (bfd_get_arch_size (templ) == 64
+                             ? sizeof (Elf64_External_Phdr)
+			     : sizeof (Elf32_External_Phdr))
+      || i_ehdr.e_phnum == 0)
+    {
+      if (build_id_verbose >= BUILD_ID_VERBOSE_BINARY_PARSE)
+	warning (_("build-id: Invalid ELF program headers from the ELF header "
+		   "at address 0x%lx"), (unsigned long) ehdr_vma);
+      return NULL;
+    }
+
+  x_phdrs_size = (bfd_get_arch_size (templ) == 64 ? sizeof (Elf64_External_Phdr)
+						: sizeof (Elf32_External_Phdr));
+
+  i_phdrs = xmalloc (i_ehdr.e_phnum * (sizeof *i_phdrs + x_phdrs_size));
+  x_phdrs_ptr = (void *) &i_phdrs[i_ehdr.e_phnum];
+  err = target_read_memory (ehdr_vma + i_ehdr.e_phoff, (bfd_byte *) x_phdrs_ptr,
+			    i_ehdr.e_phnum * x_phdrs_size);
+  if (err)
+    {
+      free (i_phdrs);
+      if (build_id_verbose >= BUILD_ID_VERBOSE_BINARY_PARSE)
+        warning (_("build-id: Error reading "
+		   "ELF program headers at address 0x%lx"),
+		 (unsigned long) (ehdr_vma + i_ehdr.e_phoff));
+      return NULL;
+    }
+
+  loadbase = ehdr_vma;
+  loadbase_set = 0;
+  for (i = 0; i < i_ehdr.e_phnum; ++i)
+    {
+      elf_swap_phdr_in (templ, (Elf64_External_Phdr *)
+			       (x_phdrs_ptr + i * x_phdrs_size), &i_phdrs[i]);
+      /* IA-64 vDSO may have two mappings for one segment, where one mapping
+	 is executable only, and one is read only.  We must not use the
+	 executable one (PF_R is the first one, PF_X the second one).  */
+      if (i_phdrs[i].p_type == PT_LOAD && (i_phdrs[i].p_flags & PF_R))
+	{
+	  /* Only the first PT_LOAD segment indicates the file bias.
+	     Next segments may have P_VADDR arbitrarily higher.
+	     If the first segment has P_VADDR zero any next segment must not
+	     confuse us, the first one sets LOADBASE certainly enough.  */
+	  if (!loadbase_set && i_phdrs[i].p_offset == 0)
+	    {
+	      loadbase = ehdr_vma - i_phdrs[i].p_vaddr;
+	      loadbase_set = 1;
+	    }
+	}
+    }
+
+  if (build_id_verbose >= BUILD_ID_VERBOSE_BINARY_PARSE)
+    warning (_("build-id: Found ELF header at address 0x%lx, loadbase 0x%lx"),
+	     (unsigned long) ehdr_vma, (unsigned long) loadbase);
+
+  *e_phnum_pointer = i_ehdr.e_phnum;
+  *loadbase_pointer = loadbase;
+  return i_phdrs;
+}
+
+/* BUILD_ID_ADDR_GET gets ADDR located somewhere in the object.
+   Find the first section before ADDR containing an ELF header.
+   We rely on the fact the sections from multiple files do not mix.
+   FIXME: We should check ADDR is contained _inside_ the section with possibly
+   missing content (P_FILESZ < P_MEMSZ).  These omitted sections are currently
+   hidden by _BFD_ELF_MAKE_SECTION_FROM_PHDR.  */
+
+static CORE_ADDR build_id_addr;
+struct build_id_addr_sect
+  {
+    struct build_id_addr_sect *next;
+    asection *sect;
+  };
+static struct build_id_addr_sect *build_id_addr_sect;
+
+static void build_id_addr_candidate (bfd *abfd, asection *sect, void *obj)
+{
+  if (build_id_addr >= bfd_section_vma (abfd, sect))
+    {
+      struct build_id_addr_sect *candidate;
+
+      candidate = xmalloc (sizeof *candidate);
+      candidate->next = build_id_addr_sect;
+      build_id_addr_sect = candidate;
+      candidate->sect = sect;
+    }
+}
+
+struct build_id *
+build_id_addr_get (CORE_ADDR addr)
+{
+  struct build_id_addr_sect *candidate;
+  struct build_id *retval = NULL;
+  Elf_Internal_Phdr *i_phdr = NULL;
+  bfd_vma loadbase = 0;
+  unsigned e_phnum = 0;
+
+  if (core_bfd == NULL)
+    return NULL;
+
+  build_id_addr = addr;
+  gdb_assert (build_id_addr_sect == NULL);
+  bfd_map_over_sections (core_bfd, build_id_addr_candidate, NULL);
+
+  /* Sections are sorted in the high-to-low VMAs order.
+     Stop the search on the first ELF header we find.
+     Do not continue the search even if it does not contain NT_GNU_BUILD_ID.  */
+
+  for (candidate = build_id_addr_sect; candidate != NULL;
+       candidate = candidate->next)
+    {
+      i_phdr = elf_get_phdr (core_bfd,
+			     bfd_section_vma (core_bfd, candidate->sect),
+			     &e_phnum, &loadbase);
+      if (i_phdr != NULL)
+	break;
+    }
+
+  if (i_phdr != NULL)
+    {
+      retval = build_id_phdr_get (core_bfd, loadbase, e_phnum, i_phdr);
+      xfree (i_phdr);
+    }
+
+  while (build_id_addr_sect != NULL)
+    {
+      candidate = build_id_addr_sect;
+      build_id_addr_sect = candidate->next;
+      xfree (candidate);
+    }
+
+  return retval;
+}
+
 /* Return if FILENAME has NT_GNU_BUILD_ID matching the CHECK value.  */
 
 static int
@@ -1265,7 +1660,7 @@ build_id_verify (const char *filename, s
   if (abfd == NULL)
     return 0;
 
-  found = build_id_bfd_get (abfd);
+  found = build_id_bfd_shdr_get (abfd);
 
   if (found == NULL)
     warning (_("File \"%s\" has no build-id, file skipped"), filename);
@@ -1281,8 +1676,9 @@ build_id_verify (const char *filename, s
   return retval;
 }
 
-static char *
-build_id_to_debug_filename (struct build_id *build_id)
+char *
+build_id_to_filename (struct build_id *build_id, char **link_return,
+		      int add_debug_suffix)
 {
   char *link, *s, *retval = NULL;
   gdb_byte *data = build_id->data;
@@ -1290,7 +1686,9 @@ build_id_to_debug_filename (struct build
 
   /* DEBUG_FILE_DIRECTORY/.build-id/ab/cdef */
   link = xmalloc (strlen (debug_file_directory) + (sizeof "/.build-id/" - 1) + 1
-		  + 2 * size + (sizeof ".debug" - 1) + 1);
+		  + 2 * size
+		  + (add_debug_suffix ? sizeof ".debug" - 1 : 0)
+		  + 1);
   s = link + sprintf (link, "%s/.build-id/", debug_file_directory);
   if (size > 0)
     {
@@ -1301,12 +1699,14 @@ build_id_to_debug_filename (struct build
     *s++ = '/';
   while (size-- > 0)
     s += sprintf (s, "%02x", (unsigned) *data++);
-  strcpy (s, ".debug");
+  if (add_debug_suffix)
+    strcpy (s, ".debug");
+  else
+    *s = 0;
 
   /* lrealpath() is expensive even for the usually non-existent files.  */
   if (access (link, F_OK) == 0)
     retval = lrealpath (link);
-  xfree (link);
 
   if (retval != NULL && !build_id_verify (retval, build_id))
     {
@@ -1314,9 +1714,437 @@ build_id_to_debug_filename (struct build
       retval = NULL;
     }
 
+  if (link_return != NULL)
+    *link_return = link;
+  else
+    xfree (link);
+
   return retval;
 }
 
+#include <rpm/rpmlib.h>
+#include <rpm/rpmts.h>
+#include <rpm/rpmdb.h>
+#include <rpm/header.h>
+
+/* This MISSING_RPM_HASH tracker is used to collect all the missing rpm files
+   and avoid their duplicities during a single inferior run.  */
+
+static struct htab *missing_rpm_hash;
+
+/* This MISSING_RPM_LIST tracker is used to collect and print as a single line
+   all the rpms right before the nearest GDB prompt.  It gets cleared after
+   each such print (it is questionable if we should clear it after the print).
+   */
+
+struct missing_rpm
+  {
+    struct missing_rpm *next;
+    char rpm[1];
+  };
+static struct missing_rpm *missing_rpm_list;
+static int missing_rpm_list_entries;
+
+/* Returns the count of newly added rpms.  */
+
+static int
+missing_rpm_enlist (const char *filename)
+{
+  static int rpm_init_done = 0;
+  rpmts ts;
+  rpmdbMatchIterator mi;
+  int count = 0;
+
+  if (filename == NULL)
+    return 0;
+
+  if (!rpm_init_done)
+    {
+      if (rpmReadConfigFiles(NULL, NULL) != 0)
+	{
+	  warning (_("Error reading the rpm configuration files"));
+	  return 0;
+	}
+      rpm_init_done = 1;
+    }
+
+  ts = rpmtsCreate ();
+
+  mi = rpmtsInitIterator (ts, RPMTAG_BASENAMES, filename, 0);
+  if (mi != NULL)
+    {
+      for (;;)
+	{
+	  Header h;
+	  char *s, *srcrpm, *verrel, *debuginfo;
+	  union
+	    {
+	      void *voidp;
+	      char *s;
+	    }
+	  sourcerpm, arch;
+	  char **slot;
+	  rpmdbMatchIterator mi_debuginfo;
+
+	  h = rpmdbNextIterator (mi);
+	  if (h == NULL)
+	    break;
+
+	  if (!headerGetEntry (h, RPMTAG_SOURCERPM, NULL, &sourcerpm.voidp,
+			       NULL))
+	    {
+	      warning (_("Error querying the rpm file `%s' %s"), filename,
+		       "RPMTAG_SOURCERPM");
+	      continue;
+	    }
+	  srcrpm = sourcerpm.s + strlen (sourcerpm.s) - (sizeof ".src.rpm" - 1);
+	  if (srcrpm < sourcerpm.s || strcmp (srcrpm, ".src.rpm") != 0)
+	    {
+error_parsing_sourcerpm:
+	      warning (_("Error parsing %%{sourcerpm} of the rpm file `%s': %s"),
+		       filename, sourcerpm.s);
+	      continue;
+	    }
+	  s = srcrpm;
+
+	  /* Skip the release.  */
+
+	  while (s > sourcerpm.s && s[-1] != '-')
+	    s--;
+	  if (s == sourcerpm.s)
+	    goto error_parsing_sourcerpm;
+	  s--;
+
+	  /* Skip the version.  */
+
+	  while (s > sourcerpm.s && s[-1] != '-')
+	    s--;
+	  if (s == sourcerpm.s)
+	    goto error_parsing_sourcerpm;
+	  s--;
+	  verrel = s;
+
+	  if (!headerGetEntry (h, RPMTAG_ARCH, NULL, &arch.voidp, NULL))
+	    {
+	      warning (_("Error querying the rpm file `%s' %s"), filename,
+		       "RPMTAG_ARCH");
+	      continue;
+	    }
+
+	  /* The allocated memory gets utilized below for MISSING_RPM_HASH.  */
+
+	  debuginfo = xmalloc (strlen (sourcerpm.s) + strlen (arch.s) + 32);
+
+	  /* Verify the debuginfo file is not already installed.  */
+
+	  sprintf (debuginfo, "%.*s-debuginfo%.*s.%s",
+		   (int) (verrel - sourcerpm.s), sourcerpm.s,
+		   (int) (srcrpm - verrel), verrel, arch.s);
+	  mi_debuginfo = rpmtsInitIterator (ts, RPMDBI_LABEL, debuginfo, 0);
+	  if (mi_debuginfo != NULL)
+	    {
+	      Header h_debuginfo;
+
+	      h_debuginfo = rpmdbNextIterator (mi_debuginfo);
+	      rpmdbFreeIterator (mi_debuginfo);
+	      if (h_debuginfo != NULL)
+		{
+		  xfree (debuginfo);
+
+		  /* We ignore any != 0 for possibly already enlisted rpms as
+		     it should not hurt much.  */
+
+		  count = 0;
+		  break;
+		}
+	    }
+
+	  /* Base package name for `debuginfo-install'.  We do not use `yum'
+	     as its command
+		 yum --enablerepo='*-debuginfo' install BASE-debuginfo.ARCH
+	     would be more complicated than just:
+		 debuginfo-install BASE.ARCH
+	     We do not need to supply the version-release as
+	     `debuginfo-install' always installs only the debuginfo matching
+	     the currently installed rpm.  Still we must supply `.%{arch}' as
+	     we may have multilib (multiple arch-differing rpm packages)
+	     installed.
+	     FUTURE: After multiple debuginfo versions simultaneously installed
+	     get supported we may need to supply the version-release here.  */
+
+	  sprintf (debuginfo, "%.*s.%s", (int) (verrel - sourcerpm.s),
+		   sourcerpm.s, arch.s);
+
+	  if (missing_rpm_hash == NULL)
+	    {
+	      /* DEL_F is passed NULL as MISSING_RPM_LIST's HTAB_DELETE
+		 should not deallocate the entries.  */
+
+	      missing_rpm_hash = htab_create_alloc (64, htab_hash_string,
+			       (int (*) (const void *, const void *)) streq,
+						    NULL, xcalloc, xfree);
+	    }
+	  slot = (char **) htab_find_slot (missing_rpm_hash, debuginfo, INSERT);
+	  /* XCALLOC never returns NULL.  */
+	  gdb_assert (slot != NULL);
+	  if (*slot == NULL)
+	    {
+	      struct missing_rpm *missing_rpm;
+
+	      *slot = debuginfo;
+
+	      missing_rpm = xmalloc (sizeof (*missing_rpm) + strlen (debuginfo));
+	      strcpy (missing_rpm->rpm, debuginfo);
+	      missing_rpm->next = missing_rpm_list;
+	      missing_rpm_list = missing_rpm;
+	      missing_rpm_list_entries++;
+	    }
+	  else
+	    xfree (debuginfo);
+	  count++;
+	}
+
+      rpmdbFreeIterator (mi);
+    }
+
+  rpmtsFree (ts);
+
+  return count;
+}
+
+static int
+missing_rpm_list_compar (const char *const *ap, const char *const *bp)
+{
+  return strcoll (*ap, *bp);
+}
+
+/* It returns a NULL-terminated array of strings needing to be FREEd.  It may
+   also return only NULL.  */
+
+static void
+missing_rpm_list_print (void)
+{
+  char **array, **array_iter;
+  struct missing_rpm *list_iter;
+  struct cleanup *cleanups;
+
+  if (missing_rpm_list_entries == 0)
+    return;
+
+  array = xmalloc (sizeof (*array) * missing_rpm_list_entries);
+  cleanups = make_cleanup (xfree, array);
+
+  array_iter = array;
+  for (list_iter = missing_rpm_list; list_iter != NULL;
+       list_iter = list_iter->next)
+    {
+      *array_iter++ = list_iter->rpm;
+    }
+  gdb_assert (array_iter == array + missing_rpm_list_entries);
+
+  qsort (array, missing_rpm_list_entries, sizeof (*array),
+	 (int (*) (const void *, const void *)) missing_rpm_list_compar);
+
+  printf_unfiltered (_("Missing separate debuginfos, use: %s"),
+		     "debuginfo-install");
+  for (array_iter = array; array_iter < array + missing_rpm_list_entries;
+       array_iter++)
+    {
+      putchar_unfiltered (' ');
+      puts_unfiltered (*array_iter);
+    }
+  putchar_unfiltered ('\n');
+
+  while (missing_rpm_list != NULL)
+    {
+      list_iter = missing_rpm_list;
+      missing_rpm_list = list_iter->next;
+      xfree (list_iter);
+    }
+  missing_rpm_list_entries = 0;
+
+  do_cleanups (cleanups);
+}
+
+static void
+missing_rpm_change (void)
+{
+  debug_flush_missing ();
+
+  gdb_assert (missing_rpm_list == NULL);
+  if (missing_rpm_hash != NULL)
+    {
+      htab_delete (missing_rpm_hash);
+      missing_rpm_hash = NULL;
+    }
+}
+
+enum missing_exec
+  {
+    /* Init state.  EXEC_BFD also still could be NULL.  */
+    MISSING_EXEC_NOT_TRIED,
+    /* We saw a non-NULL EXEC_BFD but RPM has no info about it.  */
+    MISSING_EXEC_NOT_FOUND,
+    /* We found EXEC_BFD by RPM and we either have its symbols (either embedded
+       or separate) or the main executable's RPM is now contained in
+       MISSING_RPM_HASH.  */
+    MISSING_EXEC_ENLISTED
+  };
+static enum missing_exec missing_exec = MISSING_EXEC_NOT_TRIED;
+
+void
+debug_flush_missing (void)
+{
+  missing_rpm_list_print ();
+}
+
+/* This MISSING_FILEPAIR_HASH tracker is used only for the duplicite messages
+     yum --enablerepo='*-debuginfo' install ...
+   avoidance.  */
+
+struct missing_filepair
+  {
+    char *binary;
+    char *debug;
+    char data[1];
+  };
+
+static struct htab *missing_filepair_hash;
+static struct obstack missing_filepair_obstack;
+
+static void *
+missing_filepair_xcalloc (size_t nmemb, size_t nmemb_size)
+{
+  void *retval;
+  size_t size = nmemb * nmemb_size;
+
+  retval = obstack_alloc (&missing_filepair_obstack, size);
+  memset (retval, 0, size);
+  return retval;
+}
+
+static hashval_t
+missing_filepair_hash_func (const struct missing_filepair *elem)
+{
+  hashval_t retval = 0;
+
+  retval ^= htab_hash_string (elem->binary);
+  if (elem->debug != NULL)
+    retval ^= htab_hash_string (elem->debug);
+
+  return retval;
+}
+
+static int
+missing_filepair_eq (const struct missing_filepair *elem1,
+		       const struct missing_filepair *elem2)
+{
+  return strcmp (elem1->binary, elem2->binary) == 0
+         && ((elem1->debug == NULL && elem2->debug == NULL)
+	     || strcmp (elem1->debug, elem2->debug) == 0);
+}
+
+static void
+missing_filepair_change (void)
+{
+  if (missing_filepair_hash != NULL)
+    {
+      obstack_free (&missing_filepair_obstack, NULL);
+      /* All their memory came just from missing_filepair_OBSTACK.  */
+      missing_filepair_hash = NULL;
+    }
+  missing_exec = MISSING_EXEC_NOT_TRIED;
+}
+
+static void
+debug_print_executable_changed (void *unused)
+{
+  missing_rpm_change ();
+  missing_filepair_change ();
+}
+
+/* Notify user the file BINARY with (possibly NULL) associated separate debug
+   information file DEBUG is missing.  DEBUG may or may not be the build-id
+   file such as would be:
+     /usr/lib/debug/.build-id/dd/b1d2ce632721c47bb9e8679f369e2295ce71be.debug
+   */
+
+void
+debug_print_missing (const char *binary, const char *debug)
+{
+  size_t binary_len0 = strlen (binary) + 1;
+  size_t debug_len0 = debug ? strlen (debug) + 1 : 0;
+  struct missing_filepair *missing_filepair;
+  struct missing_filepair **slot;
+
+  if (build_id_verbose < BUILD_ID_VERBOSE_FILENAMES)
+    return;
+
+  if (missing_filepair_hash == NULL)
+    {
+      obstack_init (&missing_filepair_obstack);
+      missing_filepair_hash = htab_create_alloc (64,
+	(hashval_t (*) (const void *)) missing_filepair_hash_func,
+	(int (*) (const void *, const void *)) missing_filepair_eq, NULL,
+	missing_filepair_xcalloc, NULL);
+    }
+
+  missing_filepair = obstack_alloc (&missing_filepair_obstack,
+				      sizeof (*missing_filepair) - 1
+				      + binary_len0 + debug_len0);
+  missing_filepair->binary = missing_filepair->data;
+  memcpy (missing_filepair->binary, binary, binary_len0);
+  if (debug != NULL)
+    {
+      missing_filepair->debug = missing_filepair->binary + binary_len0;
+      memcpy (missing_filepair->debug, debug, debug_len0);
+    }
+  else
+    missing_filepair->debug = NULL;
+
+  slot = (struct missing_filepair **) htab_find_slot (missing_filepair_hash,
+							missing_filepair,
+							INSERT);
+
+  /* While it may be still printed duplicitely with the missing debuginfo file
+   * it is due to once printing about the binary file build-id link and once
+   * about the .debug file build-id link as both the build-id symlinks are
+   * located in the debuginfo package.  */
+
+  if (*slot != NULL)
+    {
+      obstack_free (&missing_filepair_obstack, missing_filepair);
+      return;
+    }
+  *slot = missing_filepair;
+
+  if (missing_exec == MISSING_EXEC_NOT_TRIED)
+    {
+      char *exec_filename;
+
+      exec_filename = get_exec_file (0);
+      if (exec_filename != NULL)
+	{
+	  if (missing_rpm_enlist (exec_filename) == 0)
+	    missing_exec = MISSING_EXEC_NOT_FOUND;
+	  else
+	    missing_exec = MISSING_EXEC_ENLISTED;
+	}
+    }
+  if (missing_exec != MISSING_EXEC_ENLISTED)
+    if (missing_rpm_enlist (binary) == 0 && missing_rpm_enlist (debug) == 0)
+      {
+	/* We do not collect and flush these messages as each such message
+	   already requires its own separate lines.  */
+
+	fprintf_unfiltered (gdb_stdlog,
+			    _("Missing separate debuginfo for %s\n"), binary);
+        if (debug != NULL)
+	  fprintf_unfiltered (gdb_stdlog, _("Try: %s %s\n"),
+			      "yum --enablerepo='*-debuginfo' install", debug);
+      }
+}
+
 static char *
 get_debug_link_info (struct objfile *objfile, unsigned long *crc32_out)
 {
@@ -1402,32 +2231,36 @@ static char *
 find_separate_debug_file (struct objfile *objfile)
 {
   asection *sect;
-  char *basename;
-  char *dir;
-  char *debugfile;
+  char *basename = NULL;
+  char *dir = NULL;
+  char *debugfile = NULL;
   char *name_copy;
-  char *canon_name;
+  char *canon_name = NULL;
   bfd_size_type debuglink_size;
   unsigned long crc32;
   int i;
   struct build_id *build_id;
+  char *build_id_filename = NULL;
 
-  build_id = build_id_bfd_get (objfile->obfd);
+  build_id = build_id_bfd_shdr_get (objfile->obfd);
   if (build_id != NULL)
     {
       char *build_id_name;
 
-      build_id_name = build_id_to_debug_filename (build_id);
-      free (build_id);
+      build_id_name = build_id_to_filename (build_id, &build_id_filename, 1);
+      xfree (build_id);
       /* Prevent looping on a stripped .debug file.  */
       if (build_id_name != NULL && strcmp (build_id_name, objfile->name) == 0)
         {
-	  warning (_("\"%s\": separate debug info file has no debug info"),
+	  warning (_("\"%s\": The separate debug info file has no debug info"),
 		   build_id_name);
 	  xfree (build_id_name);
 	}
       else if (build_id_name != NULL)
-        return build_id_name;
+        {
+	  xfree (build_id_filename);
+	  return build_id_name;
+	}
     }
 
   basename = get_debug_link_info (objfile, &crc32);
@@ -1435,7 +2268,7 @@ find_separate_debug_file (struct objfile
   if (basename == NULL)
     /* There's no separate debug info, hence there's no way we could
        load it => no warning.  */
-    return NULL;
+    goto cleanup_return_debugfile;
 
   dir = xstrdup (objfile->name);
 
@@ -1451,23 +2284,19 @@ find_separate_debug_file (struct objfile
   gdb_assert (i >= 0 && IS_DIR_SEPARATOR (dir[i]));
   dir[i+1] = '\0';
 
-  debugfile = alloca (strlen (debug_file_directory) + 1
-                      + strlen (dir)
-                      + strlen (DEBUG_SUBDIRECTORY)
-                      + strlen ("/")
-                      + strlen (basename)
-                      + 1);
+  debugfile = xmalloc (strlen (debug_file_directory) + 1
+		       + strlen (dir)
+		       + strlen (DEBUG_SUBDIRECTORY)
+		       + strlen ("/")
+		       + strlen (basename)
+		       + 1);
 
   /* First try in the same directory as the original file.  */
   strcpy (debugfile, dir);
   strcat (debugfile, basename);
 
   if (separate_debug_file_exists (debugfile, crc32, objfile->name))
-    {
-      xfree (basename);
-      xfree (dir);
-      return xstrdup (debugfile);
-    }
+    goto cleanup_return_debugfile;
 
   /* Then try in the subdirectory named DEBUG_SUBDIRECTORY.  */
   strcpy (debugfile, dir);
@@ -1476,11 +2305,7 @@ find_separate_debug_file (struct objfile
   strcat (debugfile, basename);
 
   if (separate_debug_file_exists (debugfile, crc32, objfile->name))
-    {
-      xfree (basename);
-      xfree (dir);
-      return xstrdup (debugfile);
-    }
+    goto cleanup_return_debugfile;
 
   /* Then try in the global debugfile directory.  */
   strcpy (debugfile, debug_file_directory);
@@ -1489,11 +2314,7 @@ find_separate_debug_file (struct objfile
   strcat (debugfile, basename);
 
   if (separate_debug_file_exists (debugfile, crc32, objfile->name))
-    {
-      xfree (basename);
-      xfree (dir);
-      return xstrdup (debugfile);
-    }
+    goto cleanup_return_debugfile;
 
   /* If the file is in the sysroot, try using its base path in the
      global debugfile directory.  */
@@ -1508,20 +2329,18 @@ find_separate_debug_file (struct objfile
       strcat (debugfile, basename);
 
       if (separate_debug_file_exists (debugfile, crc32, objfile->name))
-	{
-	  xfree (canon_name);
-	  xfree (basename);
-	  xfree (dir);
-	  return xstrdup (debugfile);
-	}
+        goto cleanup_return_debugfile;
     }
-  
-  if (canon_name)
-    xfree (canon_name);
 
+  debugfile = NULL;
+  debug_print_missing (objfile->name, build_id_filename);
+
+cleanup_return_debugfile:
+  xfree (build_id_filename);
+  xfree (canon_name);
   xfree (basename);
   xfree (dir);
-  return NULL;
+  return debugfile;
 }
 
 
@@ -4208,4 +5027,16 @@ the global debug-file directory prepende
 				     NULL,
 				     show_debug_file_directory,
 				     &setlist, &showlist);
+
+  add_setshow_zinteger_cmd ("build-id-verbose", no_class, &build_id_verbose,
+			    _("\
+Set debugging level of the build-id locator."), _("\
+Show debugging level of the build-id locator."), _("\
+Level 1 (default) enables printing the missing debug filenames,\n\
+level 2 also prints the parsing of binaries to find the identificators."),
+			    NULL,
+			    show_build_id_verbose,
+			    &setlist, &showlist);
+
+  observer_attach_executable_changed (debug_print_executable_changed);
 }
--- ./gdb/symfile.h	2008-02-03 23:13:29.000000000 +0100
+++ ./gdb/symfile.h	2008-08-21 00:28:43.000000000 +0200
@@ -358,6 +358,14 @@ extern int symfile_map_offsets_to_segmen
 struct symfile_segment_data *get_symfile_segment_data (bfd *abfd);
 void free_symfile_segment_data (struct symfile_segment_data *data);
 
+/* build-id support.  */
+struct build_id;
+extern struct build_id *build_id_addr_get (CORE_ADDR addr);
+extern char *build_id_to_filename (struct build_id *build_id,
+				   char **link_return, int add_debug_suffix);
+extern void debug_print_missing (const char *binary, const char *debug);
+extern void debug_flush_missing (void);
+
 /* From dwarf2read.c */
 
 extern int dwarf2_has_info (struct objfile *);
--- ./gdb/testsuite/lib/gdb.exp	2008-08-21 00:29:46.000000000 +0200
+++ ./gdb/testsuite/lib/gdb.exp	2008-08-21 00:28:43.000000000 +0200
@@ -1199,6 +1199,16 @@ proc default_gdb_start { } {
 	    warning "Couldn't set the width to 0."
 	}
     }
+    # Turn off the missing RPMs warnings as the testsuite does not expect it.
+    send_gdb "set build-id-verbose 0\n"
+    gdb_expect 10 {
+	-re "$gdb_prompt $" {
+	    verbose "Disabled the missing debug infos warnings." 2
+	}
+	timeout {
+	    warning "Could not disable the missing debug infos warnings.."
+	}
+    }
     return 0;
 }
 
--- ./gdb/tui/tui-interp.c	2008-01-01 23:53:22.000000000 +0100
+++ ./gdb/tui/tui-interp.c	2008-08-21 00:28:43.000000000 +0200
@@ -30,6 +30,7 @@
 #include "tui/tui.h"
 #include "tui/tui-io.h"
 #include "exceptions.h"
+#include "symfile.h"
 
 /* Set to 1 when the TUI mode must be activated when we first start
    gdb.  */
@@ -128,6 +129,8 @@ tui_command_loop (void *data)
       char *a_prompt;
       char *gdb_prompt = get_prompt ();
 
+      debug_flush_missing ();
+
       /* Tell readline what the prompt to display is and what function
          it will need to call after a whole line is read. This also
          displays the first prompt.  */
