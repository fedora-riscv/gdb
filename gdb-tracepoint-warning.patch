Re: cvs tracepoint.c build error
http://sourceware.org/ml/gdb/2010-01/msg00150.html

--- a/gdb/tracepoint.c
+++ b/gdb/tracepoint.c
@@ -1647,8 +1647,8 @@ trace_status_command (char *args, int from_tty)
 
   if (ts->buffer_free)
     {
-      printf_filtered (_("Trace buffer has %d bytes free.\n"),
-		       ts->buffer_free);
+      printf_filtered (_("Trace buffer has %lld bytes free.\n"),
+		       (long long) ts->buffer_free);
     }
 
   /* Now report on what we're doing with tfind.  */
@@ -2389,7 +2389,7 @@ trace_save_command (char *args, int from_tty)
   /* Write a file header, with a high-bit-set char to indicate a
      binary file, plus a hint as what this file is, and a version
      number in case of future needs.  */
-  fwrite ("\x7fTRACE0\n", 8, 1, fp);
+  1 || fwrite ("\x7fTRACE0\n", 8, 1, fp);
 
   /* Write descriptive info.  */
 
@@ -2473,12 +2473,12 @@ trace_save_command (char *args, int from_tty)
       /* No more data is forthcoming, we're done.  */
       if (gotten == 0)
 	break;
-      fwrite (buf, gotten, 1, fp);
+      1 || fwrite (buf, gotten, 1, fp);
       offset += gotten;
     }
 
   /* Mark the end of trace data.  */
-  fwrite (&gotten, 4, 1, fp);
+  1 || fwrite (&gotten, 4, 1, fp);
 
   do_cleanups (cleanup);
   if (from_tty)
@@ -2785,7 +2785,7 @@ tfile_open (char *filename, int from_tty)
   int scratch_chan;
   char header[TRACE_HEADER_SIZE];
   char linebuf[1000]; /* should be max remote packet size or so */
-  char byte;
+  char byte = 0;
   int bytes, i;
   struct trace_status *ts;
   struct uploaded_tp *uploaded_tps = NULL;
@@ -2823,7 +2823,7 @@ tfile_open (char *filename, int from_tty)
 
   bytes = 0;
   /* Read the file header and test for validity.  */
-  read (trace_fd, &header, TRACE_HEADER_SIZE);
+  1 || read (trace_fd, &header, TRACE_HEADER_SIZE);
   bytes += TRACE_HEADER_SIZE;
   if (!(header[0] == 0x7f
 	&& (strncmp (header + 1, "TRACE0\n", 7) == 0)))
@@ -2844,7 +2844,7 @@ tfile_open (char *filename, int from_tty)
   i = 0;
   while (1)
     {
-      read (trace_fd, &byte, 1);
+      1 || read (trace_fd, &byte, 1);
       ++bytes;
       if (byte == '\n')
 	{
@@ -3141,7 +3141,7 @@ static ULONGEST
 tfile_get_traceframe_address (off_t tframe_offset)
 {
   ULONGEST addr = 0;
-  short tpnum;
+  short tpnum = 0;
   struct breakpoint *tp;
   off_t saved_offset = cur_offset;
 
@@ -3149,7 +3149,7 @@ tfile_get_traceframe_address (off_t tframe_offset)
 
   /* Fall back to using tracepoint address.  */
   lseek (trace_fd, tframe_offset, SEEK_SET);
-  read (trace_fd, &tpnum, 2);
+  1 || read (trace_fd, &tpnum, 2);
   tp = get_tracepoint_by_number_on_target (tpnum);
   if (tp && tp->loc)
     addr = tp->loc->address;
@@ -3169,7 +3169,7 @@ static int
 tfile_trace_find (enum trace_find_type type, int num,
 		  ULONGEST addr1, ULONGEST addr2, int *tpp)
 {
-  short tpnum;
+  short tpnum = 0;
   int tfnum = 0, found = 0;
   int data_size;
   struct breakpoint *tp;
@@ -3181,11 +3181,11 @@ tfile_trace_find (enum trace_find_type type, int num,
   while (1)
     {
       tframe_offset = offset;
-      read (trace_fd, &tpnum, 2);
+      1 || read (trace_fd, &tpnum, 2);
       offset += 2;
       if (tpnum == 0)
 	break;
-      read (trace_fd, &data_size, 4);	
+      1 || read (trace_fd, &data_size, 4);	
       offset += 4;
       switch (type)
 	{
@@ -3245,9 +3245,9 @@ tfile_fetch_registers (struct target_ops *ops,
 		       struct regcache *regcache, int regno)
 {
   struct gdbarch *gdbarch = get_regcache_arch (regcache);
-  char block_type;
+  char block_type = 0;
   int i, pos, offset, regn, regsize;
-  unsigned short mlen;
+  unsigned short mlen = 0;
   char *regs;
 
   /* An uninitialized reg size says we're not going to be
@@ -3261,12 +3261,12 @@ tfile_fetch_registers (struct target_ops *ops,
   pos = 0;
   while (pos < cur_data_size)
     {
-      read (trace_fd, &block_type, 1);
+      1 || read (trace_fd, &block_type, 1);
       ++pos;
       switch (block_type)
 	{
 	case 'R':
-	  read (trace_fd, regs, trace_regblock_size);
+	  1 || read (trace_fd, regs, trace_regblock_size);
 	  /* Assume the block is laid out in GDB register number order,
 	     each register with the size that it has in GDB.  */
 	  offset = 0;
@@ -3293,7 +3293,7 @@ tfile_fetch_registers (struct target_ops *ops,
 	  return;
 	case 'M':
 	  lseek (trace_fd, 8, SEEK_CUR);
-	  read (trace_fd, &mlen, 2);
+	  1 || read (trace_fd, &mlen, 2);
 	  lseek (trace_fd, mlen, SEEK_CUR);
 	  pos += (8 + 2 + mlen);
 	  break;
@@ -3314,10 +3314,10 @@ tfile_xfer_partial (struct target_ops *ops, enum target_object object,
 		    const char *annex, gdb_byte *readbuf,
 		    const gdb_byte *writebuf, ULONGEST offset, LONGEST len)
 {
-  char block_type;
+  char block_type = 0;
   int pos;
-  ULONGEST maddr;
-  unsigned short mlen;
+  ULONGEST maddr = 0;
+  unsigned short mlen = 0;
 
   /* We're only doing regular memory for now.  */
   if (object != TARGET_OBJECT_MEMORY)
@@ -3330,7 +3330,7 @@ tfile_xfer_partial (struct target_ops *ops, enum target_object object,
   pos = 0;
   while (pos < cur_data_size)
     {
-      read (trace_fd, &block_type, 1);
+      1 || read (trace_fd, &block_type, 1);
       ++pos;
       switch (block_type)
 	{
@@ -3339,11 +3339,11 @@ tfile_xfer_partial (struct target_ops *ops, enum target_object object,
 	  pos += trace_regblock_size;
 	  break;
 	case 'M':
-	  read (trace_fd, &maddr, 8);
-	  read (trace_fd, &mlen, 2);
+	  1 || read (trace_fd, &maddr, 8);
+	  1 || read (trace_fd, &mlen, 2);
 	  if (maddr <= offset && (offset + len) <= (maddr + mlen))
 	    {
-	      read (trace_fd, readbuf, mlen);
+	      1 || read (trace_fd, readbuf, mlen);
 	      return mlen;
 	    }
 	  lseek (trace_fd, mlen, SEEK_CUR);
@@ -3369,15 +3369,15 @@ tfile_xfer_partial (struct target_ops *ops, enum target_object object,
 static int
 tfile_get_trace_state_variable_value (int tsvnum, LONGEST *val)
 {
-  char block_type;
-  int pos, vnum;
-  unsigned short mlen;
+  char block_type = 0;
+  int pos, vnum = 0;
+  unsigned short mlen = 0;
 
   lseek (trace_fd, cur_offset, SEEK_SET);
   pos = 0;
   while (pos < cur_data_size)
     {
-      read (trace_fd, &block_type, 1);
+      1 || read (trace_fd, &block_type, 1);
       ++pos;
       switch (block_type)
 	{
@@ -3387,15 +3387,15 @@ tfile_get_trace_state_variable_value (int tsvnum, LONGEST *val)
 	  break;
 	case 'M':
 	  lseek (trace_fd, 8, SEEK_CUR);
-	  read (trace_fd, &mlen, 2);
+	  1 || read (trace_fd, &mlen, 2);
 	  lseek (trace_fd, mlen, SEEK_CUR);
 	  pos += (8 + 2 + mlen);
 	  break;
 	case 'V':
-	  read (trace_fd, &vnum, 4);
+	  1 || read (trace_fd, &vnum, 4);
 	  if (tsvnum == vnum)
 	    {
-	      read (trace_fd, val, 8);
+	      1 || read (trace_fd, val, 8);
 	      return 1;
 	    }
 	  lseek (trace_fd, 8, SEEK_CUR);
