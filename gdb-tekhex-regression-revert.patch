-R for 85880250e591a51624d24db653aaace0c5ce5943
https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;a=commitdiff;h=85880250e591a51624d24db653aaace0c5ce5943;hp=fce10a8494efa8faec

[buildbot] GDB regression on 85880250e591a51624d24db653aaace0c5ce5943
https://sourceware.org/ml/binutils/2015-01/msg00044.html

diff --git a/bfd/coff-i860.c b/bfd/coff-i860.c
index 8573a8d..2122c0d 100644
--- a/bfd/coff-i860.c
+++ b/bfd/coff-i860.c
@@ -467,10 +467,7 @@ static reloc_howto_type howto_table[] =
    FIXME: This macro refers to symbols and asect; these are from the
    calling function, not the macro arguments.  */
 
-/* PR 17512: file: 0a38fb7c
-   Set an addend value, even if it is not going to be used.  A tool
-   like coffdump might be used to print out the contents of the reloc.  */
-#define CALC_ADDEND(abfd, ptr, reloc, cache_ptr) (cache_ptr)->addend = 0
+#define CALC_ADDEND(abfd, ptr, reloc, cache_ptr)
 
 /* We use the special COFF backend linker.  */
 #define coff_relocate_section _bfd_coff_generic_relocate_section
diff --git a/bfd/tekhex.c b/bfd/tekhex.c
index 9444117..969b812 100644
--- a/bfd/tekhex.c
+++ b/bfd/tekhex.c
@@ -267,7 +267,7 @@ typedef struct tekhex_data_struct
 #define enda(x) (x->vma + x->size)
 
 static bfd_boolean
-getvalue (char **srcp, bfd_vma *valuep, char * endp)
+getvalue (char **srcp, bfd_vma *valuep)
 {
   char *src = *srcp;
   bfd_vma value = 0;
@@ -279,7 +279,7 @@ getvalue (char **srcp, bfd_vma *valuep, char * endp)
   len = hex_value (*src++);
   if (len == 0)
     len = 16;
-  while (len-- && src < endp)
+  while (len--)
     {
       if (!ISHEX (*src))
 	return FALSE;
@@ -288,11 +288,11 @@ getvalue (char **srcp, bfd_vma *valuep, char * endp)
 
   *srcp = src;
   *valuep = value;
-  return len == 0;
+  return TRUE;
 }
 
 static bfd_boolean
-getsym (char *dstp, char **srcp, unsigned int *lenp, char * endp)
+getsym (char *dstp, char **srcp, unsigned int *lenp)
 {
   char *src = *srcp;
   unsigned int i;
@@ -304,7 +304,7 @@ getsym (char *dstp, char **srcp, unsigned int *lenp, char * endp)
   len = hex_value (*src++);
   if (len == 0)
     len = 16;
-  for (i = 0; i < len && src < endp; i++)
+  for (i = 0; i < len; i++)
     dstp[i] = src[i];
   dstp[i] = 0;
   *srcp = src + i;
@@ -354,7 +354,7 @@ insert_byte (bfd *abfd, int value, bfd_vma addr)
   how big the data is.  */
 
 static bfd_boolean
-first_phase (bfd *abfd, int type, char *src, char * src_end)
+first_phase (bfd *abfd, int type, char *src)
 {
   asection *section, *alt_section;
   unsigned int len;
@@ -368,21 +368,21 @@ first_phase (bfd *abfd, int type, char *src, char * src_end)
       {
 	bfd_vma addr;
 
-	if (!getvalue (&src, &addr, src_end))
+	if (!getvalue (&src, &addr))
 	  return FALSE;
 
-	while (*src && src < src_end - 1)
+	while (*src)
 	  {
 	    insert_byte (abfd, HEX (src), addr);
 	    src += 2;
 	    addr++;
 	  }
-	return TRUE;
       }
 
+      return TRUE;
     case '3':
       /* Symbol record, read the segment.  */
-      if (!getsym (sym, &src, &len, src_end))
+      if (!getsym (sym, &src, &len))
 	return FALSE;
       section = bfd_get_section_by_name (abfd, sym);
       if (section == NULL)
@@ -403,9 +403,9 @@ first_phase (bfd *abfd, int type, char *src, char * src_end)
 	    {
 	    case '1':		/* Section range.  */
 	      src++;
-	      if (!getvalue (&src, &section->vma, src_end))
+	      if (!getvalue (&src, &section->vma))
 		return FALSE;
-	      if (!getvalue (&src, &val, src_end))
+	      if (!getvalue (&src, &val))
 		return FALSE;
 	      section->size = val - section->vma;
 	      section->flags = SEC_HAS_CONTENTS | SEC_LOAD | SEC_ALLOC;
@@ -432,7 +432,7 @@ first_phase (bfd *abfd, int type, char *src, char * src_end)
 		abfd->flags |= HAS_SYMS;
 		new_symbol->prev = abfd->tdata.tekhex_data->symbols;
 		abfd->tdata.tekhex_data->symbols = new_symbol;
-		if (!getsym (sym, &src, &len, src_end))
+		if (!getsym (sym, &src, &len))
 		  return FALSE;
 		new_symbol->symbol.name = (const char *)
                     bfd_alloc (abfd, (bfd_size_type) len + 1);
@@ -480,7 +480,7 @@ first_phase (bfd *abfd, int type, char *src, char * src_end)
 			new_symbol->symbol.section = alt_section;
 		      }
 		  }
-		if (!getvalue (&src, &val, src_end))
+		if (!getvalue (&src, &val))
 		  return FALSE;
 		new_symbol->symbol.value = val - section->vma;
 		break;
@@ -498,7 +498,7 @@ first_phase (bfd *abfd, int type, char *src, char * src_end)
    record.  */
 
 static bfd_boolean
-pass_over (bfd *abfd, bfd_boolean (*func) (bfd *, int, char *, char *))
+pass_over (bfd *abfd, bfd_boolean (*func) (bfd *, int, char *))
 {
   unsigned int chars_on_line;
   bfd_boolean is_eof = FALSE;
@@ -539,7 +539,8 @@ pass_over (bfd *abfd, bfd_boolean (*func) (bfd *, int, char *, char *))
 
       /* Put a null at the end.  */
       src[chars_on_line] = 0;
-      if (!func (abfd, type, src, src + chars_on_line))
+
+      if (!func (abfd, type, src))
 	return FALSE;
     }
 
